// helpsys DB - embedding DB as JS object here instead of reading it from JSON file.

let __vexdev__vex_code_editor__help_data = {"Namespaces":{"vex":{"name":"vex","members":{"percentUnits":{"name":"percentUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"pct","desc":"A percentage unit that represents a value from 0% to 100%."}],"desc":"The measurement units for percentage values."},"timeUnits":{"name":"timeUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"sec","desc":"A time unit that is measured in seconds."},{"name":"msec","desc":"A time unit that is measured in milliseconds."}],"desc":"The measurement units for time values."},"currentUnits":{"name":"currentUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"amp","desc":"A current unit that is measured in amps."}],"desc":"The measurement units for current values."},"voltageUnits":{"name":"voltageUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"volt","desc":"A voltage unit that is measured in volts."},{"name":"mV","desc":"The measurement units for power values millivolts."}],"desc":"The measurement units for voltage values."},"powerUnits":{"name":"powerUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"watt","desc":"A power unit that is measured in watts."}],"desc":"The measurement units for power values."},"torqueUnits":{"name":"torqueUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"Nm","desc":"A torque unit that is measured in Newton Meters."},{"name":"InLb","desc":"A torque unit that is measured in Inch Pounds."}],"desc":"The measurement units for torque values."},"rotationUnits":{"name":"rotationUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"deg","desc":"A rotation unit that is measured in degrees."},{"name":"rev","desc":"A rotation unit that is measured in revolutions."},{"name":"raw","desc":"A rotation unit that is measured in raw data form."}],"desc":"The measurement units for rotation values."},"velocityUnits":{"name":"velocityUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"pct","desc":"A velocity unit that is measured in percentage."},{"name":"rpm","desc":"A velocity unit that is measured in rotations per minute."},{"name":"dps","desc":"A velocity unit that is measured in degrees per second."}],"desc":"The measurement units for velocity values."},"distanceUnits":{"name":"distanceUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"mm","desc":"A distance unit that is measured in millimeters."},{"name":"in","desc":"A distance unit that is measured in inches."},{"name":"cm","desc":"A distance unit that is measured in centimeters."}],"desc":"The measurement units for distance values."},"analogUnits":{"name":"analogUnits","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"pct","desc":"An analog unit that is measured in percentage."},{"name":"range8bit","desc":"An analog unit that is measured in an 8-bit analog value (a value with 256 possible states)."},{"name":"range10bit","desc":"An analog unit that is measured in a 10-bit analog value (a value with 1024 possible states)."},{"name":"range12bit","desc":"An analog unit that is measured in a 12-bit analog value (a value with 4096 possible states)."},{"name":"mV","desc":"An analog unit that is measured in millivolts."}],"desc":"The measurement units for analog values."},"directionType":{"name":"directionType","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"fwd","desc":"A direction unit that is defined as forward."},{"name":"rev","desc":"A direction unit that is defined as backward."}],"desc":"The defined units for direction values."},"brakeType":{"name":"brakeType","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"coast","desc":"A brake unit that is defined as coast."},{"name":"brake","desc":"A brake unit that is defined as brake."},{"name":"hold","desc":"A brake unit that is defined as hold."}],"desc":"The defined units for brake values."},"gearSetting":{"name":"gearSetting","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"ratio36_1","desc":"A gear unit that is defined as the red 36:1 gear cartridge used in V5 Smart Motors."},{"name":"ratio18_1","desc":"A gear unit that is defined as the green 18:1 gear cartridge used in V5 Smart Motors."},{"name":"ratio6_1","desc":"A gear unit that is defined as the blue 6:1 gear cartridge used in V5 Smart Motors."}],"desc":"The defined units for gear values."},"fontType":{"name":"fontType","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"mono20","desc":"A font unit that is defined as mono20."},{"name":"mono30","desc":"A font unit that is defined as mono30."},{"name":"mono40","desc":"A font unit that is defined as mono40."},{"name":"mono60","desc":"A font unit that is defined as mono60."},{"name":"prop20","desc":"A font unit that is defined as prop20."},{"name":"prop30","desc":"A font unit that is defined as prop30."},{"name":"prop40","desc":"A font unit that is defined as prop40."},{"name":"prop60","desc":"A font unit that is defined as prop60."},{"name":"mono15","desc":"A font unit that is defined as mono15."},{"name":"mono12","desc":"A font unit that is defined as mono12."}],"desc":"The defined units for font values."},"triportType":{"name":"triportType","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"analogInput","desc":"A triport unit that is defined as an analog input."},{"name":"analogOutput","desc":"A triport unit that is defined as an analog output."},{"name":"digitalInput","desc":"A triport unit that is defined as a digital input."},{"name":"digitalOutput","desc":"A triport unit that is defined as a digital output."},{"name":"button","desc":"A triport unit that is defined as a button."},{"name":"potentiometer","desc":"A triport unit that is defined as a potentiometer."},{"name":"lineSensor","desc":"A triport unit that is defined as a line sensor."},{"name":"lightSensor","desc":"A triport unit that is defined as a light sensor."},{"name":"gyro","desc":"A triport unit that is defined as a gyro."},{"name":"accelerometer","desc":"A triport unit that is defined as an accelerometer."},{"name":"motor","desc":"A triport unit that is defined as a motor."},{"name":"servo","desc":"A triport unit that is defined as a servo."},{"name":"quadEncoder","desc":"A triport unit that is defined as a quadrature encoder."},{"name":"sonar","desc":"A triport unit that is defined as a sonar."},{"name":"motorS","desc":"A triport unit that is defined as a motor with slew rate control."}],"desc":"The defined units for triport devices."},"controllerType":{"name":"controllerType","kind":"enum","type":[""],"def":"","apilevel":[],"drawercat":"","static":false,"enumvalue":[{"name":"primary","desc":"A controller unit defined as a primary controller."},{"name":"partner","desc":"A controller unit defined as a partner controller."}],"desc":"The defined units for controller devices."}},"Classes":{"vex::accelerometer":{"name":"vex::accelerometer","members":{"accelerometer":{"name":"accelerometer","kind":"function","type":[""],"specialkind":"constructor","def":"vex::accelerometer::accelerometer","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new accelerometer object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::accelerometer::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(analogUnits units)","desc":"Gets the value of the accelerometer.","params":[{"type":"vex::analogUnits","kind":"enum","declname":"units","desc":"The measurement unit for the accelerometer device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the value of the accelerometer.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the accelerometer device."}]}],"apilevel":["cpp","pro","block"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::accelerometer::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the accelerometer value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with an accelerometer sensor.","id":"classvex_1_1accelerometer","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::analog_in":{"name":"vex::analog_in","members":{"analog_in":{"name":"analog_in","kind":"function","type":[""],"specialkind":"constructor","def":"vex::analog_in::analog_in","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new analog-in object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::analog_in::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(analogUnits units)","desc":"Gets the value of the analog-in device.","params":[{"type":"vex::analogUnits","kind":"enum","declname":"units","desc":"The measurement unit for the analog-in device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the value of the analog-in device.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the analog-in device."}]}],"apilevel":["cpp","pro","block"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::analog_in::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the analog input value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with an analog-in device.","id":"classvex_1_1analog__in","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::brain":{"name":"vex::brain","members":{"Timer":{"name":"Timer","kind":"variable","type":["vex::timer"],"specialkind":"none","def":"vex::timer vex::brain::Timer","static":false,"desc":"Use the Timer class to obtain the system time.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Screen":{"name":"Screen","kind":"variable","type":["vex::brain::lcd"],"specialkind":"none","def":"lcd vex::brain::Screen","static":false,"desc":"Use the Screen class to write or draw to the screen.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Battery":{"name":"Battery","kind":"variable","type":["vex::brain::battery"],"specialkind":"none","def":"battery vex::brain::Battery","static":false,"desc":"This is the Brain's instance of the battery.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"SDcard":{"name":"SDcard","kind":"variable","type":["vex::brain::sdcard"],"specialkind":"none","def":"sdcard vex::brain::SDcard","static":false,"desc":"This is the instance of the SD card class.","apilevel":["pro"],"drawercat":"instance"},"brain":{"name":"brain","kind":"function","type":[""],"specialkind":"constructor","def":"vex::brain::brain","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"()","desc":"Creates a new brain object.","params":[]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"timer":{"name":"timer","kind":"function","type":["double"],"specialkind":"none","def":"double vex::brain::timer","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(timeUnits units)","desc":"Gets the value of the timer in the units specified.","params":[{"type":"vex::timeUnits","kind":"enum","declname":"units","desc":"The unit of time that will be returned."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"resetTimer":{"name":"resetTimer","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::resetTimer","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"()","desc":"Resets the timer to zero.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setTimer":{"name":"setTimer","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::setTimer","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(double value, timeUnits units)","desc":"Sets the timer to a value and time unit.","params":[{"type":"double","kind":"","declname":"value","desc":"The value that the timer is set to."},{"type":"vex::timeUnits","kind":"enum","declname":"units","desc":"The unit of time that will be returned."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"}},"desc":"Use the brain class to see battery information, SD card information, or write to the Screen.","id":"classvex_1_1brain","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::brain::battery":{"name":"vex::brain::battery","members":{"capacity":{"name":"capacity","kind":"function","type":["uint32_t"],"specialkind":"none","def":"uint32_t vex::brain::battery::capacity","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units=percentUnits::pct)","desc":"Gets the battery capacity.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"(Optional) The type of unit that will be returned."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"temperature":{"name":"temperature","kind":"function","type":["double"],"specialkind":"none","def":"double vex::brain::battery::temperature","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units=percentUnits::pct)","desc":"Gets the battery temperature.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"(Optional) The type of unit that will be returned."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"}},"desc":"Use the battery class to see information about the battery.","id":"classvex_1_1brain_1_1battery","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::brain::lcd":{"name":"vex::brain::lcd","members":{"setCursor":{"name":"setCursor","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::setCursor","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(int32_t row, int32_t col)","desc":"Sets the cursor to the row and column number set in the parameters.","params":[{"type":"int32_t","kind":"","declname":"row","desc":"Sets the row number for where the cursor is placed."},{"type":"int32_t","kind":"","declname":"col","desc":"Sets the column number for where the cursor is placed."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setFont":{"name":"setFont","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::setFont","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(fontType font)","desc":"Sets the font type to be displayed on the Screen that is determined by the parameter.","params":[{"type":"vex::fontType","kind":"enum","declname":"font","desc":"The type of font that is displayed."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setPenWidth":{"name":"setPenWidth","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::setPenWidth","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(uint32_t width)","desc":"Sets the pen's width.","params":[{"type":"uint32_t","kind":"","declname":"width","desc":"This represents the width of the pen when drawing. A larger width equals a wider pen stroke."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setOrigin":{"name":"setOrigin","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::setOrigin","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(int32_t x, int32_t y)","desc":"Sets the origin of the screen to the parameters defined in the function.","params":[{"type":"int32_t","kind":"","declname":"x","desc":"The x location of the origin."},{"type":"int32_t","kind":"","declname":"y","desc":"The y location of the origin."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"column":{"name":"column","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::lcd::column","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"An integer that tracks the current cursor position's column, starting at 1.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"row":{"name":"row","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::lcd::row","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"An integer that tracks the current cursor position's row, starting at 1.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"setPenColor":{"name":"setPenColor","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::setPenColor","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(const color &color)","desc":"Sets the color of the pen to a specified color.","params":[{"type":"","kind":"","operator":"const \n &","declname":"color","desc":"A color unit where colors can be defined as names."}]},{"apilevel":["pro"],"drawercat":"setting","argsstring":"(const char *color)","desc":"Sets the color of the pen to a specified color using a hex value.","params":[{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal value that represents color."}]},{"apilevel":["pro"],"drawercat":"setting","argsstring":"(int hue)","desc":"Sets the color of the pen to a specified color.","params":[{"type":"int","kind":"","declname":"hue","desc":"The integer represents the hue of the color."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setFillColor":{"name":"setFillColor","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::setFillColor","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(const color &color)","desc":"Sets the background fill color of the screen to the specified color.","params":[{"type":"","kind":"","operator":"const \n &","declname":"color","desc":"In a color unit, colors can be defined as names."}]},{"apilevel":["pro"],"drawercat":"setting","argsstring":"(const char *color)","desc":"Sets the background fill color of the screen to the specified color.","params":[{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal value that represents color."}]},{"apilevel":["pro"],"drawercat":"setting","argsstring":"(int hue)","desc":"Sets the background fill color of the screen to the specified color.","params":[{"type":"int","kind":"","declname":"hue","desc":"The integer represents the hue of the color."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"print":{"name":"print","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::print","static":false,"overloads":[{"apilevel":["block"],"drawercat":"action","argsstring":"(T value)","desc":"Prints a number, string, or Boolean.","params":[{"type":"T","kind":"","declname":"value","desc":"Information to display on the screen."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(const char *format,...)","desc":"Prints a number, string, or Boolean.","params":[{"type":"const char *","kind":"","declname":"format","desc":"This is a reference to a char format that prints the value of variables."},{"type":"...","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"printAt":{"name":"printAt","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::printAt","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int32_t x, int32_t y, const char *format,...)","desc":"Prints a number, string, or Boolean at an x, y pixel location.","params":[{"type":"int32_t","kind":"","declname":"x","desc":"The x-coordinate at which to print a message on the screen."},{"type":"int32_t","kind":"","declname":"y","desc":"The y-coordinate at which to print a message on the screen."},{"type":"const char *","kind":"","declname":"format","desc":"A reference to a char format to print the value of variables."},{"type":"...","kind":"","desc":""}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int32_t x, int32_t y, bool bOpaque, const char *format,...)","desc":"Prints a number, string, or Boolean at an x, y pixel location with the ability to be transparent.","params":[{"type":"int32_t","kind":"","declname":"x","desc":"The x pixel location where the print should start"},{"type":"int32_t","kind":"","declname":"y","desc":"The y pixel location where the print should start"},{"type":"bool","kind":"","declname":"bOpaque","desc":"If set to false, the print will be transparent."},{"type":"const char *","kind":"","declname":"format","desc":"A reference to a char format to print the value of variables."},{"type":"...","kind":"","desc":""}]}],"apilevel":["cpp","pro"],"drawercat":"action"},"clearScreen":{"name":"clearScreen","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::clearScreen","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Clears the whole Screen to a default color or otherwise specified color.","params":[{"type":"void","kind":"","desc":""}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(const color &color)","desc":"Clears the whole Screen to a default color or otherwise specified color.","params":[{"type":"","kind":"","operator":"const \n &","declname":"color","desc":"In a color unit, colors can be defined as names."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(const char *color)","desc":"Clears the whole Screen to a default color or otherwise specified color.","params":[{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal value that represents color."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int hue)","desc":"Clears the whole Screen to a default color or otherwise specified color.","params":[{"type":"int","kind":"","declname":"hue","desc":"The integer represents the hue of the color."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"clearLine":{"name":"clearLine","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::clearLine","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int number, const color &color)","desc":"Clears the specified line and sets it to a specified color.","params":[{"type":"int","kind":"","declname":"number","desc":"The integer sets the line that is to be cleared."},{"type":"","kind":"","operator":"const \n &","declname":"color","desc":"A color unit where colors can be defined as names."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int number, const char *color)","desc":"Clears the specified line and sets it to a specified color.","params":[{"type":"int","kind":"","declname":"number","desc":"The integer sets the line that is to be cleared."},{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal value that represents color."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int number, int hue)","desc":"Clears the specified line and sets it to a specified color.","params":[{"type":"int","kind":"","declname":"number","desc":"The integer sets the line that is to be cleared."},{"type":"int","kind":"","declname":"hue","desc":"An integer that represents the hue of the color."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Clears the rest of the line from where the cursor is located.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"newLine":{"name":"newLine","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::newLine","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Clears the rest of the line from where the cursor is located and then moves the cursor to the beginning of the next line.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"drawPixel":{"name":"drawPixel","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::drawPixel","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(int x, int y)","desc":"Draws a single pixel to the screen in the specified x and y location.","params":[{"type":"int","kind":"","declname":"x","desc":"The x location of where to draw the pixel."},{"type":"int","kind":"","declname":"y","desc":"The y location of where to draw the pixel."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"drawLine":{"name":"drawLine","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::drawLine","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(int x1, int y1, int x2, int y2)","desc":"Draws a line connecting the two specified points in the parameters.","params":[{"type":"int","kind":"","declname":"x1","desc":"The x location of the first point."},{"type":"int","kind":"","declname":"y1","desc":"The y location of the first point."},{"type":"int","kind":"","declname":"x2","desc":"The x location of the second point."},{"type":"int","kind":"","declname":"y2","desc":"The y location of the second point."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"drawRectangle":{"name":"drawRectangle","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::drawRectangle","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(int x, int y, int width, int height)","desc":"Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the current pen and fill color.","params":[{"type":"int","kind":"","declname":"x","desc":"The x-coordinate at which the left edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"y","desc":"The y-coordinate at which the top edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"width","desc":"The width of the rectangle."},{"type":"int","kind":"","declname":"height","desc":"The height of the rectangle."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int x, int y, int width, int height, const color &color)","desc":"Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the color specified.","params":[{"type":"int","kind":"","declname":"x","desc":"The x-coordinate at which the left edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"y","desc":"The y-coordinate at which the top edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"width","desc":"The width of the rectangle."},{"type":"int","kind":"","declname":"height","desc":"The height of the rectangle."},{"type":"","kind":"","operator":"const \n &","declname":"color","desc":"A color unit where colors can be defined as names."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int x, int y, int width, int height, const char *color)","desc":"Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the color specified.","params":[{"type":"int","kind":"","declname":"x","desc":"The x-coordinate at which the left edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"y","desc":"The y-coordinate at which the top edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"width","desc":"The width of the rectangle."},{"type":"int","kind":"","declname":"height","desc":"The height of the rectangle."},{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal value that represents color."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int x, int y, int width, int height, int hue)","desc":"Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the color specified.","params":[{"type":"int","kind":"","declname":"x","desc":"The x-coordinate at which the left edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"y","desc":"The y-coordinate at which the top edge of the rectangle will be drawn on the screen."},{"type":"int","kind":"","declname":"width","desc":"The width of the rectangle."},{"type":"int","kind":"","declname":"height","desc":"The height of the rectangle."},{"type":"int","kind":"","declname":"hue","desc":"The color of the rectangle."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"drawCircle":{"name":"drawCircle","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::drawCircle","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(int x, int y, int radius)","desc":"Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the current pen and fill color.","params":[{"type":"int","kind":"","declname":"x","desc":"The central x location of the circle."},{"type":"int","kind":"","declname":"y","desc":"The central y location of the circle."},{"type":"int","kind":"","declname":"radius","desc":"Sets the radius of the circle to be drawn on the Screen."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int x, int y, int radius, const color &color)","desc":"Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the color specified.","params":[{"type":"int","kind":"","declname":"x","desc":"The central x location of the circle."},{"type":"int","kind":"","declname":"y","desc":"The central y location of the circle."},{"type":"int","kind":"","declname":"radius","desc":"Sets the radius of the circle to be drawn on the Screen."},{"type":"","kind":"","operator":"const \n &","declname":"color","desc":"A color unit where colors can be defined as names."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int x, int y, int radius, const char *color)","desc":"Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the color specified.","params":[{"type":"int","kind":"","declname":"x","desc":"The central x location of the circle."},{"type":"int","kind":"","declname":"y","desc":"The central y location of the circle."},{"type":"int","kind":"","declname":"radius","desc":"Sets the radius of the circle to be drawn on the Screen."},{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal value that represents color."}]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(int x, int y, int radius, int hue)","desc":"Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the color specified.","params":[{"type":"int","kind":"","declname":"x","desc":"The central x location of the circle."},{"type":"int","kind":"","declname":"y","desc":"The central y location of the circle."},{"type":"int","kind":"","declname":"radius","desc":"Sets the radius of the circle to be drawn on the Screen."},{"type":"int","kind":"","declname":"hue","desc":"An integer that represents the hue of the color."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"pressed":{"name":"pressed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::pressed","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Sets the function to be called when a press on the Screen is pressed.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"released":{"name":"released","kind":"function","type":["void"],"specialkind":"none","def":"void vex::brain::lcd::released","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Sets the function to be called when a press on the screen is released.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"xPosition":{"name":"xPosition","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::lcd::xPosition","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the last x location pressed on the screen.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"yPosition":{"name":"yPosition","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::lcd::yPosition","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the last y location pressed on the screen.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"pressing":{"name":"pressing","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::brain::lcd::pressing","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the pressed status of the Screen.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"render":{"name":"render","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::brain::lcd::render","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"()","desc":"Switches to double buffering or renders back buffer to screen.","params":[]},{"apilevel":["pro"],"drawercat":"action","argsstring":"(bool bVsyncWait, bool bRunScheduler=true)","desc":"Switches to double buffering or renders back buffer to screen.","params":[{"type":"bool","kind":"","declname":"bVsyncWait","desc":""},{"type":"bool","kind":"","declname":"bRunScheduler","desc":""}]}],"apilevel":["pro"],"drawercat":"action"}},"desc":"Use this class to write or draw to the brain's LCD screen.","id":"classvex_1_1brain_1_1lcd","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::brain::sdcard":{"name":"vex::brain::sdcard","members":{"isInserted":{"name":"isInserted","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::brain::sdcard::isInserted","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the state of the SD card.","params":[]}],"apilevel":["pro"],"drawercat":"sensing"},"loadfile":{"name":"loadfile","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::sdcard::loadfile","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"(const char *name, uint8_t *buffer, int32_t len)","desc":"Loads a file from the SD card.","params":[{"type":"const char *","kind":"","declname":"name","desc":"The name of the file."},{"type":"uint8_t *","kind":"","declname":"buffer","desc":"Pointer to a buffer for file data."},{"type":"int32_t","kind":"","declname":"len","desc":"The length of the buffer in bytes. Usually set to the max length of the buffer."}]}],"apilevel":["pro"],"drawercat":"action"},"savefile":{"name":"savefile","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::sdcard::savefile","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"(const char *name, uint8_t *buffer, int32_t len)","desc":"Saves a file to the SD card.","params":[{"type":"const char *","kind":"","declname":"name","desc":"The name of the file."},{"type":"uint8_t *","kind":"","declname":"buffer","desc":"Pointer to a buffer with file data."},{"type":"int32_t","kind":"","declname":"len","desc":"The length of the buffer in bytes. Usually set to the max length of the buffer."}]}],"apilevel":["pro"],"drawercat":"action"},"appendfile":{"name":"appendfile","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::brain::sdcard::appendfile","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"(const char *name, uint8_t *buffer, int32_t len)","desc":"Appends data to an existing file.","params":[{"type":"const char *","kind":"","declname":"name","desc":"The name of the file."},{"type":"uint8_t *","kind":"","declname":"buffer","desc":"Pointer to a buffer with file data."},{"type":"int32_t","kind":"","declname":"len","desc":"The length of the buffer in bytes. Usually set to the max length of the buffer."}]}],"apilevel":["pro"],"drawercat":"action"}},"desc":"Use the SD Card class to load or save files on your SD card.","id":"classvex_1_1brain_1_1sdcard","kind":"class","apilevel":["pro"],"drawercat":""},"vex::bumper":{"name":"vex::bumper","members":{"bumper":{"name":"bumper","kind":"function","type":[""],"specialkind":"constructor","def":"vex::bumper::bumper","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new bumper object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"pressing":{"name":"pressing","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::bumper::pressing","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Get the pressed status of the bumper device.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"pressed":{"name":"pressed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::bumper::pressed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the bumper switch is pressed.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"},"released":{"name":"released","kind":"function","type":["void"],"specialkind":"none","def":"void vex::bumper::released","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the bumper switch is released.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with the bumper device.","id":"classvex_1_1bumper","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::color":{"name":"vex::color","members":{"black":{"name":"black","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::black","static":true,"desc":"Represents the color black.","apilevel":["cpp","pro"],"drawercat":""},"white":{"name":"white","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::white","static":true,"desc":"Represents the color white.","apilevel":["cpp","pro"],"drawercat":""},"red":{"name":"red","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::red","static":true,"desc":"Represents the color red.","apilevel":["cpp","pro"],"drawercat":""},"green":{"name":"green","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::green","static":true,"desc":"Represents the color green.","apilevel":["cpp","pro"],"drawercat":""},"blue":{"name":"blue","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::blue","static":true,"desc":"Represents the color blue.","apilevel":["cpp","pro"],"drawercat":""},"yellow":{"name":"yellow","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::yellow","static":true,"desc":"Represents the color yellow.","apilevel":["cpp","pro"],"drawercat":""},"orange":{"name":"orange","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::orange","static":true,"desc":"Represents the color orange.","apilevel":["cpp","pro"],"drawercat":""},"purple":{"name":"purple","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::purple","static":true,"desc":"Represents the color purple.","apilevel":["cpp","pro"],"drawercat":""},"cyan":{"name":"cyan","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::cyan","static":true,"desc":"Represents the color cyan.","apilevel":["cpp","pro"],"drawercat":""},"transparent":{"name":"transparent","kind":"variable","type":[""],"specialkind":"none","def":"const color vex::color::transparent","static":true,"desc":"Represents the color transparent.","apilevel":["cpp","pro"],"drawercat":""},"color":{"name":"color","kind":"function","type":[""],"specialkind":"constructor","def":"vex::color::color","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"none","argsstring":"(int value)","desc":"Creates a color.","params":[{"type":"int","kind":"","declname":"value","desc":"The value of the color."}]},{"apilevel":["cpp","pro"],"drawercat":"none","argsstring":"(uint8_t r, uint8_t g, uint8_t b)","desc":"Creates a color using red, green, and blue values.","params":[{"type":"uint8_t","kind":"","declname":"r","desc":"the color of red on a scale of 0 to 255."},{"type":"uint8_t","kind":"","declname":"g","desc":"the color of green on a scale of 0 to 255."},{"type":"uint8_t","kind":"","declname":"b","desc":"the color of blue on a scale of 0 to 255."}]}],"apilevel":["cpp","pro"],"drawercat":"none"},"isTransparent":{"name":"isTransparent","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::color::isTransparent","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"none","argsstring":"() const","desc":"Gets the state of the color's transparency.","params":[]}],"apilevel":["cpp","pro"],"drawercat":"none"},"hsv":{"name":"hsv","kind":"function","type":[""],"specialkind":"none","def":"color& vex::color::hsv","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(uint32_t hue, double sat, double value)","desc":"Creates a color using hue, saturation, and brightness values.","params":[{"type":"uint32_t","kind":"","declname":"hue","desc":"An integer from 0 to 360 that represents the hue of the color."},{"type":"double","kind":"","declname":"sat","desc":"A double from 0.0 to 1.0 that represents the saturation of the color."},{"type":"double","kind":"","declname":"value","desc":"A double from 0.0 to 1.0 that represents the brightness of the color."}]}],"apilevel":["pro"],"drawercat":"none"},"web":{"name":"web","kind":"function","type":[""],"specialkind":"none","def":"color& vex::color::web","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(const char *color)","desc":"Creates a color using a hexadecimal value.","params":[{"type":"const char *","kind":"","declname":"color","desc":"A hexadecimal or web color value that defines a specific color."}]}],"apilevel":["pro"],"drawercat":"none"}},"desc":"Use the color class to create Color objects.","id":"classvex_1_1color","kind":"class","apilevel":["cpp","pro"],"drawercat":""},"vex::competition":{"name":"vex::competition","members":{"bStopTasksBetweenModes":{"name":"bStopTasksBetweenModes","kind":"variable","type":["bool"],"specialkind":"none","def":"bool vex::competition::bStopTasksBetweenModes","static":true,"desc":"Sets whether or not your program will stop tasks between modes.","apilevel":["block","cpp","pro"],"drawercat":"none"},"autonomous":{"name":"autonomous","kind":"function","type":["void"],"specialkind":"none","def":"void vex::competition::autonomous","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Calls back a function when the autonomous period starts.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"drivercontrol":{"name":"drivercontrol","kind":"function","type":["void"],"specialkind":"none","def":"void vex::competition::drivercontrol","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Calls back a function when the driver control period starts.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"isEnabled":{"name":"isEnabled","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::competition::isEnabled","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the status of your robot when under competition control.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"isDriverControl":{"name":"isDriverControl","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::competition::isDriverControl","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the status of the Driver Control period.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"isAutonomous":{"name":"isAutonomous","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::competition::isAutonomous","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the status of the Autonomous period.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"isCompetitionSwitch":{"name":"isCompetitionSwitch","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::competition::isCompetitionSwitch","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the status of the Competition Control Switch being plugged into the robot.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"isFieldControl":{"name":"isFieldControl","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::competition::isFieldControl","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the status of the Field Control System being plugged into the robot.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"}},"desc":"Use this class to set up your program for competitions.","id":"classvex_1_1competition","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::controller":{"name":"vex::controller","members":{"ButtonL1":{"name":"ButtonL1","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonL1","static":false,"desc":"A button that represents the L1 button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonL2":{"name":"ButtonL2","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonL2","static":false,"desc":"A button that represents the L2 button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonR1":{"name":"ButtonR1","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonR1","static":false,"desc":"A button that represents the R1 button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonR2":{"name":"ButtonR2","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonR2","static":false,"desc":"A button that represents the R2 button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonUp":{"name":"ButtonUp","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonUp","static":false,"desc":"A button that represents the up button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonDown":{"name":"ButtonDown","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonDown","static":false,"desc":"A button that represents the down button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonLeft":{"name":"ButtonLeft","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonLeft","static":false,"desc":"A button that represents the left button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonRight":{"name":"ButtonRight","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonRight","static":false,"desc":"A button that represents the right button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonX":{"name":"ButtonX","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonX","static":false,"desc":"A button that represents the x button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonB":{"name":"ButtonB","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonB","static":false,"desc":"A button that represents the B button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonY":{"name":"ButtonY","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonY","static":false,"desc":"A button that represents the Y button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"ButtonA":{"name":"ButtonA","kind":"variable","type":["vex::controller::button"],"specialkind":"none","def":"button& vex::controller::ButtonA","static":false,"desc":"A button that represents the A button on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Axis1":{"name":"Axis1","kind":"variable","type":["vex::controller::axis"],"specialkind":"none","def":"axis& vex::controller::Axis1","static":false,"desc":"An axis of a joystick that represents axis 1 on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Axis2":{"name":"Axis2","kind":"variable","type":["vex::controller::axis"],"specialkind":"none","def":"axis& vex::controller::Axis2","static":false,"desc":"An axis of a joystick that represents axis 2 on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Axis3":{"name":"Axis3","kind":"variable","type":["vex::controller::axis"],"specialkind":"none","def":"axis& vex::controller::Axis3","static":false,"desc":"An axis of a joystick that represents axis 3 on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Axis4":{"name":"Axis4","kind":"variable","type":["vex::controller::axis"],"specialkind":"none","def":"axis& vex::controller::Axis4","static":false,"desc":"An axis of a joystick that represents axis 4 on the controller.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"Screen":{"name":"Screen","kind":"variable","type":["vex::controller::lcd"],"specialkind":"none","def":"lcd vex::controller::Screen","static":false,"desc":"Controller's instance of LCD.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"controller":{"name":"controller","kind":"function","type":[""],"specialkind":"constructor","def":"vex::controller::controller","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"()","desc":"Creates a new controller object.","params":[]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(controllerType id)","desc":"Creates a new controller object.","params":[{"type":"vex::controllerType","kind":"enum","declname":"id","desc":"The type of controller that is being created. This can be set to primary or partner."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"rumble":{"name":"rumble","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::rumble","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(const char *str)","desc":"Rumbles the controller by a pattern defined by the parameter. Dots equal short, dashes equal long and space equals pause.","params":[{"type":"const char *","kind":"","declname":"str","desc":"A string that consists of dots and dashes that represent the rumble pattern."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use the controller class to get values from the remote controller as well as write to the controller's screen.","id":"classvex_1_1controller","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::controller::axis":{"name":"vex::controller::axis","members":{"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::axis::changed","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Sets the function to be called when the joystick axis value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::controller::axis::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(void)","desc":"Gets the value of the joystick axis.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["cpp","pro"],"drawercat":"sensing"},"position":{"name":"position","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::controller::axis::position","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the position of the joystick axis.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The type of unit that will be returned."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"}},"desc":"Use the axis class to get values from one of the controller's joysticks.","id":"classvex_1_1controller_1_1axis","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::controller::button":{"name":"vex::controller::button","members":{"pressed":{"name":"pressed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::button::pressed","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Sets the function to be called when the button is pressed.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"released":{"name":"released","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::button::released","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void(*callback)(void))","desc":"Sets the function to be called when the button is released.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"pressing":{"name":"pressing","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::controller::button::pressing","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(void)","desc":"Gets the status of a button.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"}},"desc":"Use the button class to get values from the controller's buttons.","id":"classvex_1_1controller_1_1button","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::controller::lcd":{"name":"vex::controller::lcd","members":{"setCursor":{"name":"setCursor","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::lcd::setCursor","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(int32_t row, int32_t col)","desc":"Sets the cursor to the row and column number set in the parameters.","params":[{"type":"int32_t","kind":"","declname":"row","desc":"Sets the row number for where the cursor is placed."},{"type":"int32_t","kind":"","declname":"col","desc":"Sets the column number for where the cursor is placed."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"print":{"name":"print","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::lcd::print","static":false,"overloads":[{"apilevel":["block"],"drawercat":"action","argsstring":"(T value)","desc":"Prints a number, string, or Boolean.","params":[{"type":"T","kind":"","declname":"value","desc":"Information to display on the screen."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(const char *format,...)","desc":"Prints a number, string, or Boolean.","params":[{"type":"const char *","kind":"","declname":"format","desc":"This is a reference to a char format that prints the value of variables."},{"type":"...","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"clearScreen":{"name":"clearScreen","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::lcd::clearScreen","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Clears the controller's LCD screen.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"clearLine":{"name":"clearLine","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::lcd::clearLine","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int number)","desc":"Clears the line specified by the parameter.","params":[{"type":"int","kind":"","declname":"number","desc":"The line number to be cleared."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Clears the current line.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"newLine":{"name":"newLine","kind":"function","type":["void"],"specialkind":"none","def":"void vex::controller::lcd::newLine","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Moves the cursor to the next line.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use this class to write to the controller's LCD screen.","id":"classvex_1_1controller_1_1lcd","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::digital_in":{"name":"vex::digital_in","members":{"digital_in":{"name":"digital_in","kind":"function","type":[""],"specialkind":"constructor","def":"vex::digital_in::digital_in","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new digital-in object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::digital_in::value","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the value of the digital-in device.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"high":{"name":"high","kind":"function","type":["void"],"specialkind":"none","def":"void vex::digital_in::high","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the digital input goes high.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"},"low":{"name":"low","kind":"function","type":["void"],"specialkind":"none","def":"void vex::digital_in::low","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the digital input goes low.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with a digital-in device.","id":"classvex_1_1digital__in","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::digital_out":{"name":"vex::digital_out","members":{"digital_out":{"name":"digital_out","kind":"function","type":[""],"specialkind":"constructor","def":"vex::digital_out::digital_out","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new digital-out object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::digital_out::value","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the value of the digital-out device.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"set":{"name":"set","kind":"function","type":["void"],"specialkind":"none","def":"void vex::digital_out::set","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(bool value)","desc":"Sets the digital-out device to a Boolean value.","params":[{"type":"bool","kind":"","declname":"value","desc":"A true or false Boolean value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use this class when programming with a digital-out device.","id":"classvex_1_1digital__out","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::encoder":{"name":"vex::encoder","members":{"encoder":{"name":"encoder","kind":"function","type":[""],"specialkind":"constructor","def":"vex::encoder::encoder","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new encoder object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"resetRotation":{"name":"resetRotation","kind":"function","type":["void"],"specialkind":"none","def":"void vex::encoder::resetRotation","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(void)","desc":"Resets the rotation of the encoder to zero.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setRotation":{"name":"setRotation","kind":"function","type":["void"],"specialkind":"none","def":"void vex::encoder::setRotation","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(double val, rotationUnits units)","desc":"Sets the rotation of the encoder to a specific value.","params":[{"type":"double","kind":"","declname":"val","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"rotation":{"name":"rotation","kind":"function","type":["double"],"specialkind":"none","def":"double vex::encoder::rotation","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(rotationUnits units)","desc":"Gets the rotation value of the encoder.","params":[{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the encoder device."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"velocity":{"name":"velocity","kind":"function","type":["double"],"specialkind":"none","def":"double vex::encoder::velocity","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(velocityUnits units)","desc":"Gets the velocity of the encoder.","params":[{"type":"vex::velocityUnits","kind":"enum","declname":"units","desc":"The measurement unit for the encoder device."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::encoder::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the encoder value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with an encoder.","id":"classvex_1_1encoder","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::gyro":{"name":"vex::gyro","members":{"gyro":{"name":"gyro","kind":"function","type":[""],"specialkind":"constructor","def":"vex::gyro::gyro","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new gyro object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::gyro::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(analogUnits units)","desc":"Gets the value of the gyro sensor.","params":[{"type":"vex::analogUnits","kind":"enum","declname":"units","desc":"The measurement unit for the gyro device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(rotationUnits units)","desc":"Gets the value of the gyro sensor.","params":[{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the gyro device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the value of the gyro sensor.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the gyro device."}]}],"apilevel":["cpp","pro","block"],"drawercat":"sensing"},"startCalibration":{"name":"startCalibration","kind":"function","type":["void"],"specialkind":"none","def":"void vex::gyro::startCalibration","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"(int32_t value=0)","desc":"Starts recalibration of the gyro.","params":[{"type":"int32_t","kind":"","declname":"value","desc":"(Optional) Sets the amount of calibration time."}]}],"apilevel":["pro"],"drawercat":"action"},"isCalibrating":{"name":"isCalibrating","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::gyro::isCalibrating","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"()","desc":"Returns true while the gyro sensor is performing a requested recalibration, changing to false once recalibration has completed.","params":[]}],"apilevel":["pro"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::gyro::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the gyro sensor value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with a gyro sensor.","id":"classvex_1_1gyro","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::light":{"name":"vex::light","members":{"light":{"name":"light","kind":"function","type":[""],"specialkind":"constructor","def":"vex::light::light","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new light object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::light::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(analogUnits units)","desc":"Gets the value of the light sensor.","params":[{"type":"vex::analogUnits","kind":"enum","declname":"units","desc":"The measurement unit for the light device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the value of the light sensor.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the light device."}]}],"apilevel":["cpp","pro","block"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::light::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the light sensor value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with a light sensor.","id":"classvex_1_1light","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::limit":{"name":"vex::limit","members":{"limit":{"name":"limit","kind":"function","type":[""],"specialkind":"constructor","def":"vex::limit::limit","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new limit object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"pressing":{"name":"pressing","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::limit::pressing","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the state of the limit device.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"pressed":{"name":"pressed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::limit::pressed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the limit switch is pressed.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"},"released":{"name":"released","kind":"function","type":["void"],"specialkind":"none","def":"void vex::limit::released","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the limit switch is released.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with the limit switch.","id":"classvex_1_1limit","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::line":{"name":"vex::line","members":{"line":{"name":"line","kind":"function","type":[""],"specialkind":"constructor","def":"vex::line::line","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new line object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::line::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(analogUnits units)","desc":"Gets the value of the line follower.","params":[{"type":"vex::analogUnits","kind":"enum","declname":"units","desc":"The measurement unit for the line device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the value of the line follower.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the line device."}]}],"apilevel":["cpp","pro","block"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::line::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the line sensor value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with a line follower.","id":"classvex_1_1line","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::motor":{"name":"vex::motor","members":{"motor":{"name":"motor","kind":"function","type":[""],"specialkind":"constructor","def":"vex::motor::motor","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t index)","desc":"Creates a new motor object on the port specified.","params":[{"type":"int32_t","kind":"","declname":"index","desc":"The port index for this motor. The index is zero-based."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t index, bool reverse)","desc":"Creates a new motor object on the port specified and sets the reversed flag.","params":[{"type":"int32_t","kind":"","declname":"index","desc":"The port index for this motor. The index is zero-based."},{"type":"bool","kind":"","declname":"reverse","desc":"Sets the reverse flag for the new motor object."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t index, gearSetting gears)","desc":"Creates a new motor object on the port specified and sets the gear setting.","params":[{"type":"int32_t","kind":"","declname":"index","desc":"The port index for this motor. The index is zero-based."},{"type":"vex::gearSetting","kind":"enum","declname":"gears","desc":"Sets the gear's setting for the new motor object."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t index, gearSetting gears, bool reverse)","desc":"Creates a new motor object on the port specified Sets the reversed flag and the gear setting for the new motor object.","params":[{"type":"int32_t","kind":"","declname":"index","desc":"The port index for this motor. The index is zero-based."},{"type":"vex::gearSetting","kind":"enum","declname":"gears","desc":"Sets the gear's setting for the new motor object."},{"type":"bool","kind":"","declname":"reverse","desc":"Sets the reverse flag for the new motor object."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"setReversed":{"name":"setReversed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::setReversed","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(bool value)","desc":"Sets the motor mode to \"reverse\", which will make motor commands spin the motor in the opposite direction.","params":[{"type":"bool","kind":"","declname":"value","desc":"If set to true, motor commands spin the motor in the opposite direction."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"setVelocity":{"name":"setVelocity","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::setVelocity","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(double velocity, velocityUnits units)","desc":"Sets the velocity of the motor based on the parameters set in the command. This command will not run the motor. Any subsequent call that does not contain a specified motor velocity will use this value.","params":[{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units","desc":"The measurement unit for the velocity value."}]},{"apilevel":["block"],"drawercat":"setting","argsstring":"(double velocity, percentUnits units)","desc":"Sets the velocity of the motor based on the parameters set in the command. This command will not run the motor. Any subsequent call that does not contain a specified motor velocity will use this value.","params":[{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the velocity value."}]}],"apilevel":["cpp","pro","block"],"drawercat":"setting"},"setStopping":{"name":"setStopping","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::setStopping","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(brakeType mode)","desc":"Sets the stopping mode of the motor by passing a brake mode as a parameter.","params":[{"type":"vex::brakeType","kind":"enum","declname":"mode","desc":"The stopping mode can be set to coast, brake, or hold."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"resetRotation":{"name":"resetRotation","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::resetRotation","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(void)","desc":"Resets the motor's encoder to the value of zero.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"setRotation":{"name":"setRotation","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::setRotation","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(double value, rotationUnits units)","desc":"Sets the value of the 1's encoder to the value specified in the parameter.","params":[{"type":"double","kind":"","declname":"value","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setTimeout":{"name":"setTimeout","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::setTimeout","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(int32_t time, timeUnits units)","desc":"Sets the timeout for the motor. If the motor does not reach its' commanded position prior to the completion of the timeout, the motor will stop.","params":[{"type":"int32_t","kind":"","declname":"time","desc":"Sets the amount of time."},{"type":"vex::timeUnits","kind":"enum","declname":"units","desc":"The measurement unit for the time value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"spin":{"name":"spin","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::spin","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(directionType dir)","desc":"Turns the motor on, and spins it in the specified direction.","params":[{"type":"vex::directionType","kind":"enum","declname":"dir","desc":"The direction to spin the motor."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(directionType dir, double velocity, velocityUnits units)","desc":"Turns on the motor and spins it in a specified direction and a specified velocity.","params":[{"type":"vex::directionType","kind":"enum","declname":"dir","desc":"The direction to spin the motor."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units","desc":"The measurement unit for the velocity value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"rotateTo":{"name":"rotateTo","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::motor::rotateTo","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units, double velocity, velocityUnits units_v, bool waitForCompletion=true)","desc":"Turns on the motor and spins it to an absolute target rotation value at a specified velocity.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units_v","desc":"The measurement unit for the velocity value."},{"type":"bool","kind":"","declname":"waitForCompletion","desc":"(Optional) If true, your program will wait until the motor reaches the target rotational value. If false, the program will continue after calling this function. By default, this parameter is true."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units, bool waitForCompletion=true)","desc":"Turns on the motor and spins it to an absolute target rotation value.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."},{"type":"bool","kind":"","declname":"waitForCompletion","desc":"(Optional) If true, your program will wait until the motor reaches the target rotational value. If false, the program will continue after calling this function. By default, this parameter is true."}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"rotateFor":{"name":"rotateFor","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::motor::rotateFor","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units, double velocity, velocityUnits units_v, bool waitForCompletion=true)","desc":"Turns on the motor and spins it to a relative target rotation value at a specified velocity.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units_v","desc":"The measurement unit for the velocity value."},{"type":"bool","kind":"","declname":"waitForCompletion","desc":"(Optional) If true, your program will wait until the motor reaches the target rotational value. If false, the program will continue after calling this function. By default, this parameter is true."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units, bool waitForCompletion=true)","desc":"Turns on the motor and spins it to a relative target rotation value.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."},{"type":"bool","kind":"","declname":"waitForCompletion","desc":"(Optional) If true, your program will wait until the motor reaches the target rotational value. If false, the program will continue after calling this function. By default, this parameter is true."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double time, timeUnits units, double velocity, velocityUnits units_v)","desc":"Turns on the motor and spins it to a relative target time value at a specified velocity.","params":[{"type":"double","kind":"","declname":"time","desc":"Sets the amount of time."},{"type":"vex::timeUnits","kind":"enum","declname":"units","desc":"The measurement unit for the time value."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units_v","desc":"The measurement unit for the velocity value."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double time, timeUnits units)","desc":"Turns on the motor and spins it to a relative target time value.","params":[{"type":"double","kind":"","declname":"time","desc":"Sets the amount of time."},{"type":"vex::timeUnits","kind":"enum","declname":"units","desc":"The measurement unit for the time value."}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"startRotateTo":{"name":"startRotateTo","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::startRotateTo","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units, double velocity, velocityUnits units_v)","desc":"Starts spinning a motor to an absolute target rotation but does not wait for the motor to reach that target.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units_v","desc":"The measurement unit for the velocity value."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units)","desc":"Starts spinning a motor to an absolute target rotation but does not wait for the motor to reach that target.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"startRotateFor":{"name":"startRotateFor","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::startRotateFor","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units, double velocity, velocityUnits units_v)","desc":"Starts spinning a motor to a relative target rotation but does not wait for the motor to reach that target.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units_v","desc":"The measurement unit for the velocity value."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(double rotation, rotationUnits units)","desc":"Starts spinning a motor to a relative target but does not wait for the motor to reach that target.","params":[{"type":"double","kind":"","declname":"rotation","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"isSpinning":{"name":"isSpinning","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::motor::isSpinning","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Checks to see if the motor is spinning.","params":[]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"stop":{"name":"stop","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::stop","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Stops the motor using the default brake mode.","params":[{"type":"void","kind":"","desc":""}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(brakeType mode)","desc":"Stops the motor using a specified brake mode.","params":[{"type":"vex::brakeType","kind":"enum","declname":"mode","desc":"The brake mode can be set to coast, brake, or hold."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"setMaxTorque":{"name":"setMaxTorque","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor::setMaxTorque","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(double value, percentUnits units)","desc":"Sets the max torque of the motor.","params":[{"type":"double","kind":"","declname":"value","desc":"Sets the amount of torque."},{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the torque value."}]},{"apilevel":["pro"],"drawercat":"setting","argsstring":"(double value, torqueUnits units)","desc":"Sets the max torque of the motor.","params":[{"type":"double","kind":"","declname":"value","desc":"Sets the amount of torque."},{"type":"vex::torqueUnits","kind":"enum","declname":"units","desc":"The measurement unit for the torque value."}]},{"apilevel":["pro"],"drawercat":"setting","argsstring":"(double value, currentUnits units)","desc":"Sets the max torque of the motor.","params":[{"type":"double","kind":"","declname":"value","desc":"Sets the amount of torque."},{"type":"vex::currentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the torque value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"direction":{"name":"direction","kind":"function","type":[{"type":"vex::directionType","kind":"enum"}],"specialkind":"none","def":"directionType vex::motor::direction","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(void)","desc":"Gets which direction the motor is spinning.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"rotation":{"name":"rotation","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::rotation","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(rotationUnits units)","desc":"Gets the current rotation of the motor's encoder.","params":[{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"velocity":{"name":"velocity","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::velocity","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(velocityUnits units)","desc":"Gets the current velocity of the motor.","params":[{"type":"vex::velocityUnits","kind":"enum","declname":"units","desc":"The measurement unit for the velocity."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"current":{"name":"current","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::current","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(currentUnits units)","desc":"Gets the electrical current of the motor.","params":[{"type":"vex::currentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the current."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"power":{"name":"power","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::power","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(powerUnits units)","desc":"Gets the power of the motor.","params":[{"type":"vex::powerUnits","kind":"enum","declname":"units","desc":"The measurement unit for the power."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"torque":{"name":"torque","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::torque","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(torqueUnits units)","desc":"Gets the torque of the motor.","params":[{"type":"vex::torqueUnits","kind":"enum","declname":"units","desc":"The measurement unit for the torque."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"efficiency":{"name":"efficiency","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::efficiency","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the efficiency of the motor.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the efficiency."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"temperature":{"name":"temperature","kind":"function","type":["double"],"specialkind":"none","def":"double vex::motor::temperature","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the temperature of the motor.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the temperature."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"}},"desc":"Use the motor class to control motor devices.","id":"classvex_1_1motor","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::motor29":{"name":"vex::motor29","members":{"motor29":{"name":"motor29","kind":"function","type":[""],"specialkind":"constructor","def":"vex::motor29::motor29","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new \n object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port, bool reverse)","desc":"Creates a new \n object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."},{"type":"bool","kind":"","declname":"reverse","desc":"Sets the reverse flag for the new \n object."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"setVelocity":{"name":"setVelocity","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor29::setVelocity","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(double velocity, percentUnits units)","desc":"Sets the velocity of the motor based on the parameters set in the command. This command will not run the motor. Any subsequent call that does not contain a specified motor velocity will use this value.","params":[{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit of the velocity value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setReversed":{"name":"setReversed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor29::setReversed","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(bool value)","desc":"Sets the motor mode to \"reverse\", which will make motor commands spin the motor in the opposite direction.","params":[{"type":"bool","kind":"","declname":"value","desc":"If set to true, the motor will spin in the reversed direction."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"spin":{"name":"spin","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor29::spin","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(directionType dir)","desc":"Turns the motor on, and spins it in the specified direction.","params":[{"type":"vex::directionType","kind":"enum","declname":"dir","desc":"The direction to spin the motor."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(directionType dir, double velocity, velocityUnits units)","desc":"Turns on the motor and spins it in a specified direction and a specified velocity.","params":[{"type":"vex::directionType","kind":"enum","declname":"dir","desc":"The direction to spin the motor."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units","desc":"The measurement unit of the velocity value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"stop":{"name":"stop","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor29::stop","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Stops the motor using the default brake mode.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use this class when programming a motor connected to a motor controller 29.","id":"classvex_1_1motor29","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::motor_victor":{"name":"vex::motor_victor","members":{"motor_victor":{"name":"motor_victor","kind":"function","type":[""],"specialkind":"constructor","def":"vex::motor_victor::motor_victor","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new motor victor object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port, bool reverse)","desc":"Creates a new motor victor object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."},{"type":"bool","kind":"","declname":"reverse","desc":"Sets the reverse flag for the new \n object."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"setVelocity":{"name":"setVelocity","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor_victor::setVelocity","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"setting","argsstring":"(double velocity, percentUnits units)","desc":"Sets the velocity of the motor based on the parameters set in the command. This command will not run the motor. Any subsequent call that does not contain a specified motor velocity will use this value.","params":[{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit of the velocity value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"setting"},"setReversed":{"name":"setReversed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor_victor::setReversed","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(bool value)","desc":"Sets the motor mode to \"reverse\", which will make motor commands spin the motor in the opposite direction.","params":[{"type":"bool","kind":"","declname":"value","desc":"If set to true, the motor will spin in the reversed direction."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"spin":{"name":"spin","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor_victor::spin","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(directionType dir)","desc":"Turns the motor on, and spins it in the specified direction.","params":[{"type":"vex::directionType","kind":"enum","declname":"dir","desc":"The direction to spin the motor."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(directionType dir, double velocity, velocityUnits units)","desc":"Turns on the motor and spins it in a specified direction and a specified velocity.","params":[{"type":"vex::directionType","kind":"enum","declname":"dir","desc":"The direction to spin the motor."},{"type":"double","kind":"","declname":"velocity","desc":"Sets the amount of velocity."},{"type":"vex::velocityUnits","kind":"enum","declname":"units","desc":"The measurement unit of the velocity value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"},"stop":{"name":"stop","kind":"function","type":["void"],"specialkind":"none","def":"void vex::motor_victor::stop","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(void)","desc":"Stops the motor using the default brake mode.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use this class when programming with a motor connected to a victor motor controller.","id":"classvex_1_1motor__victor","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::mutex":{"name":"vex::mutex","members":{"lock":{"name":"lock","kind":"function","type":["void"],"specialkind":"none","def":"void vex::mutex::lock","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"","argsstring":"()","desc":"Locks the mutex and blocks if the mutex is not available.","params":[]}],"apilevel":["pro"],"drawercat":""},"try_lock":{"name":"try_lock","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::mutex::try_lock","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"","argsstring":"()","desc":"Try to lock the mutex and returns if the mutex is not available.","params":[]}],"apilevel":["pro"],"drawercat":""},"unlock":{"name":"unlock","kind":"function","type":["void"],"specialkind":"none","def":"void vex::mutex::unlock","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"","argsstring":"()","desc":"Unlocks the mutex.","params":[]}],"apilevel":["pro"],"drawercat":""}},"desc":"Use this class to create and control mutexes.","id":"classvex_1_1mutex","kind":"class","apilevel":["pro"],"drawercat":""},"vex::pot":{"name":"vex::pot","members":{"pot":{"name":"pot","kind":"function","type":[""],"specialkind":"constructor","def":"vex::pot::pot","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new pot object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"value":{"name":"value","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::pot::value","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(analogUnits units)","desc":"Gets the value of the potentiometer in the units defined in the parameter.","params":[{"type":"vex::analogUnits","kind":"enum","declname":"units","desc":"The measurement unit for the potentiometer device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(percentUnits units)","desc":"Gets the value of the potentiometer in the units defined in the parameter.","params":[{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the potentiometer device."}]},{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(rotationUnits units)","desc":"Gets the value of the potentiometer in the units defined in the parameter.","params":[{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the potentiometer device."}]}],"apilevel":["cpp","pro","block"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::pot::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the potentiometer value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with a potentiometer.","id":"classvex_1_1pot","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::pwm_out":{"name":"vex::pwm_out","members":{"pwm_out":{"name":"pwm_out","kind":"function","type":[""],"specialkind":"constructor","def":"vex::pwm_out::pwm_out","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new pwm-out object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"state":{"name":"state","kind":"function","type":["void"],"specialkind":"none","def":"void vex::pwm_out::state","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(int32_t value, percentUnits units)","desc":"Sets the state of the pwm device.","params":[{"type":"int32_t","kind":"","declname":"value","desc":"Sets the length of the pulse width."},{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the state value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use this class when programming with a pwm-out device.","id":"classvex_1_1pwm__out","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::semaphore":{"name":"vex::semaphore","members":{"lock":{"name":"lock","kind":"function","type":["void"],"specialkind":"none","def":"void vex::semaphore::lock","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Attempts to lock the semaphore. If the semaphore is previously locked, it will block until the semaphore is unlocked.","params":[]},{"apilevel":["pro"],"drawercat":"none","argsstring":"(uint32_t time)","desc":"Attempts to lock the semaphore. If the semaphore is previously locked, it will block until the timeout has expired or the semaphore is unlocked.","params":[{"type":"uint32_t","kind":"","declname":"time","desc":"The amount of time to wait for the semaphore to be unlocked in milliseconds."}]}],"apilevel":["pro"],"drawercat":"none"},"unlock":{"name":"unlock","kind":"function","type":["void"],"specialkind":"none","def":"void vex::semaphore::unlock","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Unlocks a locked semaphore.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"owner":{"name":"owner","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::semaphore::owner","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Checks to see if the semaphore is locked by the current task.","params":[]}],"apilevel":["pro"],"drawercat":"none"}},"desc":"Use this class to synchronize access to resources.","id":"classvex_1_1semaphore","kind":"class","apilevel":["pro"],"drawercat":""},"vex::servo":{"name":"vex::servo","members":{"servo":{"name":"servo","kind":"function","type":[""],"specialkind":"constructor","def":"vex::servo::servo","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new servo object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"position":{"name":"position","kind":"function","type":["void"],"specialkind":"none","def":"void vex::servo::position","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(int32_t value, percentUnits units)","desc":"Sets the position of the servo device.","params":[{"type":"int32_t","kind":"","declname":"value","desc":"Sets the amount of rotation."},{"type":"vex::percentUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(double value, rotationUnits units)","desc":"Sets the position of the servo device.","params":[{"type":"double","kind":"","declname":"value","desc":"Sets the amount of rotation."},{"type":"vex::rotationUnits","kind":"enum","declname":"units","desc":"The measurement unit for the rotation value."}]}],"apilevel":["block","cpp","pro"],"drawercat":"action"}},"desc":"Use this class when programming with a servo device.","id":"classvex_1_1servo","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::sonar":{"name":"vex::sonar","members":{"sonar":{"name":"sonar","kind":"function","type":[""],"specialkind":"constructor","def":"vex::sonar::sonar","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(triport::port &port)","desc":"Creates a new sonar object on the port specified in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"port","desc":"A reference to a three wire port."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"distance":{"name":"distance","kind":"function","type":["double"],"specialkind":"none","def":"double vex::sonar::distance","static":false,"overloads":[{"apilevel":["block","cpp","pro"],"drawercat":"sensing","argsstring":"(distanceUnits units)","desc":"Gets the value of the distance sensor.","params":[{"type":"vex::distanceUnits","kind":"enum","declname":"units","desc":"The measurement unit for the sonar device."}]}],"apilevel":["block","cpp","pro"],"drawercat":"sensing"},"changed":{"name":"changed","kind":"function","type":["void"],"specialkind":"none","def":"void vex::sonar::changed","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"sensing","argsstring":"(void(*callback)(void))","desc":"Calls a function when the sonar value changes.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"sensing"}},"desc":"Use this class when programming with a sonar sensor.","id":"classvex_1_1sonar","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::task":{"name":"vex::task","members":{"task":{"name":"task","kind":"function","type":[""],"specialkind":"constructor","def":"vex::task::task","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int(*callback)(void))","desc":"Constructs a task with a function callback.","params":[{"type":"int(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int(*callback)(void), int32_t priority)","desc":"Constructs a task with a function callback and a priority.","params":[{"type":"int(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."},{"type":"int32_t","kind":"","declname":"priority","desc":"Sets the priority of the task."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"stop":{"name":"stop","kind":"function","type":["void"],"specialkind":"none","def":"void vex::task::stop","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"()","desc":"Stops the task.","params":[]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int(*callback)(void))","desc":"Stops the task of the passed in function.","params":[{"type":"int(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["cpp","pro"],"drawercat":"action"},"suspend":{"name":"suspend","kind":"function","type":["void"],"specialkind":"none","def":"void vex::task::suspend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"()","desc":"Suspends the task until the task is told to resume.","params":[]}],"apilevel":["pro"],"drawercat":"action"},"resume":{"name":"resume","kind":"function","type":["void"],"specialkind":"none","def":"void vex::task::resume","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"action","argsstring":"()","desc":"Resumes the previously suspended task.","params":[]}],"apilevel":["pro"],"drawercat":"action"},"priority":{"name":"priority","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::task::priority","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"()","desc":"Gets the priority of the task.","params":[]}],"apilevel":["cpp","pro"],"drawercat":"sensing"},"setPriority":{"name":"setPriority","kind":"function","type":["void"],"specialkind":"none","def":"void vex::task::setPriority","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(int32_t priority)","desc":"Sets the priority of the task specified by the parameter.","params":[{"type":"int32_t","kind":"","declname":"priority","desc":"The priority level of the task."}]}],"apilevel":["cpp","pro"],"drawercat":"action"},"sleep":{"name":"sleep","kind":"function","type":["void"],"specialkind":"none","def":"static void vex::task::sleep","static":true,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(uint32_t time)","desc":"Sets the task to sleep for the specified amount of time (in milliseconds).","params":[{"type":"uint32_t","kind":"","declname":"time","desc":"The number of milliseconds for the task to sleep."}]}],"apilevel":["cpp","pro"],"drawercat":"action"},"yield":{"name":"yield","kind":"function","type":["void"],"specialkind":"none","def":"static void vex::task::yield","static":true,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"()","desc":"Suspends the enumerator and gives up control to the enumerating method. A breaking point in a task.","params":[]}],"apilevel":["cpp","pro"],"drawercat":"action"}},"desc":"Use this class to create and control tasks.","id":"classvex_1_1task","kind":"class","apilevel":["cpp","pro"],"drawercat":""},"vex::thread":{"name":"vex::thread","members":{"thread":{"name":"thread","kind":"function","type":[""],"specialkind":"constructor","def":"vex::thread::thread","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(int(*callback)(void))","desc":"Creates a thread object.","params":[{"type":"int(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]},{"apilevel":["pro"],"drawercat":"none","argsstring":"(void(*callback)(void))","desc":"Creates a thread object.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A reference to a function."}]}],"apilevel":["pro"],"drawercat":"none"},"get_id":{"name":"get_id","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::thread::get_id","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the ID of the thread.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"join":{"name":"join","kind":"function","type":["void"],"specialkind":"none","def":"void vex::thread::join","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Waits for the other thread to finish its execution.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"detach":{"name":"detach","kind":"function","type":["void"],"specialkind":"none","def":"void vex::thread::detach","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Permits the thread to execute from the thread handle.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"joinable":{"name":"joinable","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::thread::joinable","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Checks whether the thread is joinable.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"native_handle":{"name":"native_handle","kind":"function","type":["void *"],"specialkind":"none","def":"void* vex::thread::native_handle","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the pointer to the native handle of the thread.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void vex::thread::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(thread &__t)","desc":"Swaps the thread IDs with another specified thread in the parameter.","params":[{"type":"","kind":"","operator":"&","declname":"__t","desc":""}]},{"apilevel":["pro"],"drawercat":"none","argsstring":"(thread &__x, thread &__y)","desc":"Swaps two threads specified in the parameters.","params":[{"type":"","kind":"","operator":"&","declname":"__x","desc":""},{"type":"","kind":"","operator":"&","declname":"__y","desc":""}]}],"apilevel":["pro"],"drawercat":"none"},"interrupt":{"name":"interrupt","kind":"function","type":["void"],"specialkind":"none","def":"void vex::thread::interrupt","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Stops the thread.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"setPriority":{"name":"setPriority","kind":"function","type":["void"],"specialkind":"none","def":"void vex::thread::setPriority","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(int32_t priority)","desc":"Sets the priority of the thread.","params":[{"type":"int32_t","kind":"","declname":"priority","desc":"The priority of the thread to be set to."}]}],"apilevel":["pro"],"drawercat":"none"},"priority":{"name":"priority","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::thread::priority","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the priority of the thread.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"hardware_concurrency":{"name":"hardware_concurrency","kind":"function","type":["int32_t"],"specialkind":"none","def":"static int32_t vex::thread::hardware_concurrency","static":true,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the number of concurrent threads supported by the hardware.","params":[]}],"apilevel":["pro"],"drawercat":"none"}},"desc":"Use this class to create and control threads.","id":"classvex_1_1thread","kind":"class","apilevel":["pro"],"drawercat":""},"vex::timer":{"name":"vex::timer","members":{"time":{"name":"time","kind":"function","type":["uint32_t"],"specialkind":"none","def":"uint32_t vex::timer::time","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"() const","desc":"Gets the current value of the timer in mS.","params":[]},{"apilevel":["pro"],"drawercat":"none","argsstring":"(timeUnits units) const","desc":"Gets the current value of the timer in specified units.","params":[{"type":"vex::timeUnits","kind":"enum","declname":"units","desc":"The measurement unit for time."}]}],"apilevel":["pro"],"drawercat":"none"},"clear":{"name":"clear","kind":"function","type":["void"],"specialkind":"none","def":"void vex::timer::clear","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Sets the current value of the timer to 0.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"system":{"name":"system","kind":"function","type":["uint32_t"],"specialkind":"none","def":"static uint32_t vex::timer::system","static":true,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the current value of the system timer in mS.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"systemHighResolution":{"name":"systemHighResolution","kind":"function","type":["uint64_t"],"specialkind":"none","def":"static uint64_t vex::timer::systemHighResolution","static":true,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the current value of the high-resolution timer (in microseconds).","params":[]}],"apilevel":["pro"],"drawercat":"none"},"event":{"name":"event","kind":"function","type":["void"],"specialkind":"none","def":"static void vex::timer::event","static":true,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(void(*callback)(void *), uint32_t value)","desc":"Sets a callback that will be called in the future.","params":[{"type":"void(*)(void *)","kind":"","declname":"callback","desc":"A pointer to a function that will be called when the timer expires."},{"type":"uint32_t","kind":"","declname":"value","desc":"The delay in mS to when the function will be called."}]},{"apilevel":["pro"],"drawercat":"none","argsstring":"(void(*callback)(void), uint32_t value)","desc":"Sets a callback that will be called in the future.","params":[{"type":"void(*)(void)","kind":"","declname":"callback","desc":"A pointer to a function that will be called when the timer expires."},{"type":"uint32_t","kind":"","declname":"value","desc":"The delay in mS to when the function will be called."}]}],"apilevel":["pro"],"drawercat":"none"}},"desc":"Use the timer class to create timers for your program.","id":"classvex_1_1timer","kind":"class","apilevel":["pro"],"drawercat":""},"vex::vision":{"name":"vex::vision","members":{"objectCount":{"name":"objectCount","kind":"variable","type":["int32_t"],"specialkind":"none","def":"int32_t vex::vision::objectCount","static":false,"desc":"The amount of objects found in the data sample.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"largestObject":{"name":"largestObject","kind":"variable","type":["vex::vision::object"],"specialkind":"none","def":"object vex::vision::largestObject","static":false,"desc":"The largest object found in the data sample.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"objects":{"name":"objects","kind":"variable","type":["vex::vision::object"],"specialkind":"none","def":"safearray< object, VISION_MAX_OBJECTS > vex::vision::objects","static":false,"desc":"An array containing the largest object(s) found in the data sample.  \n  \n.","apilevel":["block","cpp","pro"],"drawercat":"instance"},"vision":{"name":"vision","kind":"function","type":[""],"specialkind":"constructor","def":"vex::vision::vision","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t index)","desc":"Creates a new vision object on the port specified.","params":[{"type":"int32_t","kind":"","declname":"index","desc":"The port index for this vision. The index is zero-based."}]},{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t index, uint8_t bright, Args... sigs)","desc":"Creates a new vision object on the port specified. Sets the brightness setting and all of the vision objects settings.","params":[{"type":"int32_t","kind":"","declname":"index","desc":"The port index for this vision. The index is zero-based."},{"type":"uint8_t","kind":"","declname":"bright","desc":"The vision sensor brightness setting. Values are 0 to 255"},{"type":"Args...","kind":"","declname":"sigs","desc":"List of signature objects used to set up the detection signatures for this sensor."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"},"takeSnapshot":{"name":"takeSnapshot","kind":"function","type":["int32_t"],"specialkind":"none","def":"int32_t vex::vision::takeSnapshot","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(uint32_t id)","desc":"Takes a data sample from the vision sensor.","params":[{"type":"uint32_t","kind":"","declname":"id","desc":"The ID of the object to look for."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(code &cc)","desc":"Takes a data sample from the vision sensor.","params":[{"type":"vex::vision::code","kind":"","operator":"&","declname":"cc","desc":"The code signature of the object to look for."}]},{"apilevel":["block","cpp","pro"],"drawercat":"action","argsstring":"(signature &sig)","desc":"Takes a data sample from the vision sensor.","params":[{"type":"vex::vision::signature","kind":"","operator":"&","declname":"sig","desc":"The signature of the object to look for."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(uint32_t id, uint32_t count)","desc":"Takes a data sample from the vision sensor, and only stores the largest samples of the specified amount.","params":[{"type":"uint32_t","kind":"","declname":"id","desc":"The ID of the object to look for."},{"type":"uint32_t","kind":"","declname":"count","desc":"the amount of objects to look for. The largest of the object will be returned."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(code &cc, uint32_t count)","desc":"Takes a data sample from the vision sensor, and only stores the largest samples of the specified amount.","params":[{"type":"vex::vision::code","kind":"","operator":"&","declname":"cc","desc":"The code signature of the object to look for."},{"type":"uint32_t","kind":"","declname":"count","desc":"the amount of objects to look for. The largest of the object will be returned."}]},{"apilevel":["cpp","pro"],"drawercat":"action","argsstring":"(signature &sig, uint32_t count)","desc":"Takes a data sample from the vision sensor, and only stores the largest samples of the specified amount.","params":[{"type":"vex::vision::signature","kind":"","operator":"&","declname":"sig","desc":"The signature of the object to look for."},{"type":"uint32_t","kind":"","declname":"count","desc":"the amount of objects to look for. The largest of the object will be returned."}]}],"apilevel":["cpp","pro","block"],"drawercat":"action"},"setLedMode":{"name":"setLedMode","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::vision::setLedMode","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(tLedMode mode)","desc":"Changes the mode of the LED on the vision sensor.","params":[{"type":"tLedMode","kind":"","declname":"mode","desc":"The LED mode. Automatic mode will cause the LED color to be controlled by the vision sensor firmware. Manual mode allows the LED color to be controlled by the user program."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"getLedMode":{"name":"getLedMode","kind":"function","type":["tLedMode"],"specialkind":"none","def":"tLedMode vex::vision::getLedMode","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(void)","desc":"Gets the mode of the LED from the vision sensor.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["cpp","pro"],"drawercat":"sensing"},"setLedBrightness":{"name":"setLedBrightness","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::vision::setLedBrightness","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(uint8_t percent)","desc":"Changes the brightness of the LED on the vision sensor when LED is set to manual mode.","params":[{"type":"uint8_t","kind":"","declname":"percent","desc":"A percentage of total brightness of the vision sensor LED when in manual mode. Values are 0 to 100. 0 = LED off"}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"getLedBrightness":{"name":"getLedBrightness","kind":"function","type":["uint8_t"],"specialkind":"none","def":"uint8_t vex::vision::getLedBrightness","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(void)","desc":"Gets the brightness of the LED from the vision sensor.","params":[{"type":"void","kind":"","desc":""}]}],"apilevel":["cpp","pro"],"drawercat":"sensing"},"setLedColor":{"name":"setLedColor","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::vision::setLedColor","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"setting","argsstring":"(uint8_t red, uint8_t green, uint8_t blue)","desc":"Changes the color of the LED on the vision sensor when LED is set to manual mode.","params":[{"type":"uint8_t","kind":"","declname":"red","desc":"A value from 0 to 255 the represents the intensity of the red color of the LED."},{"type":"uint8_t","kind":"","declname":"green","desc":"A value from 0 to 255 the represents the intensity of the green color of the LED."},{"type":"uint8_t","kind":"","declname":"blue","desc":"A value from 0 to 255 the represents the intensity of the blue color of the LED."}]}],"apilevel":["cpp","pro"],"drawercat":"setting"},"getLedColor":{"name":"getLedColor","kind":"function","type":["bool"],"specialkind":"none","def":"bool vex::vision::getLedColor","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"sensing","argsstring":"(uint8_t *red, uint8_t *green, uint8_t *blue)","desc":"Gets the color of the LED from the vision sensor.","params":[{"type":"uint8_t *","kind":"","declname":"red","desc":"A reference to a value to store the intensity of the red color of the LED."},{"type":"uint8_t *","kind":"","declname":"green","desc":"A reference to a value to store the intensity of the green color of the LED."},{"type":"uint8_t *","kind":"","declname":"blue","desc":"A reference to a value to store the intensity of the blue color of the LED."}]}],"apilevel":["cpp","pro"],"drawercat":"sensing"}},"desc":"Use this class when programming the vision sensor.","id":"classvex_1_1vision","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::vision::code":{"name":"vex::vision::code","members":{"code":{"name":"code","kind":"function","type":[""],"specialkind":"constructor","def":"vex::vision::code::code","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(signature &s1, signature &s2)","desc":"Creates a new vision code object.","params":[{"type":"","kind":"","operator":"&","declname":"s1","desc":""},{"type":"","kind":"","operator":"&","declname":"s2","desc":""}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"}},"desc":"Use this class when programming the vision sensor.","id":"classvex_1_1vision_1_1code","kind":"class","apilevel":["pro"],"drawercat":""},"vex::vision::object":{"name":"vex::vision::object","members":{"id":{"name":"id","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::id","static":false,"desc":"The unique ID of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"originX":{"name":"originX","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::originX","static":false,"desc":"The top left x position of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"originY":{"name":"originY","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::originY","static":false,"desc":"The top left y position of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"centerX":{"name":"centerX","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::centerX","static":false,"desc":"The center x position of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"centerY":{"name":"centerY","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::centerY","static":false,"desc":"The center y position of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"width":{"name":"width","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::width","static":false,"desc":"The width of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"height":{"name":"height","kind":"variable","type":["const int &"],"specialkind":"none","def":"const int& vex::vision::object::height","static":false,"desc":"The height of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"angle":{"name":"angle","kind":"variable","type":["const double &"],"specialkind":"none","def":"const double& vex::vision::object::angle","static":false,"desc":"The angle of the object.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"exists":{"name":"exists","kind":"variable","type":["const bool &"],"specialkind":"none","def":"const bool& vex::vision::object::exists","static":false,"desc":"If the vision sensor detects the object or not.","apilevel":["block","cpp","pro"],"drawercat":"sensing"},"object":{"name":"object","kind":"function","type":[""],"specialkind":"constructor","def":"vex::vision::object::object","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Creates a new vision object with all properties set to default values.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"set":{"name":"set","kind":"function","type":["void"],"specialkind":"none","def":"void vex::vision::object::set","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(V5_DeviceVisionObject obj)","desc":"Copies all properties of the passed in object into this object.","params":[{"type":"V5_DeviceVisionObject","kind":"","declname":"obj","desc":"The object whose properties are to be copied."}]}],"apilevel":["pro"],"drawercat":"none"},"flipAngle":{"name":"flipAngle","kind":"function","type":["void"],"specialkind":"none","def":"void vex::vision::object::flipAngle","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Inverts the angle for this object.","params":[]}],"apilevel":["pro"],"drawercat":"none"},"clear":{"name":"clear","kind":"function","type":["void"],"specialkind":"none","def":"void vex::vision::object::clear","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Sets all properties for this object to default values.","params":[]}],"apilevel":["pro"],"drawercat":"none"}},"desc":"The object class represents an object that the vision sensor detects.","id":"classvex_1_1vision_1_1object","kind":"class","apilevel":["block","cpp","pro"],"drawercat":""},"vex::vision::signature":{"name":"vex::vision::signature","members":{"signature":{"name":"signature","kind":"function","type":[""],"specialkind":"constructor","def":"vex::vision::signature::signature","static":false,"overloads":[{"apilevel":["cpp","pro"],"drawercat":"constructor","argsstring":"(int32_t id, int32_t uMin, int32_t uMax, int32_t uMean, int32_t vMin, int32_t vMax, int32_t vMean, float range, int32_t type)","desc":"Creates a new vision signature object.","params":[{"type":"int32_t","kind":"","declname":"id","desc":"The signature id."},{"type":"int32_t","kind":"","declname":"uMin","desc":"The signature minimum value on the u axis."},{"type":"int32_t","kind":"","declname":"uMax","desc":"The signature maximum value on the u axis."},{"type":"int32_t","kind":"","declname":"uMean","desc":"The signature mean value on the u axis."},{"type":"int32_t","kind":"","declname":"vMin","desc":"The signature minimum value on the v axis."},{"type":"int32_t","kind":"","declname":"vMax","desc":"The signature maximum value on the v axis."},{"type":"int32_t","kind":"","declname":"vMean","desc":"The signature mean value on the v axis."},{"type":"float","kind":"","declname":"range","desc":"The signature range scale factor."},{"type":"int32_t","kind":"","declname":"type","desc":"The signature type, normal, or color code."}]}],"apilevel":["cpp","pro"],"drawercat":"constructor"}},"desc":"Use this class when programming the vision sensor.","id":"classvex_1_1vision_1_1signature","kind":"class","apilevel":["pro"],"drawercat":""},"vex::this_thread":{"name":"vex::this_thread","members":{},"Classes":{},"files":{},"desc":"","id":"namespacevex_1_1this__thread","kind":"class","specialkind":"namespace","apilevel":["pro"],"drawercat":""}},"files":{},"desc":"Triport device class.","id":"namespacevex","kind":"namespace"},"vex::this_thread":{"name":"vex::this_thread","members":{"get_id":{"name":"get_id","kind":"function","type":["int32_t"],"def":"int32_t vex::this_thread::get_id","apilevel":["pro"],"drawercat":"none","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the ID of the thread.","params":[]}]},"yield":{"name":"yield","kind":"function","type":["void"],"def":"void vex::this_thread::yield","apilevel":["pro"],"drawercat":"none","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Suspends the current thread.","params":[]}]},"sleep_for":{"name":"sleep_for","kind":"function","type":["void"],"def":"void vex::this_thread::sleep_for","apilevel":["pro"],"drawercat":"none","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(const std::chrono::duration< _Rep, _Period > &__rtime)","desc":"Suspends the current thread until the time is expired in milliseconds.","params":[{"type":"const std::chrono::duration< _Rep, _Period > &","kind":"","declname":"__rtime","desc":""}]}]},"sleep_until":{"name":"sleep_until","kind":"function","type":["void"],"def":"void vex::this_thread::sleep_until","apilevel":["pro"],"drawercat":"none","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(const std::chrono::time_point< _Clock, _Duration > &__atime)","desc":"Sleeps until the system timer reaches the time specified in the parameter.","params":[{"type":"const std::chrono::time_point< _Clock, _Duration > &","kind":"","declname":"__atime","desc":""}]}]},"setPriority":{"name":"setPriority","kind":"function","type":["void"],"def":"void vex::this_thread::setPriority","apilevel":["pro"],"drawercat":"none","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"(int32_t priority)","desc":"Sets the priority of the current thread.","params":[{"type":"int32_t","kind":"","declname":"priority","desc":"The priority of the thread to be set to."}]}]},"priority":{"name":"priority","kind":"function","type":["int32_t"],"def":"int32_t vex::this_thread::priority","apilevel":["pro"],"drawercat":"none","static":false,"overloads":[{"apilevel":["pro"],"drawercat":"none","argsstring":"()","desc":"Gets the priority of the current thread.","params":[]}]}},"Classes":{},"files":{},"desc":"","id":"namespacevex_1_1this__thread","kind":"namespace"},"std":{"name":"std","members":{"@52":{"name":"@52","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[{"name":"_S_threshold","desc":""}],"desc":""},"@53":{"name":"@53","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[{"name":"_S_chunk_size","desc":""}],"desc":""},"@54":{"name":"@54","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[{"name":"_S_word_bit","desc":""}],"desc":""},"__memory_order_modifier":{"name":"__memory_order_modifier","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"_Ios_Fmtflags":{"name":"_Ios_Fmtflags","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"_Ios_Iostate":{"name":"_Ios_Iostate","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"_Ios_Openmode":{"name":"_Ios_Openmode","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"_Ios_Seekdir":{"name":"_Ios_Seekdir","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"_Rb_tree_color":{"name":"_Rb_tree_color","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"errc":{"name":"errc","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":""},"memory_order":{"name":"memory_order","kind":"enum","type":[""],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"enumvalue":[],"desc":"Enumeration for memory_order."},"__add_grouping":{"name":"__add_grouping","kind":"function","type":["_CharT *"],"def":"_CharT* std::__add_grouping","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT *__s, _CharT __sep, const char *__gbeg, size_t __gsize, const _CharT *__first, const _CharT *__last)","desc":"","params":[{"type":"_CharT *","kind":"","declname":"__s","desc":""},{"type":"_CharT","kind":"","declname":"__sep","desc":""},{"type":"const char *","kind":"","declname":"__gbeg","desc":""},{"type":"size_t","kind":"","declname":"__gsize","desc":""},{"type":"const _CharT *","kind":"","declname":"__first","desc":""},{"type":"const _CharT *","kind":"","declname":"__last","desc":""}]}]},"__addressof":{"name":"__addressof","kind":"function","type":["_Tp *"],"def":"_Tp* std::__addressof","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp &__r) noexcept","desc":"Same as C++11 std::addressof.","params":[{"type":"_Tp &","kind":"","declname":"__r","desc":""}]}]},"__adjacent_find":{"name":"__adjacent_find","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__adjacent_find","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":""}]}]},"__adjust_heap":{"name":"__adjust_heap","kind":"function","type":["void"],"def":"void std::__adjust_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_Distance","kind":"","declname":"__holeIndex","desc":""},{"type":"_Distance","kind":"","declname":"__len","desc":""},{"type":"_Tp","kind":"","declname":"__value","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__advance":{"name":"__advance","kind":"function","type":["void"],"def":"void std::__advance","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator &__i, _Distance __n, random_access_iterator_tag)","desc":"","params":[{"type":"_RandomAccessIterator &","kind":"","declname":"__i","desc":""},{"type":"_Distance","kind":"","declname":"__n","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__alloc_on_copy":{"name":"__alloc_on_copy","kind":"function","type":["_Alloc"],"def":"_Alloc std::__alloc_on_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Alloc &__a)","desc":"","params":[{"type":"const _Alloc &","kind":"","declname":"__a","desc":""}]}]},"__alloc_on_move":{"name":"__alloc_on_move","kind":"function","type":["void"],"def":"void std::__alloc_on_move","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Alloc &__one, _Alloc &__two)","desc":"","params":[{"type":"_Alloc &","kind":"","declname":"__one","desc":""},{"type":"_Alloc &","kind":"","declname":"__two","desc":""}]}]},"__alloc_on_swap":{"name":"__alloc_on_swap","kind":"function","type":["void"],"def":"void std::__alloc_on_swap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Alloc &__one, _Alloc &__two)","desc":"","params":[{"type":"_Alloc &","kind":"","declname":"__one","desc":""},{"type":"_Alloc &","kind":"","declname":"__two","desc":""}]}]},"__allocate_shared":{"name":"__allocate_shared","kind":"function","type":["__shared_ptr< _Tp, _Lp >"],"def":"__shared_ptr<_Tp, _Lp> std::__allocate_shared","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Alloc &__a, _Args &&...__args)","desc":"","params":[{"type":"const _Alloc &","kind":"","declname":"__a","desc":""},{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}]},"__attribute__":{"name":"__attribute__","kind":"function","type":[""],"def":"std::__attribute__","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"((always_inline)) void atomic_thread_fence(memory_order __m) noexcept","desc":"","params":[{"type":"(always_inline)","kind":"","desc":""}]}]},"__check_facet":{"name":"__check_facet","kind":"function","type":["const _Facet &"],"def":"const _Facet& std::__check_facet","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Facet *__f)","desc":"","params":[{"type":"const _Facet *","kind":"","declname":"__f","desc":""}]}]},"__chunk_insertion_sort":{"name":"__chunk_insertion_sort","kind":"function","type":["void"],"def":"void std::__chunk_insertion_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Distance","kind":"","declname":"__chunk_size","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__cmpexch_failure_order":{"name":"__cmpexch_failure_order","kind":"function","type":[""],"def":"constexpr memory_order std::__cmpexch_failure_order","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(memory_order __m) noexcept","desc":"","params":[{"type":"","kind":"","declname":"__m","desc":""}]}]},"__cmpexch_failure_order2":{"name":"__cmpexch_failure_order2","kind":"function","type":[""],"def":"constexpr memory_order std::__cmpexch_failure_order2","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(memory_order __m) noexcept","desc":"","params":[{"type":"","kind":"","declname":"__m","desc":""}]}]},"__convert_from_v":{"name":"__convert_from_v","kind":"function","type":["int"],"def":"int std::__convert_from_v","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const __c_locale &__cloc __attribute__((__unused__)), char *__out, const int __size __attribute__((__unused__)), const char *__fmt,...)","desc":"","params":[{"type":"const __c_locale &__cloc","kind":"","declname":"__attribute__","desc":""},{"type":"char *","kind":"","declname":"__out","desc":""},{"type":"const int __size","kind":"","declname":"__attribute__","desc":""},{"type":"const char *","kind":"","declname":"__fmt","desc":""},{"type":"...","kind":"","desc":""}]}]},"__convert_to_v":{"name":"__convert_to_v","kind":"function","type":["void"],"def":"void std::__convert_to_v","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *, long double &, ios_base::iostate &, const __c_locale &)","desc":"","params":[{"type":"const char *","kind":"","desc":""},{"type":"long double &","kind":"","desc":""},{"type":"","kind":"","operator":"&","desc":""},{"type":"const __c_locale &","kind":"","desc":""}]}]},"__copy_move_a":{"name":"__copy_move_a","kind":"function","type":["_OI"],"def":"_OI std::__copy_move_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II __first, _II __last, _OI __result)","desc":"","params":[{"type":"_II","kind":"","declname":"__first","desc":""},{"type":"_II","kind":"","declname":"__last","desc":""},{"type":"_OI","kind":"","declname":"__result","desc":""}]}]},"__copy_move_a2":{"name":"__copy_move_a2","kind":"function","type":["_OI"],"def":"_OI std::__copy_move_a2","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II __first, _II __last, _OI __result)","desc":"","params":[{"type":"_II","kind":"","declname":"__first","desc":""},{"type":"_II","kind":"","declname":"__last","desc":""},{"type":"_OI","kind":"","declname":"__result","desc":""}]}]},"__copy_move_backward_a":{"name":"__copy_move_backward_a","kind":"function","type":["_BI2"],"def":"_BI2 std::__copy_move_backward_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BI1 __first, _BI1 __last, _BI2 __result)","desc":"","params":[{"type":"_BI1","kind":"","declname":"__first","desc":""},{"type":"_BI1","kind":"","declname":"__last","desc":""},{"type":"_BI2","kind":"","declname":"__result","desc":""}]}]},"__copy_move_backward_a2":{"name":"__copy_move_backward_a2","kind":"function","type":["_BI2"],"def":"_BI2 std::__copy_move_backward_a2","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BI1 __first, _BI1 __last, _BI2 __result)","desc":"","params":[{"type":"_BI1","kind":"","declname":"__first","desc":""},{"type":"_BI1","kind":"","declname":"__last","desc":""},{"type":"_BI2","kind":"","declname":"__result","desc":""}]}]},"__copy_n":{"name":"__copy_n","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__copy_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _Size __n, _OutputIterator __result, random_access_iterator_tag)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__count_if":{"name":"__count_if","kind":"function","type":["iterator_traits< _InputIterator >::difference_type"],"def":"iterator_traits<_InputIterator>::difference_type std::__count_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__deque_buf_size":{"name":"__deque_buf_size","kind":"function","type":["size_t"],"def":"size_t std::__deque_buf_size","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_t __size)","desc":"","params":[{"type":"size_t","kind":"","declname":"__size","desc":""}]}]},"__distance":{"name":"__distance","kind":"function","type":["iterator_traits< _RandomAccessIterator >::difference_type"],"def":"iterator_traits<_RandomAccessIterator>::difference_type std::__distance","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__do_alloc_on_copy":{"name":"__do_alloc_on_copy","kind":"function","type":["void"],"def":"void std::__do_alloc_on_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Alloc &, const _Alloc &, false_type)","desc":"","params":[{"type":"_Alloc &","kind":"","desc":""},{"type":"const _Alloc &","kind":"","desc":""},{"type":"false_type","kind":"","desc":""}]}]},"__do_alloc_on_move":{"name":"__do_alloc_on_move","kind":"function","type":["void"],"def":"void std::__do_alloc_on_move","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Alloc &, _Alloc &, false_type)","desc":"","params":[{"type":"_Alloc &","kind":"","desc":""},{"type":"_Alloc &","kind":"","desc":""},{"type":"false_type","kind":"","desc":""}]}]},"__do_alloc_on_swap":{"name":"__do_alloc_on_swap","kind":"function","type":["void"],"def":"void std::__do_alloc_on_swap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Alloc &, _Alloc &, false_type)","desc":"","params":[{"type":"_Alloc &","kind":"","desc":""},{"type":"_Alloc &","kind":"","desc":""},{"type":"false_type","kind":"","desc":""}]}]},"__enable_shared_from_this_helper":{"name":"__enable_shared_from_this_helper","kind":"function","type":["void"],"def":"void std::__enable_shared_from_this_helper","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const __shared_count< _Lp > &,...) noexcept","desc":"","params":[{"type":"const __shared_count< _Lp > &","kind":"","desc":""},{"type":"...","kind":"","desc":""}]}]},"__equal_aux":{"name":"__equal_aux","kind":"function","type":["bool"],"def":"bool std::__equal_aux","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II1 __first1, _II1 __last1, _II2 __first2)","desc":"","params":[{"type":"_II1","kind":"","declname":"__first1","desc":""},{"type":"_II1","kind":"","declname":"__last1","desc":""},{"type":"_II2","kind":"","declname":"__first2","desc":""}]}]},"__equal_range":{"name":"__equal_range","kind":"function","type":["std::pair"],"def":"pair<_ForwardIterator, _ForwardIterator> std::__equal_range","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__val","desc":""},{"type":"_CompareItTp","kind":"","declname":"__comp_it_val","desc":""},{"type":"_CompareTpIt","kind":"","declname":"__comp_val_it","desc":""}]}]},"__fill_a":{"name":"__fill_a","kind":"function","type":["__gnu_cxx::__enable_if< __is_byte< _Tp >::__value, void >::__type"],"def":"__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type std::__fill_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp *__first, _Tp *__last, const _Tp &__c)","desc":"","params":[{"type":"_Tp *","kind":"","declname":"__first","desc":""},{"type":"_Tp *","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__c","desc":""}]}]},"__fill_bvector":{"name":"__fill_bvector","kind":"function","type":["void"],"def":"void std::__fill_bvector","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Bit_iterator __first, _Bit_iterator __last, bool __x)","desc":"","params":[{"type":"_Bit_iterator","kind":"","declname":"__first","desc":""},{"type":"_Bit_iterator","kind":"","declname":"__last","desc":""},{"type":"bool","kind":"","declname":"__x","desc":""}]}]},"__fill_n_a":{"name":"__fill_n_a","kind":"function","type":["__gnu_cxx::__enable_if< __is_byte< _Tp >::__value, _Tp * >::__type"],"def":"__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type std::__fill_n_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp *__first, _Size __n, const _Tp &__c)","desc":"","params":[{"type":"_Tp *","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"const _Tp &","kind":"","declname":"__c","desc":""}]}]},"__final_insertion_sort":{"name":"__final_insertion_sort","kind":"function","type":["void"],"def":"void std::__final_insertion_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function for the sort routine.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__find_end":{"name":"__find_end","kind":"function","type":["_BidirectionalIterator1"],"def":"_BidirectionalIterator1 std::__find_end","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, bidirectional_iterator_tag, bidirectional_iterator_tag, _BinaryPredicate __comp)","desc":"","params":[{"type":"_BidirectionalIterator1","kind":"","declname":"__first1","desc":""},{"type":"_BidirectionalIterator1","kind":"","declname":"__last1","desc":""},{"type":"_BidirectionalIterator2","kind":"","declname":"__first2","desc":""},{"type":"_BidirectionalIterator2","kind":"","declname":"__last2","desc":""},{"type":"std::bidirectional_iterator_tag","kind":"","desc":""},{"type":"std::bidirectional_iterator_tag","kind":"","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__comp","desc":""}]}]},"__find_if":{"name":"__find_if","kind":"function","type":["_Iterator"],"def":"_Iterator std::__find_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Iterator __first, _Iterator __last, _Predicate __pred)","desc":"","params":[{"type":"_Iterator","kind":"","declname":"__first","desc":""},{"type":"_Iterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__find_if_not":{"name":"__find_if_not","kind":"function","type":["_InputIterator"],"def":"_InputIterator std::__find_if_not","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Provided for stable_partition to use.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__find_if_not_n":{"name":"__find_if_not_n","kind":"function","type":["_InputIterator"],"def":"_InputIterator std::__find_if_not_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _Distance &__len, _Predicate __pred)","desc":"Like find_if_not(), but uses and updates a count of the remaining range length instead of comparing against an end iterator.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_Distance &","kind":"","declname":"__len","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__gcd":{"name":"__gcd","kind":"function","type":["_EuclideanRingElement"],"def":"_EuclideanRingElement std::__gcd","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_EuclideanRingElement __m, _EuclideanRingElement __n)","desc":"","params":[{"type":"_EuclideanRingElement","kind":"","declname":"__m","desc":""},{"type":"_EuclideanRingElement","kind":"","declname":"__n","desc":""}]}]},"__get_nested_exception":{"name":"__get_nested_exception","kind":"function","type":["std::nested_exception"],"def":"const nested_exception* std::__get_nested_exception","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Ex &__ex)","desc":"","params":[{"type":"const _Ex &","kind":"","declname":"__ex","desc":""}]}]},"__heap_select":{"name":"__heap_select","kind":"function","type":["void"],"def":"void std::__heap_select","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function for the sort routines.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__middle","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__iconv_adaptor":{"name":"__iconv_adaptor","kind":"function","type":["size_t"],"def":"size_t std::__iconv_adaptor","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_t(*__func)(iconv_t, _Tp, size_t *, char **, size_t *), iconv_t __cd, char **__inbuf, size_t *__inbytes, char **__outbuf, size_t *__outbytes)","desc":"","params":[{"type":"size_t(*)(iconv_t, _Tp, size_t *, char **, size_t *)","kind":"","declname":"__func","desc":""},{"type":"iconv_t","kind":"","declname":"__cd","desc":""},{"type":"char **","kind":"","declname":"__inbuf","desc":""},{"type":"size_t *","kind":"","declname":"__inbytes","desc":""},{"type":"char **","kind":"","declname":"__outbuf","desc":""},{"type":"size_t *","kind":"","declname":"__outbytes","desc":""}]}]},"__includes":{"name":"__includes","kind":"function","type":["bool"],"def":"bool std::__includes","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__inplace_merge":{"name":"__inplace_merge","kind":"function","type":["void"],"def":"void std::__inplace_merge","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)","desc":"","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__middle","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__inplace_stable_partition":{"name":"__inplace_stable_partition","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__inplace_stable_partition","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _Predicate __pred, _Distance __len)","desc":"This is a helper function... Requires __len != 0 and !__pred(*__first), same as __stable_partition_adaptive.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""},{"type":"_Distance","kind":"","declname":"__len","desc":""}]}]},"__inplace_stable_sort":{"name":"__inplace_stable_sort","kind":"function","type":["void"],"def":"void std::__inplace_stable_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function for the stable sorting routines.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__insertion_sort":{"name":"__insertion_sort","kind":"function","type":["void"],"def":"void std::__insertion_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function for the sort routine.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__introselect":{"name":"__introselect","kind":"function","type":["void"],"def":"void std::__introselect","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__nth","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Size","kind":"","declname":"__depth_limit","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__introsort_loop":{"name":"__introsort_loop","kind":"function","type":["void"],"def":"void std::__introsort_loop","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)","desc":"This is a helper function for the sort routine.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Size","kind":"","declname":"__depth_limit","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__is_heap":{"name":"__is_heap","kind":"function","type":["bool"],"def":"bool std::__is_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__is_heap_until":{"name":"__is_heap_until","kind":"function","type":["_Distance"],"def":"_Distance std::__is_heap_until","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _Distance __n, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_Distance","kind":"","declname":"__n","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__is_permutation":{"name":"__is_permutation","kind":"function","type":["bool"],"def":"bool std::__is_permutation","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)","desc":"","params":[{"type":"_ForwardIterator1","kind":"","declname":"__first1","desc":""},{"type":"_ForwardIterator1","kind":"","declname":"__last1","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__first2","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__pred","desc":""}]}]},"__is_sorted_until":{"name":"__is_sorted_until","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__is_sorted_until","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__iterator_category":{"name":"__iterator_category","kind":"function","type":["iterator_traits< _Iter >::iterator_category"],"def":"iterator_traits<_Iter>::iterator_category std::__iterator_category","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Iter &)","desc":"","params":[{"type":"const _Iter &","kind":"","desc":""}]}]},"__lexicographical_compare_aux":{"name":"__lexicographical_compare_aux","kind":"function","type":["bool"],"def":"bool std::__lexicographical_compare_aux","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)","desc":"","params":[{"type":"_II1","kind":"","declname":"__first1","desc":""},{"type":"_II1","kind":"","declname":"__last1","desc":""},{"type":"_II2","kind":"","declname":"__first2","desc":""},{"type":"_II2","kind":"","declname":"__last2","desc":""}]}]},"__lexicographical_compare_impl":{"name":"__lexicographical_compare_impl","kind":"function","type":["bool"],"def":"bool std::__lexicographical_compare_impl","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)","desc":"","params":[{"type":"_II1","kind":"","declname":"__first1","desc":""},{"type":"_II1","kind":"","declname":"__last1","desc":""},{"type":"_II2","kind":"","declname":"__first2","desc":""},{"type":"_II2","kind":"","declname":"__last2","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__lg":{"name":"__lg","kind":"function","type":["constexpr unsigned long long"],"def":"constexpr unsigned long long std::__lg","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(unsigned long long __n)","desc":"","params":[{"type":"unsigned long long","kind":"","declname":"__n","desc":""}]}]},"__lower_bound":{"name":"__lower_bound","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__lower_bound","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__val","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__make_heap":{"name":"__make_heap","kind":"function","type":["void"],"def":"void std::__make_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__make_move_if_noexcept_iterator":{"name":"__make_move_if_noexcept_iterator","kind":"function","type":["_ReturnType"],"def":"_ReturnType std::__make_move_if_noexcept_iterator","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Iterator __i)","desc":"","params":[{"type":"_Iterator","kind":"","declname":"__i","desc":""}]}]},"__make_shared":{"name":"__make_shared","kind":"function","type":["__shared_ptr< _Tp, _Lp >"],"def":"__shared_ptr<_Tp, _Lp> std::__make_shared","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}]},"__max_element":{"name":"__max_element","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__max_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__merge":{"name":"__merge","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__merge","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__merge_adaptive":{"name":"__merge_adaptive","kind":"function","type":["void"],"def":"void std::__merge_adaptive","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)","desc":"This is a helper function for the merge routines.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__middle","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Distance","kind":"","declname":"__len1","desc":""},{"type":"_Distance","kind":"","declname":"__len2","desc":""},{"type":"_Pointer","kind":"","declname":"__buffer","desc":""},{"type":"_Distance","kind":"","declname":"__buffer_size","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__merge_sort_loop":{"name":"__merge_sort_loop","kind":"function","type":["void"],"def":"void std::__merge_sort_loop","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator1","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator1","kind":"","declname":"__last","desc":""},{"type":"_RandomAccessIterator2","kind":"","declname":"__result","desc":""},{"type":"_Distance","kind":"","declname":"__step_size","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__merge_sort_with_buffer":{"name":"__merge_sort_with_buffer","kind":"function","type":["void"],"def":"void std::__merge_sort_with_buffer","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Pointer","kind":"","declname":"__buffer","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__merge_without_buffer":{"name":"__merge_without_buffer","kind":"function","type":["void"],"def":"void std::__merge_without_buffer","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)","desc":"This is a helper function for the merge routines.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__middle","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Distance","kind":"","declname":"__len1","desc":""},{"type":"_Distance","kind":"","declname":"__len2","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__min_element":{"name":"__min_element","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__min_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__minmax_element":{"name":"__minmax_element","kind":"function","type":["std::pair"],"def":"pair<_ForwardIterator, _ForwardIterator> std::__minmax_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__mismatch":{"name":"__mismatch","kind":"function","type":["std::pair"],"def":"pair<_InputIterator1, _InputIterator2> std::__mismatch","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":""}]}]},"__miter_base":{"name":"__miter_base","kind":"function","type":["_Miter_base< _Iterator >::iterator_type"],"def":"_Miter_base<_Iterator>::iterator_type std::__miter_base","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Iterator __it)","desc":"","params":[{"type":"_Iterator","kind":"","declname":"__it","desc":""}]}]},"__move_median_to_first":{"name":"__move_median_to_first","kind":"function","type":["void"],"def":"void std::__move_median_to_first","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Iterator __result, _Iterator __a, _Iterator __b, _Iterator __c, _Compare __comp)","desc":"Swaps the median value of *__a, *__b and *__c under __comp to *__result.","params":[{"type":"_Iterator","kind":"","declname":"__result","desc":""},{"type":"_Iterator","kind":"","declname":"__a","desc":""},{"type":"_Iterator","kind":"","declname":"__b","desc":""},{"type":"_Iterator","kind":"","declname":"__c","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__move_merge":{"name":"__move_merge","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__move_merge","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first1, _InputIterator __last1, _InputIterator __first2, _InputIterator __last2, _OutputIterator __result, _Compare __comp)","desc":"This is a helper function for the __merge_sort_loop routines.","params":[{"type":"_InputIterator","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__move_merge_adaptive":{"name":"__move_merge_adaptive","kind":"function","type":["void"],"def":"void std::__move_merge_adaptive","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"This is a helper function for the __merge_adaptive routines.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__move_merge_adaptive_backward":{"name":"__move_merge_adaptive_backward","kind":"function","type":["void"],"def":"void std::__move_merge_adaptive_backward","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)","desc":"This is a helper function for the __merge_adaptive routines.","params":[{"type":"_BidirectionalIterator1","kind":"","declname":"__first1","desc":""},{"type":"_BidirectionalIterator1","kind":"","declname":"__last1","desc":""},{"type":"_BidirectionalIterator2","kind":"","declname":"__first2","desc":""},{"type":"_BidirectionalIterator2","kind":"","declname":"__last2","desc":""},{"type":"_BidirectionalIterator3","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__next_permutation":{"name":"__next_permutation","kind":"function","type":["bool"],"def":"bool std::__next_permutation","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)","desc":"","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__niter_base":{"name":"__niter_base","kind":"function","type":["_Niter_base< _Iterator >::iterator_type"],"def":"_Niter_base<_Iterator>::iterator_type std::__niter_base","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Iterator __it)","desc":"","params":[{"type":"_Iterator","kind":"","declname":"__it","desc":""}]}]},"__ostream_fill":{"name":"__ostream_fill","kind":"function","type":["void"],"def":"void std::__ostream_fill","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(basic_ostream< _CharT, _Traits > &__out, streamsize __n)","desc":"","params":[{"type":"basic_ostream< _CharT, _Traits > &","kind":"","declname":"__out","desc":""},{"type":"","kind":"","declname":"__n","desc":""}]}]},"__ostream_insert":{"name":"__ostream_insert","kind":"function","type":["basic_ostream< _CharT, _Traits > &"],"def":"basic_ostream<_CharT, _Traits>& std::__ostream_insert","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(basic_ostream< _CharT, _Traits > &__out, const _CharT *__s, streamsize __n)","desc":"","params":[{"type":"basic_ostream< _CharT, _Traits > &","kind":"","declname":"__out","desc":""},{"type":"const _CharT *","kind":"","declname":"__s","desc":""},{"type":"","kind":"","declname":"__n","desc":""}]}]},"__ostream_write":{"name":"__ostream_write","kind":"function","type":["void"],"def":"void std::__ostream_write","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(basic_ostream< _CharT, _Traits > &__out, const _CharT *__s, streamsize __n)","desc":"","params":[{"type":"basic_ostream< _CharT, _Traits > &","kind":"","declname":"__out","desc":""},{"type":"const _CharT *","kind":"","declname":"__s","desc":""},{"type":"","kind":"","declname":"__n","desc":""}]}]},"__partial_sort":{"name":"__partial_sort","kind":"function","type":["void"],"def":"void std::__partial_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__middle","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__partial_sort_copy":{"name":"__partial_sort_copy","kind":"function","type":["_RandomAccessIterator"],"def":"_RandomAccessIterator std::__partial_sort_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__result_first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__result_last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__partition":{"name":"__partition","kind":"function","type":["_BidirectionalIterator"],"def":"_BidirectionalIterator std::__partition","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, bidirectional_iterator_tag)","desc":"This is a helper function...","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""},{"type":"std::bidirectional_iterator_tag","kind":"","desc":""}]}]},"__pop_heap":{"name":"__pop_heap","kind":"function","type":["void"],"def":"void std::__pop_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__prev_permutation":{"name":"__prev_permutation","kind":"function","type":["bool"],"def":"bool std::__prev_permutation","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)","desc":"","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__push_heap":{"name":"__push_heap","kind":"function","type":["void"],"def":"void std::__push_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_Distance","kind":"","declname":"__holeIndex","desc":""},{"type":"_Distance","kind":"","declname":"__topIndex","desc":""},{"type":"_Tp","kind":"","declname":"__value","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__remove_copy_if":{"name":"__remove_copy_if","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__remove_copy_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__remove_if":{"name":"__remove_if","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__remove_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__replace_copy_if":{"name":"__replace_copy_if","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__replace_copy_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""},{"type":"const _Tp &","kind":"","declname":"__new_value","desc":""}]}]},"__reverse":{"name":"__reverse","kind":"function","type":["void"],"def":"void std::__reverse","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__rotate":{"name":"__rotate","kind":"function","type":["void"],"def":"void std::__rotate","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, random_access_iterator_tag)","desc":"This is a helper function for the rotate algorithm.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__middle","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__rotate_adaptive":{"name":"__rotate_adaptive","kind":"function","type":["_BidirectionalIterator1"],"def":"_BidirectionalIterator1 std::__rotate_adaptive","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)","desc":"This is a helper function for the merge routines.","params":[{"type":"_BidirectionalIterator1","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator1","kind":"","declname":"__middle","desc":""},{"type":"_BidirectionalIterator1","kind":"","declname":"__last","desc":""},{"type":"_Distance","kind":"","declname":"__len1","desc":""},{"type":"_Distance","kind":"","declname":"__len2","desc":""},{"type":"_BidirectionalIterator2","kind":"","declname":"__buffer","desc":""},{"type":"_Distance","kind":"","declname":"__buffer_size","desc":""}]}]},"__search":{"name":"__search","kind":"function","type":["_ForwardIterator1"],"def":"_ForwardIterator1 std::__search","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)","desc":"","params":[{"type":"_ForwardIterator1","kind":"","declname":"__first1","desc":""},{"type":"_ForwardIterator1","kind":"","declname":"__last1","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__first2","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__last2","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__predicate","desc":""}]}]},"__search_n":{"name":"__search_n","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__search_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, _UnaryPredicate __unary_pred)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Integer","kind":"","declname":"__count","desc":""},{"type":"_UnaryPredicate","kind":"","declname":"__unary_pred","desc":""}]}]},"__search_n_aux":{"name":"__search_n_aux","kind":"function","type":["_RandomAccessIter"],"def":"_RandomAccessIter std::__search_n_aux","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, _UnaryPredicate __unary_pred, std::random_access_iterator_tag)","desc":"","params":[{"type":"_RandomAccessIter","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIter","kind":"","declname":"__last","desc":""},{"type":"_Integer","kind":"","declname":"__count","desc":""},{"type":"_UnaryPredicate","kind":"","declname":"__unary_pred","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__set_difference":{"name":"__set_difference","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__set_difference","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__set_intersection":{"name":"__set_intersection","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__set_intersection","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__set_symmetric_difference":{"name":"__set_symmetric_difference","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__set_symmetric_difference","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__set_union":{"name":"__set_union","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::__set_union","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__sort":{"name":"__sort","kind":"function","type":["void"],"def":"void std::__sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__sort_heap":{"name":"__sort_heap","kind":"function","type":["void"],"def":"void std::__sort_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__stable_partition":{"name":"__stable_partition","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__stable_partition","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"__stable_partition_adaptive":{"name":"__stable_partition_adaptive","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__stable_partition_adaptive","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)","desc":"This is a helper function... Requires __first != __last and !__pred(__first) and __len == distance(__first, __last).","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""},{"type":"_Distance","kind":"","declname":"__len","desc":""},{"type":"_Pointer","kind":"","declname":"__buffer","desc":""},{"type":"_Distance","kind":"","declname":"__buffer_size","desc":""}]}]},"__stable_sort":{"name":"__stable_sort","kind":"function","type":["void"],"def":"void std::__stable_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__stable_sort_adaptive":{"name":"__stable_sort_adaptive","kind":"function","type":["void"],"def":"void std::__stable_sort_adaptive","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Pointer","kind":"","declname":"__buffer","desc":""},{"type":"_Distance","kind":"","declname":"__buffer_size","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__throw_bad_alloc":{"name":"__throw_bad_alloc","kind":"function","type":["void"],"def":"void std::__throw_bad_alloc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(void) __attribute__((__noreturn__))","desc":"","params":[{"type":"void","kind":"","desc":""}]}]},"__throw_bad_cast":{"name":"__throw_bad_cast","kind":"function","type":["void"],"def":"void std::__throw_bad_cast","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(void) __attribute__((__noreturn__))","desc":"","params":[{"type":"void","kind":"","desc":""}]}]},"__throw_bad_exception":{"name":"__throw_bad_exception","kind":"function","type":["void"],"def":"void std::__throw_bad_exception","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(void) __attribute__((__noreturn__))","desc":"","params":[{"type":"void","kind":"","desc":""}]}]},"__throw_bad_function_call":{"name":"__throw_bad_function_call","kind":"function","type":["void"],"def":"void std::__throw_bad_function_call","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() __attribute__((__noreturn__))","desc":"","params":[]}]},"__throw_bad_typeid":{"name":"__throw_bad_typeid","kind":"function","type":["void"],"def":"void std::__throw_bad_typeid","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(void) __attribute__((__noreturn__))","desc":"","params":[{"type":"void","kind":"","desc":""}]}]},"__throw_bad_weak_ptr":{"name":"__throw_bad_weak_ptr","kind":"function","type":["void"],"def":"void std::__throw_bad_weak_ptr","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]}]},"__throw_domain_error":{"name":"__throw_domain_error","kind":"function","type":["void"],"def":"void std::__throw_domain_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_future_error":{"name":"__throw_future_error","kind":"function","type":["void"],"def":"void std::__throw_future_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(int) __attribute__((__noreturn__))","desc":"","params":[{"type":"int","kind":"","desc":""}]}]},"__throw_invalid_argument":{"name":"__throw_invalid_argument","kind":"function","type":["void"],"def":"void std::__throw_invalid_argument","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_ios_failure":{"name":"__throw_ios_failure","kind":"function","type":["void"],"def":"void std::__throw_ios_failure","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_length_error":{"name":"__throw_length_error","kind":"function","type":["void"],"def":"void std::__throw_length_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_logic_error":{"name":"__throw_logic_error","kind":"function","type":["void"],"def":"void std::__throw_logic_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_out_of_range":{"name":"__throw_out_of_range","kind":"function","type":["void"],"def":"void std::__throw_out_of_range","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_out_of_range_fmt":{"name":"__throw_out_of_range_fmt","kind":"function","type":["void"],"def":"void std::__throw_out_of_range_fmt","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *,...) __attribute__((__noreturn__)) __attribute__((__format__(__printf__","desc":"","params":[{"type":"const char *","kind":"","desc":""},{"type":"...","kind":"","desc":""}]}]},"__throw_overflow_error":{"name":"__throw_overflow_error","kind":"function","type":["void"],"def":"void std::__throw_overflow_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_range_error":{"name":"__throw_range_error","kind":"function","type":["void"],"def":"void std::__throw_range_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_regex_error":{"name":"__throw_regex_error","kind":"function","type":["void"],"def":"void std::__throw_regex_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(regex_constants::error_type __ecode)","desc":"","params":[{"type":"","kind":"","declname":"__ecode","desc":""}]}]},"__throw_runtime_error":{"name":"__throw_runtime_error","kind":"function","type":["void void"],"def":"void void std::__throw_runtime_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_system_error":{"name":"__throw_system_error","kind":"function","type":["void"],"def":"void std::__throw_system_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(int) __attribute__((__noreturn__))","desc":"","params":[{"type":"int","kind":"","desc":""}]}]},"__throw_underflow_error":{"name":"__throw_underflow_error","kind":"function","type":["void"],"def":"void std::__throw_underflow_error","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const char *) __attribute__((__noreturn__))","desc":"","params":[{"type":"const char *","kind":"","desc":""}]}]},"__throw_with_nested":{"name":"__throw_with_nested","kind":"function","type":["void"],"def":"void std::__throw_with_nested","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Ex &&,...) __attribute__((__noreturn__))","desc":"","params":[{"type":"_Ex &&","kind":"","desc":""},{"type":"...","kind":"","desc":""}]}]},"__unguarded_insertion_sort":{"name":"__unguarded_insertion_sort","kind":"function","type":["void"],"def":"void std::__unguarded_insertion_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function for the sort routine.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__unguarded_linear_insert":{"name":"__unguarded_linear_insert","kind":"function","type":["void"],"def":"void std::__unguarded_linear_insert","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function for the sort routine.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__unguarded_partition":{"name":"__unguarded_partition","kind":"function","type":["_RandomAccessIterator"],"def":"_RandomAccessIterator std::__unguarded_partition","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __pivot, _Compare __comp)","desc":"This is a helper function...","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__pivot","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__unguarded_partition_pivot":{"name":"__unguarded_partition_pivot","kind":"function","type":["_RandomAccessIterator"],"def":"_RandomAccessIterator std::__unguarded_partition_pivot","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"This is a helper function...","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__uninitialized_construct_buf":{"name":"__uninitialized_construct_buf","kind":"function","type":["void"],"def":"void std::__uninitialized_construct_buf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Pointer __first, _Pointer __last, _ForwardIterator __seed)","desc":"","params":[{"type":"_Pointer","kind":"","declname":"__first","desc":""},{"type":"_Pointer","kind":"","declname":"__last","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__seed","desc":""}]}]},"__uninitialized_copy_a":{"name":"__uninitialized_copy_a","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_copy_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, allocator< _Tp > &)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"std::allocator","kind":"","operator":"< _Tp > &","desc":""}]}]},"__uninitialized_copy_move":{"name":"__uninitialized_copy_move","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_copy_move","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"_Allocator &","kind":"","declname":"__alloc","desc":""}]}]},"__uninitialized_copy_n":{"name":"__uninitialized_copy_n","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_copy_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, random_access_iterator_tag)","desc":"","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"std::random_access_iterator_tag","kind":"","desc":""}]}]},"__uninitialized_default":{"name":"__uninitialized_default","kind":"function","type":["void"],"def":"void std::__uninitialized_default","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""}]}]},"__uninitialized_default_a":{"name":"__uninitialized_default_a","kind":"function","type":["void"],"def":"void std::__uninitialized_default_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, allocator< _Tp > &)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"std::allocator","kind":"","operator":"< _Tp > &","desc":""}]}]},"__uninitialized_default_n":{"name":"__uninitialized_default_n","kind":"function","type":["void"],"def":"void std::__uninitialized_default_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _Size __n)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""}]}]},"__uninitialized_default_n_a":{"name":"__uninitialized_default_n_a","kind":"function","type":["void"],"def":"void std::__uninitialized_default_n_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _Size __n, allocator< _Tp > &)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"std::allocator","kind":"","operator":"< _Tp > &","desc":""}]}]},"__uninitialized_fill_a":{"name":"__uninitialized_fill_a","kind":"function","type":["void"],"def":"void std::__uninitialized_fill_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, allocator< _Tp2 > &)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__x","desc":""},{"type":"std::allocator","kind":"","operator":"< _Tp2 > &","desc":""}]}]},"__uninitialized_fill_move":{"name":"__uninitialized_fill_move","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_fill_move","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__mid","desc":""},{"type":"const _Tp &","kind":"","declname":"__x","desc":""},{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_Allocator &","kind":"","declname":"__alloc","desc":""}]}]},"__uninitialized_fill_n_a":{"name":"__uninitialized_fill_n_a","kind":"function","type":["void"],"def":"void std::__uninitialized_fill_n_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _Size __n, const _Tp &__x, allocator< _Tp2 > &)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"const _Tp &","kind":"","declname":"__x","desc":""},{"type":"std::allocator","kind":"","operator":"< _Tp2 > &","desc":""}]}]},"__uninitialized_move_a":{"name":"__uninitialized_move_a","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_move_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"_Allocator &","kind":"","declname":"__alloc","desc":""}]}]},"__uninitialized_move_copy":{"name":"__uninitialized_move_copy","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_move_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)","desc":"","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"_Allocator &","kind":"","declname":"__alloc","desc":""}]}]},"__uninitialized_move_fill":{"name":"__uninitialized_move_fill","kind":"function","type":["void"],"def":"void std::__uninitialized_move_fill","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator","kind":"","declname":"__last1","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__first2","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last2","desc":""},{"type":"const _Tp &","kind":"","declname":"__x","desc":""},{"type":"_Allocator &","kind":"","declname":"__alloc","desc":""}]}]},"__uninitialized_move_if_noexcept_a":{"name":"__uninitialized_move_if_noexcept_a","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__uninitialized_move_if_noexcept_a","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"_Allocator &","kind":"","declname":"__alloc","desc":""}]}]},"__unique":{"name":"__unique","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__unique","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":""}]}]},"__unique_copy":{"name":"__unique_copy","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__unique_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, input_iterator_tag, forward_iterator_tag)","desc":"","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":""},{"type":"std::input_iterator_tag","kind":"","desc":""},{"type":"std::forward_iterator_tag","kind":"","desc":""}]}]},"__unmatched_sub":{"name":"__unmatched_sub","kind":"function","type":["std::sub_match"],"def":"const sub_match<_Bi_iter>& std::__unmatched_sub","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]}]},"__upper_bound":{"name":"__upper_bound","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::__upper_bound","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__val","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"__use_alloc":{"name":"__use_alloc","kind":"function","type":["__uses_alloc_impl< _Tp, _Alloc, _Args...>"],"def":"__uses_alloc_impl<_Tp, _Alloc, _Args...> std::__use_alloc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Alloc &__a)","desc":"","params":[{"type":"const _Alloc &","kind":"","declname":"__a","desc":""}]}]},"__valarray_copy":{"name":"__valarray_copy","kind":"function","type":["void"],"def":"void std::__valarray_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __src, size_t __n, _Array< size_t > __i, _Array< _Tp > __dst, _Array< size_t > __j)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__src","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"_Array< _Tp >","kind":"","declname":"__dst","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__j","desc":""}]}]},"__valarray_copy_construct":{"name":"__valarray_copy_construct","kind":"function","type":["void"],"def":"void std::__valarray_copy_construct","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"size_t","kind":"","declname":"__s","desc":""},{"type":"_Array< _Tp >","kind":"","declname":"__b","desc":""}]}]},"__valarray_default_construct":{"name":"__valarray_default_construct","kind":"function","type":["void"],"def":"void std::__valarray_default_construct","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp *__b, _Tp *__e)","desc":"","params":[{"type":"_Tp *","kind":"","declname":"__b","desc":""},{"type":"_Tp *","kind":"","declname":"__e","desc":""}]}]},"__valarray_destroy_elements":{"name":"__valarray_destroy_elements","kind":"function","type":["void"],"def":"void std::__valarray_destroy_elements","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp *__b, _Tp *__e)","desc":"","params":[{"type":"_Tp *","kind":"","declname":"__b","desc":""},{"type":"_Tp *","kind":"","declname":"__e","desc":""}]}]},"__valarray_fill":{"name":"__valarray_fill","kind":"function","type":["void"],"def":"void std::__valarray_fill","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< size_t > __i, size_t __n, const _Tp &__t)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"const _Tp &","kind":"","declname":"__t","desc":""}]}]},"__valarray_fill_construct":{"name":"__valarray_fill_construct","kind":"function","type":["void"],"def":"void std::__valarray_fill_construct","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp *__b, _Tp *__e, const _Tp __t)","desc":"","params":[{"type":"_Tp *","kind":"","declname":"__b","desc":""},{"type":"_Tp *","kind":"","declname":"__e","desc":""},{"type":"const _Tp","kind":"","declname":"__t","desc":""}]}]},"__valarray_get_memory":{"name":"__valarray_get_memory","kind":"function","type":["void *"],"def":"void* std::__valarray_get_memory","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_t __n)","desc":"","params":[{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"__valarray_get_storage":{"name":"__valarray_get_storage","kind":"function","type":["_Tp *__restrict__"],"def":"_Tp* __restrict__ std::__valarray_get_storage","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_t __n)","desc":"","params":[{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"__valarray_max":{"name":"__valarray_max","kind":"function","type":["_Ta::value_type"],"def":"_Ta::value_type std::__valarray_max","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Ta &__a)","desc":"","params":[{"type":"const _Ta &","kind":"","declname":"__a","desc":""}]}]},"__valarray_min":{"name":"__valarray_min","kind":"function","type":["_Ta::value_type"],"def":"_Ta::value_type std::__valarray_min","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Ta &__a)","desc":"","params":[{"type":"const _Ta &","kind":"","declname":"__a","desc":""}]}]},"__valarray_product":{"name":"__valarray_product","kind":"function","type":["_Tp"],"def":"_Tp std::__valarray_product","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Tp *__f, const _Tp *__l)","desc":"","params":[{"type":"const _Tp *","kind":"","declname":"__f","desc":""},{"type":"const _Tp *","kind":"","declname":"__l","desc":""}]}]},"__valarray_release_memory":{"name":"__valarray_release_memory","kind":"function","type":["void"],"def":"void std::__valarray_release_memory","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(void *__p)","desc":"","params":[{"type":"void *","kind":"","declname":"__p","desc":""}]}]},"__valarray_sum":{"name":"__valarray_sum","kind":"function","type":["_Tp"],"def":"_Tp std::__valarray_sum","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Tp *__f, const _Tp *__l)","desc":"","params":[{"type":"const _Tp *","kind":"","declname":"__f","desc":""},{"type":"const _Tp *","kind":"","declname":"__l","desc":""}]}]},"__write":{"name":"__write","kind":"function","type":["_OutIter"],"def":"_OutIter std::__write","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_OutIter __s, const _CharT *__ws, int __len)","desc":"","params":[{"type":"_OutIter","kind":"","declname":"__s","desc":""},{"type":"const _CharT *","kind":"","declname":"__ws","desc":""},{"type":"int","kind":"","declname":"__len","desc":""}]}]},"_Array_augmented___bitwise_and":{"name":"_Array_augmented___bitwise_and","kind":"function","type":["void"],"def":"void std::_Array_augmented___bitwise_and","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"const _Expr< _Dom, _Tp > &","kind":"","declname":"__e","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"_Array_augmented___bitwise_or":{"name":"_Array_augmented___bitwise_or","kind":"function","type":["void"],"def":"void std::_Array_augmented___bitwise_or","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< bool >","kind":"","declname":"__m","desc":""},{"type":"const _Expr< _Dom, _Tp > &","kind":"","declname":"__e","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"_Array_augmented___bitwise_xor":{"name":"_Array_augmented___bitwise_xor","kind":"function","type":["void"],"def":"void std::_Array_augmented___bitwise_xor","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"const _Expr< _Dom, _Tp > &","kind":"","declname":"__e","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"_Array_augmented___divides":{"name":"_Array_augmented___divides","kind":"function","type":["void"],"def":"void std::_Array_augmented___divides","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"const _Expr< _Dom, _Tp > &","kind":"","declname":"__e","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"_Array_augmented___minus":{"name":"_Array_augmented___minus","kind":"function","type":["void"],"def":"void std::_Array_augmented___minus","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"const _Expr< _Dom, _Tp > &","kind":"","declname":"__e","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"_Array_augmented___modulus":{"name":"_Array_augmented___modulus","kind":"function","type":["void"],"def":"void std::_Array_augmented___modulus","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< _Tp >","kind":"","declname":"__b","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"size_t","kind":"","declname":"__s","desc":""}]}]},"_Array_augmented___multiplies":{"name":"_Array_augmented___multiplies","kind":"function","type":["void"],"def":"void std::_Array_augmented___multiplies","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< _Tp >","kind":"","declname":"__b","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"size_t","kind":"","declname":"__s","desc":""}]}]},"_Array_augmented___plus":{"name":"_Array_augmented___plus","kind":"function","type":["void"],"def":"void std::_Array_augmented___plus","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< _Tp >","kind":"","declname":"__b","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"size_t","kind":"","declname":"__s","desc":""}]}]},"_Array_augmented___shift_left":{"name":"_Array_augmented___shift_left","kind":"function","type":["void"],"def":"void std::_Array_augmented___shift_left","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"_Array< size_t >","kind":"","declname":"__i","desc":""},{"type":"const _Expr< _Dom, _Tp > &","kind":"","declname":"__e","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""}]}]},"_Array_augmented___shift_right":{"name":"_Array_augmented___shift_right","kind":"function","type":["void"],"def":"void std::_Array_augmented___shift_right","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Array< _Tp > __a, size_t __n, const _Tp &__t)","desc":"","params":[{"type":"_Array< _Tp >","kind":"","declname":"__a","desc":""},{"type":"size_t","kind":"","declname":"__n","desc":""},{"type":"const _Tp &","kind":"","declname":"__t","desc":""}]}]},"_Construct":{"name":"_Construct","kind":"function","type":["void"],"def":"void std::_Construct","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_T1 *__p, _Args &&...__args)","desc":"","params":[{"type":"_T1 *","kind":"","declname":"__p","desc":""},{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}]},"_Destroy":{"name":"_Destroy","kind":"function","type":["void"],"def":"void std::_Destroy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, allocator< _Tp > &)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"std::allocator","kind":"","operator":"< _Tp > &","desc":""}]}]},"_Fnv_hash_bytes":{"name":"_Fnv_hash_bytes","kind":"function","type":["size_t"],"def":"size_t std::_Fnv_hash_bytes","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const void *__ptr, size_t __len, size_t __seed)","desc":"","params":[{"type":"const void *","kind":"","declname":"__ptr","desc":""},{"type":"size_t","kind":"","declname":"__len","desc":""},{"type":"size_t","kind":"","declname":"__seed","desc":""}]}]},"_Hash_bytes":{"name":"_Hash_bytes","kind":"function","type":["size_t"],"def":"size_t std::_Hash_bytes","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const void *__ptr, size_t __len, size_t __seed)","desc":"","params":[{"type":"const void *","kind":"","declname":"__ptr","desc":""},{"type":"size_t","kind":"","declname":"__len","desc":""},{"type":"size_t","kind":"","declname":"__seed","desc":""}]}]},"_Rb_tree_black_count":{"name":"_Rb_tree_black_count","kind":"function","type":["unsigned int"],"def":"unsigned int std::_Rb_tree_black_count","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Rb_tree_node_base *__node, const _Rb_tree_node_base *__root)","desc":"","params":[{"type":"const _Rb_tree_node_base *","kind":"","declname":"__node","desc":""},{"type":"const _Rb_tree_node_base *","kind":"","declname":"__root","desc":""}]}]},"_Rb_tree_decrement":{"name":"_Rb_tree_decrement","kind":"function","type":["const _Rb_tree_node_base *"],"def":"const _Rb_tree_node_base* std::_Rb_tree_decrement","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Rb_tree_node_base *__x)","desc":"","params":[{"type":"const _Rb_tree_node_base *","kind":"","declname":"__x","desc":""}]}]},"_Rb_tree_increment":{"name":"_Rb_tree_increment","kind":"function","type":["const _Rb_tree_node_base *"],"def":"const _Rb_tree_node_base* std::_Rb_tree_increment","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Rb_tree_node_base *__x)","desc":"","params":[{"type":"const _Rb_tree_node_base *","kind":"","declname":"__x","desc":""}]}]},"_Rb_tree_insert_and_rebalance":{"name":"_Rb_tree_insert_and_rebalance","kind":"function","type":["void"],"def":"void std::_Rb_tree_insert_and_rebalance","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const bool __insert_left, _Rb_tree_node_base *__x, _Rb_tree_node_base *__p, _Rb_tree_node_base &__header)","desc":"","params":[{"type":"const bool","kind":"","declname":"__insert_left","desc":""},{"type":"_Rb_tree_node_base *","kind":"","declname":"__x","desc":""},{"type":"_Rb_tree_node_base *","kind":"","declname":"__p","desc":""},{"type":"_Rb_tree_node_base &","kind":"","declname":"__header","desc":""}]}]},"_Rb_tree_rebalance_for_erase":{"name":"_Rb_tree_rebalance_for_erase","kind":"function","type":["_Rb_tree_node_base *"],"def":"_Rb_tree_node_base* std::_Rb_tree_rebalance_for_erase","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Rb_tree_node_base *const __z, _Rb_tree_node_base &__header)","desc":"","params":[{"type":"_Rb_tree_node_base *const","kind":"","declname":"__z","desc":""},{"type":"_Rb_tree_node_base &","kind":"","declname":"__header","desc":""}]}]},"abs":{"name":"abs","kind":"function","type":["_Expr< _UnClos< _Abs, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Abs , _ValArray, _Tp>, _Tp> std::abs","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"accumulate":{"name":"accumulate","kind":"function","type":["_Tp"],"def":"_Tp std::accumulate","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)","desc":"Accumulate values in a range with operation.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_Tp","kind":"","declname":"__init","desc":""},{"type":"_BinaryOperation","kind":"","declname":"__binary_op","desc":""}]}]},"acos":{"name":"acos","kind":"function","type":["_Expr< _UnClos< _Acos, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Acos , _ValArray, _Tp>, _Tp> std::acos","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"addressof":{"name":"addressof","kind":"function","type":["_Tp *"],"def":"_Tp* std::addressof","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp &__r) noexcept","desc":"Returns the actual address of the object or function referenced by r, even in the presence of an overloaded operator&.","params":[{"type":"_Tp &","kind":"","declname":"__r","desc":"Reference to an object or function."}]}]},"adjacent_difference":{"name":"adjacent_difference","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::adjacent_difference","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)","desc":"Return differences between adjacent values.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_BinaryOperation","kind":"","declname":"__binary_op","desc":""}]}]},"adjacent_find":{"name":"adjacent_find","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::adjacent_find","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)","desc":"Find two adjacent values in a sequence using a predicate.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":"A binary predicate."}]}]},"advance":{"name":"advance","kind":"function","type":["void"],"def":"void std::advance","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator &__i, _Distance __n)","desc":"A generalization of pointer arithmetic.","params":[{"type":"_InputIterator &","kind":"","declname":"__i","desc":""},{"type":"_Distance","kind":"","declname":"__n","desc":""}]}]},"all_of":{"name":"all_of","kind":"function","type":["bool"],"def":"bool std::all_of","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Checks that a predicate is true for all the elements of a sequence.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"allocate_shared":{"name":"allocate_shared","kind":"function","type":["std::shared_ptr"],"def":"shared_ptr<_Tp> std::allocate_shared","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Alloc &__a, _Args &&...__args)","desc":"Create an object that is owned by a shared_ptr.","params":[{"type":"const _Alloc &","kind":"","declname":"__a","desc":""},{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}]},"any_of":{"name":"any_of","kind":"function","type":["bool"],"def":"bool std::any_of","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Checks that a predicate is false for at least an element of a sequence.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"asin":{"name":"asin","kind":"function","type":["_Expr< _UnClos< _Asin, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Asin , _ValArray, _Tp>, _Tp> std::asin","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"atan":{"name":"atan","kind":"function","type":["_Expr< _UnClos< _Atan, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Atan , _ValArray, _Tp>, _Tp> std::atan","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"atan2":{"name":"atan2","kind":"function","type":["_Expr< _BinClos< _Atan2, _Constant, _ValArray, _Tp, _Tp >, _Tp >"],"def":"_Expr<_BinClos< _Atan2 , _Constant, _ValArray, _Tp, _Tp>, _Tp> std::atan2","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Tp &__t, const valarray< _Tp > &__v)","desc":"","params":[{"type":"const _Tp &","kind":"","declname":"__t","desc":""},{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"back_inserter":{"name":"back_inserter","kind":"function","type":["std::back_insert_iterator"],"def":"back_insert_iterator<_Container> std::back_inserter","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Container &__x)","desc":"","params":[{"type":"_Container &","kind":"","declname":"__x","desc":"A container of arbitrary type."}]}]},"begin":{"name":"begin","kind":"function","type":["_Tp *"],"def":"_Tp* std::begin","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp(&__arr)[_Nm])","desc":"Return an iterator pointing to the first element of the array.","params":[{"type":"_Tp(&)","kind":"","declname":"__arr","desc":"Array."}]}]},"binary_search":{"name":"binary_search","kind":"function","type":["bool"],"def":"bool std::binary_search","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)","desc":"Determines whether an element exists in a range.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__val","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"bind1st":{"name":"bind1st","kind":"function","type":["std::binder1st"],"def":"binder1st<_Operation> std::bind1st","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Operation &__fn, const _Tp &__x)","desc":"One of the                    \n                        \n.","params":[{"type":"const _Operation &","kind":"","declname":"__fn","desc":""},{"type":"const _Tp &","kind":"","declname":"__x","desc":""}]}]},"bind2nd":{"name":"bind2nd","kind":"function","type":["std::binder2nd"],"def":"binder2nd<_Operation> std::bind2nd","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Operation &__fn, const _Tp &__x)","desc":"One of the                    \n                        \n.","params":[{"type":"const _Operation &","kind":"","declname":"__fn","desc":""},{"type":"const _Tp &","kind":"","declname":"__x","desc":""}]}]},"boolalpha":{"name":"boolalpha","kind":"function","type":["std::ios_base"],"def":"ios_base& std::boolalpha","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::boolalpha).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"const_pointer_cast":{"name":"const_pointer_cast","kind":"function","type":["__shared_ptr< _Tp, _Lp >"],"def":"__shared_ptr<_Tp, _Lp> std::const_pointer_cast","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const __shared_ptr< _Tp1, _Lp > &__r) noexcept","desc":"const_pointer_cast","params":[{"type":"const __shared_ptr< _Tp1, _Lp > &","kind":"","declname":"__r","desc":""}]}]},"copy":{"name":"copy","kind":"function","type":["_OI"],"def":"_OI std::copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II __first, _II __last, _OI __result)","desc":"Copies the range [first,last) into result.","params":[{"type":"_II","kind":"","declname":"__first","desc":""},{"type":"_II","kind":"","declname":"__last","desc":""},{"type":"_OI","kind":"","declname":"__result","desc":""}]}]},"copy_backward":{"name":"copy_backward","kind":"function","type":["_BI2"],"def":"_BI2 std::copy_backward","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BI1 __first, _BI1 __last, _BI2 __result)","desc":"Copies the range [first,last) into result.","params":[{"type":"_BI1","kind":"","declname":"__first","desc":""},{"type":"_BI1","kind":"","declname":"__last","desc":""},{"type":"_BI2","kind":"","declname":"__result","desc":""}]}]},"copy_exception":{"name":"copy_exception","kind":"function","type":["exception_ptr"],"def":"exception_ptr std::copy_exception","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Ex __ex) noexcept 1","desc":"Obtain an exception_ptr pointing to a copy of the supplied object. This function is deprecated, use std::make_exception_ptr instead.","params":[{"type":"_Ex","kind":"","declname":"__ex","desc":""}]}]},"copy_if":{"name":"copy_if","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::copy_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)","desc":"Copy the elements of a sequence for which a predicate is true.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"copy_n":{"name":"copy_n","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::copy_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _Size __n, _OutputIterator __result)","desc":"Copies the range [first,first+n) into [result,result+n).","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_Size","kind":"","declname":"__n","desc":"The number of elements to copy."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":"An output iterator."}]}]},"cos":{"name":"cos","kind":"function","type":["_Expr< _UnClos< _Cos, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Cos , _ValArray, _Tp>, _Tp> std::cos","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"cosh":{"name":"cosh","kind":"function","type":["_Expr< _UnClos< _Cosh, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Cosh , _ValArray, _Tp>, _Tp> std::cosh","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"count":{"name":"count","kind":"function","type":["iterator_traits< _InputIterator >::difference_type"],"def":"iterator_traits<_InputIterator>::difference_type std::count","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const _Tp &__value)","desc":"Count the number of copies of a value in a sequence.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"const _Tp &","kind":"","declname":"__value","desc":"The value to be counted."}]}]},"count_if":{"name":"count_if","kind":"function","type":["iterator_traits< _InputIterator >::difference_type"],"def":"iterator_traits<_InputIterator>::difference_type std::count_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Count the elements of a sequence for which a predicate is true.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"current_exception":{"name":"current_exception","kind":"function","type":["exception_ptr"],"def":"exception_ptr std::current_exception","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]}]},"dec":{"name":"dec","kind":"function","type":["std::ios_base"],"def":"ios_base& std::dec","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::dec, ios_base::basefield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"distance":{"name":"distance","kind":"function","type":["iterator_traits< _InputIterator >::difference_type"],"def":"iterator_traits<_InputIterator>::difference_type std::distance","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last)","desc":"A generalization of pointer arithmetic.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""}]}]},"dynamic_pointer_cast":{"name":"dynamic_pointer_cast","kind":"function","type":["__shared_ptr< _Tp, _Lp >"],"def":"__shared_ptr<_Tp, _Lp> std::dynamic_pointer_cast","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const __shared_ptr< _Tp1, _Lp > &__r) noexcept","desc":"dynamic_pointer_cast","params":[{"type":"const __shared_ptr< _Tp1, _Lp > &","kind":"","declname":"__r","desc":""}]}]},"end":{"name":"end","kind":"function","type":["_Tp *"],"def":"_Tp* std::end","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp(&__arr)[_Nm])","desc":"Return an iterator pointing to one past the last element of the array.","params":[{"type":"_Tp(&)","kind":"","declname":"__arr","desc":"Array."}]}]},"equal":{"name":"equal","kind":"function","type":["bool"],"def":"bool std::equal","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II1 __first1, _II1 __last1, _II2 __first2)","desc":"Tests a range for element-wise equality.","params":[{"type":"_II1","kind":"","declname":"__first1","desc":"An input iterator."},{"type":"_II1","kind":"","declname":"__last1","desc":"An input iterator."},{"type":"_II2","kind":"","declname":"__first2","desc":"An input iterator."}]}]},"equal_range":{"name":"equal_range","kind":"function","type":["std::pair"],"def":"pair<_ForwardIterator, _ForwardIterator> std::equal_range","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)","desc":"Finds the largest subrange in which                    \n                        \n could be inserted at any place in it without changing the ordering.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"const _Tp &","kind":"","declname":"__val","desc":"The search term."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A functor to use for comparisons."}]}]},"exp":{"name":"exp","kind":"function","type":["_Expr< _UnClos< _Exp, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Exp , _ValArray, _Tp>, _Tp> std::exp","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"fill":{"name":"fill","kind":"function","type":["void"],"def":"void std::fill","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)","desc":"Fills the range [first,last) with copies of value.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"const _Tp &","kind":"","declname":"__value","desc":"A reference-to-const of arbitrary type."}]}]},"fill_n":{"name":"fill_n","kind":"function","type":["_OI"],"def":"_OI std::fill_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_OI __first, _Size __n, const _Tp &__value)","desc":"Fills the range [first,first+n) with copies of value.","params":[{"type":"_OI","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"const _Tp &","kind":"","declname":"__value","desc":""}]}]},"find":{"name":"find","kind":"function","type":["_InputIterator"],"def":"_InputIterator std::find","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const _Tp &__val)","desc":"Find the first occurrence of a value in a sequence.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"const _Tp &","kind":"","declname":"__val","desc":"The value to find."}]}]},"find_end":{"name":"find_end","kind":"function","type":["_ForwardIterator1"],"def":"_ForwardIterator1 std::find_end","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)","desc":"Find last matching subsequence in a sequence using a predicate.","params":[{"type":"_ForwardIterator1","kind":"","declname":"__first1","desc":""},{"type":"_ForwardIterator1","kind":"","declname":"__last1","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__first2","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__last2","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__comp","desc":""}]}]},"find_first_of":{"name":"find_first_of","kind":"function","type":["_InputIterator"],"def":"_InputIterator std::find_first_of","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)","desc":"Find element from a set in a sequence using a predicate.","params":[{"type":"_InputIterator","kind":"","declname":"__first1","desc":"Start of range to search."},{"type":"_InputIterator","kind":"","declname":"__last1","desc":"End of range to search."},{"type":"_ForwardIterator","kind":"","declname":"__first2","desc":"Start of match candidates."},{"type":"_ForwardIterator","kind":"","declname":"__last2","desc":"End of match candidates."},{"type":"_BinaryPredicate","kind":"","declname":"__comp","desc":"Predicate to use."}]}]},"find_if":{"name":"find_if","kind":"function","type":["_InputIterator"],"def":"_InputIterator std::find_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Find the first element in a sequence for which a predicate is true.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"find_if_not":{"name":"find_if_not","kind":"function","type":["_InputIterator"],"def":"_InputIterator std::find_if_not","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Find the first element in a sequence for which a predicate is false.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"fixed":{"name":"fixed","kind":"function","type":["std::ios_base"],"def":"ios_base& std::fixed","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::fixed, ios_base::floatfield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"for_each":{"name":"for_each","kind":"function","type":["_Function"],"def":"_Function std::for_each","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Function __f)","desc":"Apply a function to every element of a sequence.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Function","kind":"","declname":"__f","desc":"A unary function object."}]}]},"forward":{"name":"forward","kind":"function","type":["constexpr _Tp &&"],"def":"constexpr _Tp&& std::forward","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(typename std::remove_reference< _Tp >::type &&__t) noexcept","desc":"Forward an rvalue.","params":[{"type":"typename std::remove_reference< _Tp >::type &&","kind":"","declname":"__t","desc":""}]}]},"front_inserter":{"name":"front_inserter","kind":"function","type":["std::front_insert_iterator"],"def":"front_insert_iterator<_Container> std::front_inserter","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Container &__x)","desc":"","params":[{"type":"_Container &","kind":"","declname":"__x","desc":"A container of arbitrary type."}]}]},"generate":{"name":"generate","kind":"function","type":["void"],"def":"void std::generate","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)","desc":"Assign the result of a function object to each value in a sequence.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_Generator","kind":"","declname":"__gen","desc":"A function object taking no arguments and returning std::iterator_traits<_ForwardIterator>::value_type"}]}]},"generate_canonical":{"name":"generate_canonical","kind":"function","type":["_RealType"],"def":"_RealType std::generate_canonical","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_UniformRandomNumberGenerator &__g)","desc":"A function template for converting the output of a (integral) uniform random number generator to a floatng point result in the range [0-1).","params":[{"type":"_UniformRandomNumberGenerator &","kind":"","declname":"__g","desc":""}]}]},"generate_n":{"name":"generate_n","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::generate_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_OutputIterator __first, _Size __n, _Generator __gen)","desc":"Assign the result of a function object to each value in a sequence.","params":[{"type":"_OutputIterator","kind":"","declname":"__first","desc":""},{"type":"_Size","kind":"","declname":"__n","desc":""},{"type":"_Generator","kind":"","declname":"__gen","desc":""}]}]},"get_deleter":{"name":"get_deleter","kind":"function","type":["_Del *"],"def":"_Del* std::get_deleter","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const __shared_ptr< _Tp, _Lp > &__p) noexcept","desc":"20.7.2.2.10 shared_ptr get_deleter","params":[{"type":"const __shared_ptr< _Tp, _Lp > &","kind":"","declname":"__p","desc":""}]}]},"get_temporary_buffer":{"name":"get_temporary_buffer","kind":"function","type":["std::pair"],"def":"pair<_Tp*, ptrdiff_t> std::get_temporary_buffer","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ptrdiff_t __len) noexcept","desc":"Allocates a temporary buffer.","params":[{"type":"ptrdiff_t","kind":"","declname":"__len","desc":""}]}]},"getline":{"name":"getline","kind":"function","type":["basic_istream< wchar_t > &"],"def":"basic_istream<wchar_t>& std::getline","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(basic_istream< wchar_t > &__in, basic_string< wchar_t > &__str, wchar_t __delim)","desc":"","params":[{"type":"basic_istream< wchar_t > &","kind":"","declname":"__in","desc":""},{"type":"std::basic_string","kind":"","operator":"< wchar_t > &","declname":"__str","desc":""},{"type":"wchar_t","kind":"","declname":"__delim","desc":""}]}]},"has_facet":{"name":"has_facet","kind":"function","type":["bool"],"def":"bool std::has_facet","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const locale &)","desc":"","params":[{"type":"std::locale","kind":"","operator":"const                \n                        \n &","desc":""}]}]},"hex":{"name":"hex","kind":"function","type":["std::ios_base"],"def":"ios_base& std::hex","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::hex, ios_base::basefield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"includes":{"name":"includes","kind":"function","type":["bool"],"def":"bool std::includes","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)","desc":"Determines whether all elements of a sequence exists in a range using comparison.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":"Start of search range."},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":"End of search range."},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":"Start of sequence"},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":"End of sequence."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison function to use."}]}]},"inner_product":{"name":"inner_product","kind":"function","type":["_Tp"],"def":"_Tp std::inner_product","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)","desc":"Compute inner product of two ranges.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_Tp","kind":"","declname":"__init","desc":""},{"type":"_BinaryOperation1","kind":"","declname":"__binary_op1","desc":""},{"type":"_BinaryOperation2","kind":"","declname":"__binary_op2","desc":""}]}]},"inplace_merge":{"name":"inplace_merge","kind":"function","type":["void"],"def":"void std::inplace_merge","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)","desc":"Merges two sorted ranges in place.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__middle","desc":""},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"inserter":{"name":"inserter","kind":"function","type":["std::insert_iterator"],"def":"insert_iterator<_Container> std::inserter","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Container &__x, _Iterator __i)","desc":"","params":[{"type":"_Container &","kind":"","declname":"__x","desc":"A container of arbitrary type."},{"type":"_Iterator","kind":"","declname":"__i","desc":""}]}]},"internal":{"name":"internal","kind":"function","type":["std::ios_base"],"def":"ios_base& std::internal","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::internal, ios_base::adjustfield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"iota":{"name":"iota","kind":"function","type":["void"],"def":"void std::iota","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)","desc":"Create a range of sequentially increasing values.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Tp","kind":"","declname":"__value","desc":""}]}]},"is_heap":{"name":"is_heap","kind":"function","type":["bool"],"def":"bool std::is_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"Determines whether a range is a heap using comparison functor.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison functor to use."}]}]},"is_heap_until":{"name":"is_heap_until","kind":"function","type":["_RandomAccessIterator"],"def":"_RandomAccessIterator std::is_heap_until","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"Search the end of a heap using comparison functor.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison functor to use."}]}]},"is_partitioned":{"name":"is_partitioned","kind":"function","type":["bool"],"def":"bool std::is_partitioned","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Checks whether the sequence is partitioned.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"is_permutation":{"name":"is_permutation","kind":"function","type":["bool"],"def":"bool std::is_permutation","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)","desc":"Checks whether a permutation of the second sequence is equal to the first sequence.","params":[{"type":"_ForwardIterator1","kind":"","declname":"__first1","desc":"Start of first range."},{"type":"_ForwardIterator1","kind":"","declname":"__last1","desc":"End of first range."},{"type":"_ForwardIterator2","kind":"","declname":"__first2","desc":"Start of second range."},{"type":"_BinaryPredicate","kind":"","declname":"__pred","desc":"A binary predicate."}]}]},"is_sorted":{"name":"is_sorted","kind":"function","type":["bool"],"def":"bool std::is_sorted","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"Determines whether the elements of a sequence are sorted according to a comparison functor.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"is_sorted_until":{"name":"is_sorted_until","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::is_sorted_until","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"Determines the end of a sorted sequence using comparison functor.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"isalnum":{"name":"isalnum","kind":"function","type":["bool"],"def":"bool std::isalnum","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::alnum, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isalpha":{"name":"isalpha","kind":"function","type":["bool"],"def":"bool std::isalpha","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::alpha, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"iscntrl":{"name":"iscntrl","kind":"function","type":["bool"],"def":"bool std::iscntrl","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::cntrl, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isdigit":{"name":"isdigit","kind":"function","type":["bool"],"def":"bool std::isdigit","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::digit, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isgraph":{"name":"isgraph","kind":"function","type":["bool"],"def":"bool std::isgraph","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::graph, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"islower":{"name":"islower","kind":"function","type":["bool"],"def":"bool std::islower","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::lower, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isprint":{"name":"isprint","kind":"function","type":["bool"],"def":"bool std::isprint","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::print, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"ispunct":{"name":"ispunct","kind":"function","type":["bool"],"def":"bool std::ispunct","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::punct, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isspace":{"name":"isspace","kind":"function","type":["bool"],"def":"bool std::isspace","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::space, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isupper":{"name":"isupper","kind":"function","type":["bool"],"def":"bool std::isupper","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::upper, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"isxdigit":{"name":"isxdigit","kind":"function","type":["bool"],"def":"bool std::isxdigit","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.is(ctype_base::xdigit, __c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"iter_swap":{"name":"iter_swap","kind":"function","type":["void"],"def":"void std::iter_swap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_FIter1, _FIter2)","desc":"","params":[{"type":"_FIter1","kind":"","desc":""},{"type":"_FIter2","kind":"","desc":""}]}]},"kill_dependency":{"name":"kill_dependency","kind":"function","type":["_Tp"],"def":"_Tp std::kill_dependency","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp __y) noexcept","desc":"kill_dependency","params":[{"type":"_Tp","kind":"","declname":"__y","desc":""}]}]},"left":{"name":"left","kind":"function","type":["std::ios_base"],"def":"ios_base& std::left","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::left, ios_base::adjustfield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"lexicographical_compare":{"name":"lexicographical_compare","kind":"function","type":["bool"],"def":"bool std::lexicographical_compare","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)","desc":"Performs                    \n                        \n comparison on ranges.","params":[{"type":"_II1","kind":"","declname":"__first1","desc":"An input iterator."},{"type":"_II1","kind":"","declname":"__last1","desc":"An input iterator."},{"type":"_II2","kind":"","declname":"__first2","desc":"An input iterator."},{"type":"_II2","kind":"","declname":"__last2","desc":"An input iterator."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A                                    \n                                        \n."}]}]},"log":{"name":"log","kind":"function","type":["_Expr< _UnClos< _Log, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Log , _ValArray, _Tp>, _Tp> std::log","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"log10":{"name":"log10","kind":"function","type":["_Expr< _UnClos< _Log10, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Log10 , _ValArray, _Tp>, _Tp> std::log10","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"lower_bound":{"name":"lower_bound","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::lower_bound","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)","desc":"Finds the first position in which                    \n                        \n could be inserted without changing the ordering.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"const _Tp &","kind":"","declname":"__val","desc":"The search term."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A functor to use for comparisons."}]}]},"make_exception_ptr":{"name":"make_exception_ptr","kind":"function","type":["exception_ptr"],"def":"exception_ptr std::make_exception_ptr","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Ex __ex) noexcept","desc":"Obtain an exception_ptr pointing to a copy of the supplied object.","params":[{"type":"_Ex","kind":"","declname":"__ex","desc":""}]}]},"make_heap":{"name":"make_heap","kind":"function","type":["void"],"def":"void std::make_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"Construct a heap over a range using comparison functor.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"Start of heap."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"End of heap."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison functor to use."}]}]},"make_move_iterator":{"name":"make_move_iterator","kind":"function","type":["std::move_iterator"],"def":"move_iterator<_Iterator> std::make_move_iterator","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Iterator __i)","desc":"","params":[{"type":"_Iterator","kind":"","declname":"__i","desc":""}]}]},"make_pair":{"name":"make_pair","kind":"function","type":["std::pair"],"def":"constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> std::make_pair","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_T1 &&__x, _T2 &&__y)","desc":"A convenience wrapper for creating a pair from two objects.","params":[{"type":"_T1 &&","kind":"","declname":"__x","desc":"The first object."},{"type":"_T2 &&","kind":"","declname":"__y","desc":"The second object."}]}]},"make_shared":{"name":"make_shared","kind":"function","type":["std::shared_ptr"],"def":"shared_ptr<_Tp> std::make_shared","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"Create an object that is owned by a shared_ptr.","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}]},"max":{"name":"max","kind":"function","type":["_Tp"],"def":"_Tp std::max","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< _Tp >, _Compare)","desc":"","params":[{"type":"initializer_list< _Tp >","kind":"","desc":""},{"type":"_Compare","kind":"","desc":""}]}]},"max_element":{"name":"max_element","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::max_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"Return the maximum element in a range using comparison functor.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison functor."}]}]},"mem_fun":{"name":"mem_fun","kind":"function","type":["std::const_mem_fun1_t"],"def":"const_mem_fun1_t<_Ret, _Tp, _Arg> std::mem_fun","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Ret(_Tp::*__f)(_Arg) const)","desc":"","params":[{"type":"_Ret(_Tp::*)(_Arg) const","kind":"","declname":"__f","desc":""}]}]},"mem_fun_ref":{"name":"mem_fun_ref","kind":"function","type":["std::const_mem_fun1_ref_t"],"def":"const_mem_fun1_ref_t<_Ret, _Tp, _Arg> std::mem_fun_ref","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Ret(_Tp::*__f)(_Arg) const)","desc":"","params":[{"type":"_Ret(_Tp::*)(_Arg) const","kind":"","declname":"__f","desc":""}]}]},"merge":{"name":"merge","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::merge","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"Merges two sorted ranges.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"min":{"name":"min","kind":"function","type":["_Tp"],"def":"_Tp std::min","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< _Tp >, _Compare)","desc":"","params":[{"type":"initializer_list< _Tp >","kind":"","desc":""},{"type":"_Compare","kind":"","desc":""}]}]},"min_element":{"name":"min_element","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::min_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"Return the minimum element in a range using comparison functor.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison functor."}]}]},"minmax":{"name":"minmax","kind":"function","type":["std::pair"],"def":"pair< _Tp, _Tp > std::minmax","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< _Tp >, _Compare)","desc":"","params":[{"type":"initializer_list< _Tp >","kind":"","desc":""},{"type":"_Compare","kind":"","desc":""}]}]},"minmax_element":{"name":"minmax_element","kind":"function","type":["std::pair"],"def":"pair<_ForwardIterator, _ForwardIterator> std::minmax_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)","desc":"Return a pair of iterators pointing to the minimum and maximum elements in a range.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"Comparison functor."}]}]},"mismatch":{"name":"mismatch","kind":"function","type":["std::pair"],"def":"pair<_InputIterator1, _InputIterator2> std::mismatch","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)","desc":"Finds the places in ranges which don't match.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":"An input iterator."},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":"An input iterator."},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":"An input iterator."},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":"A binary predicate                                    \n                                        \n."}]}]},"move":{"name":"move","kind":"function","type":["_OI"],"def":"_OI std::move","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_II __first, _II __last, _OI __result)","desc":"Moves the range [first,last) into result.","params":[{"type":"_II","kind":"","declname":"__first","desc":""},{"type":"_II","kind":"","declname":"__last","desc":""},{"type":"_OI","kind":"","declname":"__result","desc":""}]}]},"move_backward":{"name":"move_backward","kind":"function","type":["_BI2"],"def":"_BI2 std::move_backward","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BI1 __first, _BI1 __last, _BI2 __result)","desc":"Moves the range [first,last) into result.","params":[{"type":"_BI1","kind":"","declname":"__first","desc":""},{"type":"_BI1","kind":"","declname":"__last","desc":""},{"type":"_BI2","kind":"","declname":"__result","desc":""}]}]},"move_if_noexcept":{"name":"move_if_noexcept","kind":"function","type":["constexpr conditional< __move_if_noexcept_cond< _Tp >::value, const _Tp &, _Tp && >::type"],"def":"constexpr conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type std::move_if_noexcept","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp &__x) noexcept","desc":"Conditionally convert a value to an rvalue.","params":[{"type":"_Tp &","kind":"","declname":"__x","desc":"A thing of arbitrary type."}]}]},"next":{"name":"next","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::next","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __x, typename iterator_traits< _ForwardIterator >::difference_type __n=1)","desc":"","params":[{"type":"_ForwardIterator","kind":"","declname":"__x","desc":""},{"type":"typename iterator_traits< _ForwardIterator >::difference_type","kind":"","declname":"__n","desc":""}]}]},"next_permutation":{"name":"next_permutation","kind":"function","type":["bool"],"def":"bool std::next_permutation","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)","desc":"Permute range into the next                    \n                        \n ordering using comparison functor.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"noboolalpha":{"name":"noboolalpha","kind":"function","type":["std::ios_base"],"def":"ios_base& std::noboolalpha","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::boolalpha).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"none_of":{"name":"none_of","kind":"function","type":["bool"],"def":"bool std::none_of","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _Predicate __pred)","desc":"Checks that a predicate is false for all the elements of a sequence.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"noshowbase":{"name":"noshowbase","kind":"function","type":["std::ios_base"],"def":"ios_base& std::noshowbase","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::showbase).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"noshowpoint":{"name":"noshowpoint","kind":"function","type":["std::ios_base"],"def":"ios_base& std::noshowpoint","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::showpoint).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"noshowpos":{"name":"noshowpos","kind":"function","type":["std::ios_base"],"def":"ios_base& std::noshowpos","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::showpos).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"noskipws":{"name":"noskipws","kind":"function","type":["std::ios_base"],"def":"ios_base& std::noskipws","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::skipws).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"not1":{"name":"not1","kind":"function","type":["std::unary_negate"],"def":"unary_negate<_Predicate> std::not1","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Predicate &__pred)","desc":"One of the                    \n                        \n.","params":[{"type":"const _Predicate &","kind":"","declname":"__pred","desc":""}]}]},"not2":{"name":"not2","kind":"function","type":["std::binary_negate"],"def":"binary_negate<_Predicate> std::not2","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Predicate &__pred)","desc":"One of the                    \n                        \n.","params":[{"type":"const _Predicate &","kind":"","declname":"__pred","desc":""}]}]},"nounitbuf":{"name":"nounitbuf","kind":"function","type":["std::ios_base"],"def":"ios_base& std::nounitbuf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::unitbuf).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"nouppercase":{"name":"nouppercase","kind":"function","type":["std::ios_base"],"def":"ios_base& std::nouppercase","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.unsetf(ios_base::uppercase).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"nth_element":{"name":"nth_element","kind":"function","type":["void"],"def":"void std::nth_element","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)","desc":"Sort a sequence just enough to find a particular position using a predicate for comparison.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__nth","desc":"Another iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"oct":{"name":"oct","kind":"function","type":["std::ios_base"],"def":"ios_base& std::oct","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::oct, ios_base::basefield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"partial_sort":{"name":"partial_sort","kind":"function","type":["void"],"def":"void std::partial_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)","desc":"Sort the smallest elements of a sequence using a predicate for comparison.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__middle","desc":"Another iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"partial_sort_copy":{"name":"partial_sort_copy","kind":"function","type":["_RandomAccessIterator"],"def":"_RandomAccessIterator std::partial_sort_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)","desc":"Copy the smallest elements of a sequence using a predicate for comparison.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"Another input iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__result_first","desc":"A random-access iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__result_last","desc":"Another random-access iterator."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"partial_sum":{"name":"partial_sum","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::partial_sum","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)","desc":"Return list of partial sums.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_BinaryOperation","kind":"","declname":"__binary_op","desc":""}]}]},"partition":{"name":"partition","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::partition","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)","desc":"Move elements for which a predicate is true to the beginning of a sequence.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate functor."}]}]},"partition_copy":{"name":"partition_copy","kind":"function","type":["std::pair"],"def":"pair<_OutputIterator1, _OutputIterator2> std::partition_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)","desc":"Copy the elements of a sequence to separate output sequences depending on the truth value of a predicate.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_OutputIterator1","kind":"","declname":"__out_true","desc":"An output iterator."},{"type":"_OutputIterator2","kind":"","declname":"__out_false","desc":"An output iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"partition_point":{"name":"partition_point","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::partition_point","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)","desc":"Find the partition point of a partitioned range.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."}]}]},"pop_heap":{"name":"pop_heap","kind":"function","type":["void"],"def":"void std::pop_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RAIter, _RAIter, _Compare)","desc":"","params":[{"type":"_RAIter","kind":"","desc":""},{"type":"_RAIter","kind":"","desc":""},{"type":"_Compare","kind":"","desc":""}]}]},"pow":{"name":"pow","kind":"function","type":["_Expr< _BinClos< _Pow, _ValArray, _ValArray, _Tp, _Tp >, _Tp >"],"def":"_Expr<_BinClos< _Pow , _ValArray, _ValArray, _Tp, _Tp>, _Tp> std::pow","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v, const valarray< _Tp > &__w)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""},{"type":"const valarray< _Tp > &","kind":"","declname":"__w","desc":""}]}]},"prev":{"name":"prev","kind":"function","type":["_BidirectionalIterator"],"def":"_BidirectionalIterator std::prev","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __x, typename iterator_traits< _BidirectionalIterator >::difference_type __n=1)","desc":"","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__x","desc":""},{"type":"typename iterator_traits< _BidirectionalIterator >::difference_type","kind":"","declname":"__n","desc":""}]}]},"prev_permutation":{"name":"prev_permutation","kind":"function","type":["bool"],"def":"bool std::prev_permutation","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)","desc":"Permute range into the previous                    \n                        \n ordering using comparison functor.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":"Start of range."},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":"End of range."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A comparison functor."}]}]},"ptr_fun":{"name":"ptr_fun","kind":"function","type":["std::pointer_to_binary_function"],"def":"pointer_to_binary_function<_Arg1, _Arg2, _Result> std::ptr_fun","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Result(*__x)(_Arg1, _Arg2))","desc":"One of the                    \n                        \n.","params":[{"type":"_Result(*)(_Arg1, _Arg2)","kind":"","declname":"__x","desc":""}]}]},"push_heap":{"name":"push_heap","kind":"function","type":["void"],"def":"void std::push_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RAIter, _RAIter, _Compare)","desc":"","params":[{"type":"_RAIter","kind":"","desc":""},{"type":"_RAIter","kind":"","desc":""},{"type":"_Compare","kind":"","desc":""}]}]},"random_shuffle":{"name":"random_shuffle","kind":"function","type":["void"],"def":"void std::random_shuffle","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &&__rand)","desc":"Shuffle the elements of a sequence using a random number generator.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_RandomNumberGenerator &&","kind":"","declname":"__rand","desc":"The RNG functor or function."}]}]},"remove":{"name":"remove","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::remove","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)","desc":"Remove elements from a sequence.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"const _Tp &","kind":"","declname":"__value","desc":""}]}]},"remove_copy":{"name":"remove_copy","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::remove_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value)","desc":"Copy a sequence, removing elements of a given value.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":"An output iterator."},{"type":"const _Tp &","kind":"","declname":"__value","desc":"The value to be removed."}]}]},"remove_copy_if":{"name":"remove_copy_if","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::remove_copy_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)","desc":"Copy a sequence, removing elements for which a predicate is true.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"remove_if":{"name":"remove_if","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::remove_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)","desc":"Remove elements from a sequence using a predicate.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""},{"type":"_Predicate","kind":"","declname":"__pred","desc":""}]}]},"replace":{"name":"replace","kind":"function","type":["void"],"def":"void std::replace","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value)","desc":"Replace each occurrence of one value in a sequence with another value.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"const _Tp &","kind":"","declname":"__old_value","desc":"The value to be replaced."},{"type":"const _Tp &","kind":"","declname":"__new_value","desc":"The replacement value."}]}]},"replace_copy":{"name":"replace_copy","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::replace_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value)","desc":"Copy a sequence, replacing each element of one value with another value.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":"An output iterator."},{"type":"const _Tp &","kind":"","declname":"__old_value","desc":"The value to be replaced."},{"type":"const _Tp &","kind":"","declname":"__new_value","desc":"The replacement value."}]}]},"replace_copy_if":{"name":"replace_copy_if","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::replace_copy_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)","desc":"Copy a sequence, replacing each value for which a predicate returns true with another value.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":"An output iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."},{"type":"const _Tp &","kind":"","declname":"__new_value","desc":"The replacement value."}]}]},"replace_if":{"name":"replace_if","kind":"function","type":["void"],"def":"void std::replace_if","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value)","desc":"Replace each value in a sequence for which a predicate returns true with another value.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate."},{"type":"const _Tp &","kind":"","declname":"__new_value","desc":"The replacement value."}]}]},"rethrow_exception":{"name":"rethrow_exception","kind":"function","type":["void"],"def":"void std::rethrow_exception","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(exception_ptr) __attribute__((__noreturn__))","desc":"Throw the object pointed to by the exception_ptr.","params":[{"type":"exception_ptr","kind":"","desc":""}]}]},"rethrow_if_nested":{"name":"rethrow_if_nested","kind":"function","type":["void"],"def":"void std::rethrow_if_nested","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const nested_exception &__ex)","desc":"Overload, See N2619.","params":[{"type":"std::nested_exception","kind":"","operator":"const                \n                        \n &","declname":"__ex","desc":""}]}]},"return_temporary_buffer":{"name":"return_temporary_buffer","kind":"function","type":["void"],"def":"void std::return_temporary_buffer","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Tp *__p)","desc":"The companion to get_temporary_buffer().","params":[{"type":"_Tp *","kind":"","declname":"__p","desc":"A buffer previously allocated by get_temporary_buffer."}]}]},"reverse":{"name":"reverse","kind":"function","type":["void"],"def":"void std::reverse","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last)","desc":"Reverse a sequence.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":"A bidirectional iterator."},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":"A bidirectional iterator."}]}]},"reverse_copy":{"name":"reverse_copy","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::reverse_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)","desc":"Copy a sequence, reversing its elements.","params":[{"type":"_BidirectionalIterator","kind":"","declname":"__first","desc":"A bidirectional iterator."},{"type":"_BidirectionalIterator","kind":"","declname":"__last","desc":"A bidirectional iterator."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":"An output iterator."}]}]},"right":{"name":"right","kind":"function","type":["std::ios_base"],"def":"ios_base& std::right","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::right, ios_base::adjustfield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"rotate":{"name":"rotate","kind":"function","type":["void"],"def":"void std::rotate","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)","desc":"Rotate the elements of a sequence.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__middle","desc":""},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":""}]}]},"rotate_copy":{"name":"rotate_copy","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::rotate_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)","desc":"Copy a sequence, rotating its elements.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__middle","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":"An output iterator."}]}]},"scientific":{"name":"scientific","kind":"function","type":["std::ios_base"],"def":"ios_base& std::scientific","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::scientific, ios_base::floatfield).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"search":{"name":"search","kind":"function","type":["_ForwardIterator1"],"def":"_ForwardIterator1 std::search","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)","desc":"Search a sequence for a matching sub-sequence using a predicate.","params":[{"type":"_ForwardIterator1","kind":"","declname":"__first1","desc":""},{"type":"_ForwardIterator1","kind":"","declname":"__last1","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__first2","desc":""},{"type":"_ForwardIterator2","kind":"","declname":"__last2","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__predicate","desc":""}]}]},"search_n":{"name":"search_n","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::search_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred)","desc":"Search a sequence for a number of consecutive values using a predicate.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_Integer","kind":"","declname":"__count","desc":"The number of consecutive values."},{"type":"const _Tp &","kind":"","declname":"__val","desc":"The value to find."},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":"A binary predicate."}]}]},"set_difference":{"name":"set_difference","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::set_difference","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"Return the difference of two sorted ranges using comparison functor.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":"Start of first range."},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":"End of first range."},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":"Start of second range."},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":"End of second range."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":"The comparison functor."}]}]},"set_intersection":{"name":"set_intersection","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::set_intersection","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"Return the intersection of two sorted ranges using comparison functor.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":"Start of first range."},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":"End of first range."},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":"Start of second range."},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":"End of second range."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":"The comparison functor."}]}]},"set_symmetric_difference":{"name":"set_symmetric_difference","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::set_symmetric_difference","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"Return the symmetric difference of two sorted ranges using comparison functor.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":"Start of first range."},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":"End of first range."},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":"Start of second range."},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":"End of second range."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":"The comparison functor."}]}]},"set_union":{"name":"set_union","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::set_union","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)","desc":"Return the union of two sorted ranges using a comparison functor.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":"Start of first range."},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":"End of first range."},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":"Start of second range."},{"type":"_InputIterator2","kind":"","declname":"__last2","desc":"End of second range."},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":"The comparison functor."}]}]},"showbase":{"name":"showbase","kind":"function","type":["std::ios_base"],"def":"ios_base& std::showbase","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::showbase).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"showpoint":{"name":"showpoint","kind":"function","type":["std::ios_base"],"def":"ios_base& std::showpoint","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::showpoint).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"showpos":{"name":"showpos","kind":"function","type":["std::ios_base"],"def":"ios_base& std::showpos","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::showpos).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"shuffle":{"name":"shuffle","kind":"function","type":["void"],"def":"void std::shuffle","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &&__g)","desc":"Shuffle the elements of a sequence using a uniform random number generator.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_UniformRandomNumberGenerator &&","kind":"","declname":"__g","desc":"A UniformRandomNumberGenerator (26.5.1.3)."}]}]},"sin":{"name":"sin","kind":"function","type":["_Expr< _UnClos< _Sin, _Expr, _Dom >, typename _Dom::value_type >"],"def":"_Expr<_UnClos< _Sin , _Expr, _Dom>, typename _Dom::value_type> std::sin","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Expr< _Dom, typename _Dom::value_type > &__e)","desc":"","params":[{"type":"const _Expr< _Dom, typename _Dom::value_type > &","kind":"","declname":"__e","desc":""}]}]},"sinh":{"name":"sinh","kind":"function","type":["_Expr< _UnClos< _Sinh, _Expr, _Dom >, typename _Dom::value_type >"],"def":"_Expr<_UnClos< _Sinh , _Expr, _Dom>, typename _Dom::value_type> std::sinh","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Expr< _Dom, typename _Dom::value_type > &__e)","desc":"","params":[{"type":"const _Expr< _Dom, typename _Dom::value_type > &","kind":"","declname":"__e","desc":""}]}]},"skipws":{"name":"skipws","kind":"function","type":["std::ios_base"],"def":"ios_base& std::skipws","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::skipws).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"sort":{"name":"sort","kind":"function","type":["void"],"def":"void std::sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"Sort the elements of a sequence using a predicate for comparison.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"sort_heap":{"name":"sort_heap","kind":"function","type":["void"],"def":"void std::sort_heap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RAIter, _RAIter, _Compare)","desc":"","params":[{"type":"_RAIter","kind":"","desc":""},{"type":"_RAIter","kind":"","desc":""},{"type":"_Compare","kind":"","desc":""}]}]},"sqrt":{"name":"sqrt","kind":"function","type":["_Expr< _UnClos< _Sqrt, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Sqrt , _ValArray, _Tp>, _Tp> std::sqrt","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"stable_partition":{"name":"stable_partition","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::stable_partition","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)","desc":"Move elements for which a predicate is true to the beginning of a sequence, preserving relative ordering.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_Predicate","kind":"","declname":"__pred","desc":"A predicate functor."}]}]},"stable_sort":{"name":"stable_sort","kind":"function","type":["void"],"def":"void std::stable_sort","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)","desc":"Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements.","params":[{"type":"_RandomAccessIterator","kind":"","declname":"__first","desc":""},{"type":"_RandomAccessIterator","kind":"","declname":"__last","desc":""},{"type":"_Compare","kind":"","declname":"__comp","desc":""}]}]},"static_pointer_cast":{"name":"static_pointer_cast","kind":"function","type":["__shared_ptr< _Tp, _Lp >"],"def":"__shared_ptr<_Tp, _Lp> std::static_pointer_cast","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const __shared_ptr< _Tp1, _Lp > &__r) noexcept","desc":"static_pointer_cast","params":[{"type":"const __shared_ptr< _Tp1, _Lp > &","kind":"","declname":"__r","desc":""}]}]},"swap":{"name":"swap","kind":"function","type":["void"],"def":"void std::swap","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(basic_string< _CharT, _Traits, _Alloc > &__lhs, basic_string< _CharT, _Traits, _Alloc > &__rhs)","desc":"Swap contents of two strings.","params":[{"type":"std::basic_string","kind":"","operator":"< _CharT, _Traits, _Alloc > &","declname":"__lhs","desc":"First string."},{"type":"std::basic_string","kind":"","operator":"< _CharT, _Traits, _Alloc > &","declname":"__rhs","desc":"Second string."}]}]},"swap_ranges":{"name":"swap_ranges","kind":"function","type":["_FIter2"],"def":"_FIter2 std::swap_ranges","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_FIter1, _FIter1, _FIter2)","desc":"","params":[{"type":"_FIter1","kind":"","desc":""},{"type":"_FIter1","kind":"","desc":""},{"type":"_FIter2","kind":"","desc":""}]}]},"tan":{"name":"tan","kind":"function","type":["_Expr< _UnClos< _Tan, _Expr, _Dom >, typename _Dom::value_type >"],"def":"_Expr<_UnClos< _Tan , _Expr, _Dom>, typename _Dom::value_type> std::tan","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Expr< _Dom, typename _Dom::value_type > &__e)","desc":"","params":[{"type":"const _Expr< _Dom, typename _Dom::value_type > &","kind":"","declname":"__e","desc":""}]}]},"tanh":{"name":"tanh","kind":"function","type":["_Expr< _UnClos< _Tanh, _ValArray, _Tp >, _Tp >"],"def":"_Expr<_UnClos< _Tanh , _ValArray, _Tp>, _Tp> std::tanh","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const valarray< _Tp > &__v)","desc":"","params":[{"type":"const valarray< _Tp > &","kind":"","declname":"__v","desc":""}]}]},"throw_with_nested":{"name":"throw_with_nested","kind":"function","type":["void"],"def":"void std::throw_with_nested","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Ex __ex)","desc":"If                    \n                        \n is derived from nested_exception,                    \n                        \n. Else, an implementation-defined object derived from both.","params":[{"type":"_Ex","kind":"","declname":"__ex","desc":""}]}]},"tolower":{"name":"tolower","kind":"function","type":["_CharT"],"def":"_CharT std::tolower","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.tolower(__c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"toupper":{"name":"toupper","kind":"function","type":["_CharT"],"def":"_CharT std::toupper","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_CharT __c, const locale &__loc)","desc":"Convenience interface to ctype.toupper(__c).","params":[{"type":"_CharT","kind":"","declname":"__c","desc":""},{"type":"std::locale","kind":"","operator":"const                \n                        \n &","declname":"__loc","desc":""}]}]},"transform":{"name":"transform","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::transform","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)","desc":"Perform an operation on corresponding elements of two sequences.","params":[{"type":"_InputIterator1","kind":"","declname":"__first1","desc":""},{"type":"_InputIterator1","kind":"","declname":"__last1","desc":""},{"type":"_InputIterator2","kind":"","declname":"__first2","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_BinaryOperation","kind":"","declname":"__binary_op","desc":""}]}]},"uninitialized_copy":{"name":"uninitialized_copy","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::uninitialized_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _ForwardIterator __result)","desc":"Copies the range [first,last) into result.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":"An output iterator."}]}]},"uninitialized_copy_n":{"name":"uninitialized_copy_n","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::uninitialized_copy_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _Size __n, _ForwardIterator __result)","desc":"Copies the range [first,first+n) into result.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_Size","kind":"","declname":"__n","desc":"The number of elements to copy."},{"type":"_ForwardIterator","kind":"","declname":"__result","desc":"An output iterator."}]}]},"uninitialized_fill":{"name":"uninitialized_fill","kind":"function","type":["void"],"def":"void std::uninitialized_fill","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)","desc":"Copies the value x into the range [first,last).","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"const _Tp &","kind":"","declname":"__x","desc":"The source value."}]}]},"uninitialized_fill_n":{"name":"uninitialized_fill_n","kind":"function","type":["void"],"def":"void std::uninitialized_fill_n","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _Size __n, const _Tp &__x)","desc":"Copies the value x into the range [first,first+n).","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_Size","kind":"","declname":"__n","desc":"The number of copies to make."},{"type":"const _Tp &","kind":"","declname":"__x","desc":"The source value."}]}]},"unique":{"name":"unique","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::unique","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)","desc":"Remove consecutive values from a sequence using a predicate.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"A forward iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"A forward iterator."},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":"A binary predicate."}]}]},"unique_copy":{"name":"unique_copy","kind":"function","type":["_OutputIterator"],"def":"_OutputIterator std::unique_copy","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)","desc":"Copy a sequence, removing consecutive values using a predicate.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"_OutputIterator","kind":"","declname":"__result","desc":""},{"type":"_BinaryPredicate","kind":"","declname":"__binary_pred","desc":""}]}]},"unitbuf":{"name":"unitbuf","kind":"function","type":["std::ios_base"],"def":"ios_base& std::unitbuf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::unitbuf).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"upper_bound":{"name":"upper_bound","kind":"function","type":["_ForwardIterator"],"def":"_ForwardIterator std::upper_bound","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)","desc":"Finds the last position in which                    \n                        \n could be inserted without changing the ordering.","params":[{"type":"_ForwardIterator","kind":"","declname":"__first","desc":"An iterator."},{"type":"_ForwardIterator","kind":"","declname":"__last","desc":"Another iterator."},{"type":"const _Tp &","kind":"","declname":"__val","desc":"The search term."},{"type":"_Compare","kind":"","declname":"__comp","desc":"A functor to use for comparisons."}]}]},"uppercase":{"name":"uppercase","kind":"function","type":["std::ios_base"],"def":"ios_base& std::uppercase","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(ios_base &__base)","desc":"Calls base.setf(ios_base::uppercase).","params":[{"type":"std::ios_base","kind":"","operator":"&","declname":"__base","desc":""}]}]},"use_facet":{"name":"use_facet","kind":"function","type":["const _Facet &"],"def":"const _Facet& std::use_facet","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const locale &)","desc":"","params":[{"type":"std::locale","kind":"","operator":"const                \n                        \n &","desc":""}]}]}},"Classes":{"std::allocator":{"name":"std::allocator","members":{"allocator":{"name":"allocator","kind":"function","type":[""],"specialkind":"constructor","def":"std::allocator< _Tp >::allocator","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const allocator &__a)","desc":"","params":[{"type":"allocator","kind":"","operator":"const\n                \n &","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const allocator< _Tp1 > &)","desc":"","params":[{"type":"allocator","kind":"","operator":"const\n                \n< _Tp1 > &","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"address":{"name":"address","kind":"function","type":["pointer"],"specialkind":"none","def":"pointer __gnu_cxx::new_allocator< _Tp >::address","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(reference __x) const noexcept","desc":"","params":[{"type":"reference","kind":"","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_reference __x) const noexcept","desc":"","params":[{"type":"const_reference","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"allocate":{"name":"allocate","kind":"function","type":["pointer"],"specialkind":"none","def":"pointer __gnu_cxx::new_allocator< _Tp >::allocate","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const void *=0)","desc":"","params":[{"type":"size_type","kind":"","declname":"__n","desc":""},{"type":"const void *","kind":"","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"construct":{"name":"construct","kind":"function","type":["void"],"specialkind":"none","def":"void __gnu_cxx::new_allocator< _Tp >::construct","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Up *__p, _Args &&...__args)","desc":"","params":[{"type":"_Up *","kind":"","declname":"__p","desc":""},{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"deallocate":{"name":"deallocate","kind":"function","type":["void"],"specialkind":"none","def":"void __gnu_cxx::new_allocator< _Tp >::deallocate","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(pointer __p, size_type)","desc":"","params":[{"type":"pointer","kind":"","declname":"__p","desc":""},{"type":"size_type","kind":"","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"destroy":{"name":"destroy","kind":"function","type":["void"],"specialkind":"none","def":"void __gnu_cxx::new_allocator< _Tp >::destroy","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Up *__p)","desc":"","params":[{"type":"_Up *","kind":"","declname":"__p","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"max_size":{"name":"max_size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type __gnu_cxx::new_allocator< _Tp >::max_size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":{"emphasis":"standard","__text":"The\n            \n allocator, as per [20.4]."},"id":"classstd_1_1allocator","kind":"class","apilevel":["pro"],"drawercat":["pro"]},"std::deque":{"name":"std::deque","members":{"deque":{"name":"deque","kind":"function","type":[""],"specialkind":"constructor","def":"std::deque< _Tp, _Alloc >::deque","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"Creates a deque with no elements.","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const allocator_type &__a)","desc":"Creates a deque with no elements.","params":[{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n)","desc":"Creates a deque with default constructed elements.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"The number of elements to initially create."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const value_type &__value, const allocator_type &__a=allocator_type())","desc":"Creates a deque with copies of an exemplar element.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"The number of elements to initially create."},{"type":"const value_type &","kind":"","declname":"__value","desc":"An element to copy."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const deque &__x)","desc":"Deque copy constructor.","params":[{"type":"","kind":"","operator":"const\n                \n &","declname":"__x","desc":"A deque of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(deque &&__x)","desc":"Deque move constructor.","params":[{"type":"","kind":"","operator":"&&","declname":"__x","desc":"A deque of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l, const allocator_type &__a=allocator_type())","desc":"Builds a deque from an initializer list.","params":[{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())","desc":"Builds a deque from a range.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"assign":{"name":"assign","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::assign","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const value_type &__val)","desc":"Assigns a given value to a deque.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"Number of elements to be assigned."},{"type":"const value_type &","kind":"","declname":"__val","desc":"Value to be assigned."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last)","desc":"Assigns a range to a deque.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l)","desc":"Assigns an initializer list to a deque.","params":[{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"at":{"name":"at","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::deque< _Tp, _Alloc >::at","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n)","desc":"Provides access to the data contained in the deque.","params":[{"type":"size_type","kind":"","declname":"__n","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n) const","desc":"Provides access to the data contained in the deque.","params":[{"type":"size_type","kind":"","declname":"__n","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"back":{"name":"back","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::deque< _Tp, _Alloc >::back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"begin":{"name":"begin","kind":"function","type":[""],"specialkind":"none","def":"iterator std::deque< _Tp, _Alloc >::begin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cbegin":{"name":"cbegin","kind":"function","type":[""],"specialkind":"none","def":"const_iterator std::deque< _Tp, _Alloc >::cbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cend":{"name":"cend","kind":"function","type":[""],"specialkind":"none","def":"const_iterator std::deque< _Tp, _Alloc >::cend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"clear":{"name":"clear","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::clear","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crbegin":{"name":"crbegin","kind":"function","type":[""],"specialkind":"none","def":"const_reverse_iterator std::deque< _Tp, _Alloc >::crbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crend":{"name":"crend","kind":"function","type":[""],"specialkind":"none","def":"const_reverse_iterator std::deque< _Tp, _Alloc >::crend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace":{"name":"emplace","kind":"function","type":[""],"specialkind":"none","def":"iterator std::deque< _Tp, _Alloc >::emplace","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _Args &&...__args)","desc":"Inserts an object in deque before specified iterator.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the deque."},{"type":"_Args &&...","kind":"","declname":"__args","desc":"Arguments."}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace_back":{"name":"emplace_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::emplace_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace_front":{"name":"emplace_front","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::emplace_front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"empty":{"name":"empty","kind":"function","type":["bool"],"specialkind":"none","def":"bool std::deque< _Tp, _Alloc >::empty","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"end":{"name":"end","kind":"function","type":[""],"specialkind":"none","def":"iterator std::deque< _Tp, _Alloc >::end","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"erase":{"name":"erase","kind":"function","type":[""],"specialkind":"none","def":"iterator std::deque< _Tp, _Alloc >::erase","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position)","desc":"Remove element at given position.","params":[{"type":"","kind":"","declname":"__position","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __first, const_iterator __last)","desc":"Remove a range of elements.","params":[{"type":"","kind":"","declname":"__first","desc":""},{"type":"","kind":"","declname":"__last","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"front":{"name":"front","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::deque< _Tp, _Alloc >::front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"get_allocator":{"name":"get_allocator","kind":"function","type":["allocator_type"],"specialkind":"none","def":"allocator_type std::deque< _Tp, _Alloc >::get_allocator","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"Get a copy of the memory allocation object.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"insert":{"name":"insert","kind":"function","type":[""],"specialkind":"none","def":"iterator std::deque< _Tp, _Alloc >::insert","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, const value_type &__x)","desc":"Inserts given value into deque before specified iterator.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the deque."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, value_type &&__x)","desc":"Inserts given rvalue into deque before specified iterator.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the deque."},{"type":"value_type &&","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __p, initializer_list< value_type > __l)","desc":"Inserts an initializer list into the deque.","params":[{"type":"","kind":"","declname":"__p","desc":"An iterator into the deque."},{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":"An initializer_list."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, size_type __n, const value_type &__x)","desc":"Inserts a number of copies of given data into the deque.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the deque."},{"type":"size_type","kind":"","declname":"__n","desc":"Number of elements to be inserted."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _InputIterator __first, _InputIterator __last)","desc":"Inserts a range into the deque.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the deque."},{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."}]}],"apilevel":["pro"],"drawercat":["pro"]},"max_size":{"name":"max_size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::deque< _Tp, _Alloc >::max_size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"pop_back":{"name":"pop_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::pop_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"Removes last element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"pop_front":{"name":"pop_front","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::pop_front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"Removes first element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"push_back":{"name":"push_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::push_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the end of the deque.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"push_front":{"name":"push_front","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::push_front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the front of the deque.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"rbegin":{"name":"rbegin","kind":"function","type":[""],"specialkind":"none","def":"reverse_iterator std::deque< _Tp, _Alloc >::rbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"rend":{"name":"rend","kind":"function","type":[""],"specialkind":"none","def":"reverse_iterator std::deque< _Tp, _Alloc >::rend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"resize":{"name":"resize","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::resize","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __new_size)","desc":"Resizes the deque to the specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__new_size","desc":"Number of elements the deque should contain."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __new_size, const value_type &__x)","desc":"Resizes the deque to the specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__new_size","desc":"Number of elements the deque should contain."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data with which new elements should be populated."}]}],"apilevel":["pro"],"drawercat":["pro"]},"shrink_to_fit":{"name":"shrink_to_fit","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::shrink_to_fit","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"size":{"name":"size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::deque< _Tp, _Alloc >::size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void std::deque< _Tp, _Alloc >::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(deque &__x) noexcept","desc":"Swaps data with another deque.","params":[{"type":"","kind":"","operator":"&","declname":"__x","desc":"A deque of the same element and allocator types."}]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":"A standard container using fixed-size memory allocation and constant-time manipulation of elements at either end.","id":"classstd_1_1deque","kind":"class","apilevel":["pro"],"drawercat":["pro"]},"std::list":{"name":"std::list","members":{"list":{"name":"list","kind":"function","type":[""],"specialkind":"constructor","def":"std::list< _Tp, _Alloc >::list","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept(is_nothrow_default_constructible< _Node_alloc_type >::value)","desc":"Creates a list with no elements.","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const allocator_type &__a) noexcept","desc":"Creates a list with no elements.","params":[{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n)","desc":"Creates a list with default constructed elements.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"The number of elements to initially create."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const value_type &__value, const allocator_type &__a=allocator_type())","desc":"Creates a list with copies of an exemplar element.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"The number of elements to initially create."},{"type":"const value_type &","kind":"","declname":"__value","desc":"An element to copy."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const list &__x)","desc":"List copy constructor.","params":[{"type":"","kind":"","operator":"const                \n                        \n &","declname":"__x","desc":"A list of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(list &&__x) noexcept","desc":"List move constructor.","params":[{"type":"","kind":"","operator":"&&","declname":"__x","desc":"A list of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l, const allocator_type &__a=allocator_type())","desc":"Builds a list from an initializer_list.","params":[{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":"An initializer_list of value_type."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())","desc":"Builds a list from a range.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]}],"apilevel":["pro"],"drawercat":["pro"]},"assign":{"name":"assign","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::assign","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const value_type &__val)","desc":"Assigns a given value to a list.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"Number of elements to be assigned."},{"type":"const value_type &","kind":"","declname":"__val","desc":"Value to be assigned."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last)","desc":"Assigns a range to a list.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l)","desc":"Assigns an initializer_list to a list.","params":[{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":"An initializer_list of value_type."}]}],"apilevel":["pro"],"drawercat":["pro"]},"back":{"name":"back","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::list< _Tp, _Alloc >::back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"begin":{"name":"begin","kind":"function","type":[""],"specialkind":"none","def":"iterator std::list< _Tp, _Alloc >::begin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cbegin":{"name":"cbegin","kind":"function","type":[""],"specialkind":"none","def":"const_iterator std::list< _Tp, _Alloc >::cbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cend":{"name":"cend","kind":"function","type":[""],"specialkind":"none","def":"const_iterator std::list< _Tp, _Alloc >::cend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"clear":{"name":"clear","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::clear","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crbegin":{"name":"crbegin","kind":"function","type":[""],"specialkind":"none","def":"const_reverse_iterator std::list< _Tp, _Alloc >::crbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crend":{"name":"crend","kind":"function","type":[""],"specialkind":"none","def":"const_reverse_iterator std::list< _Tp, _Alloc >::crend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace":{"name":"emplace","kind":"function","type":[""],"specialkind":"none","def":"iterator std::list< _Tp, _Alloc >::emplace","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _Args &&...__args)","desc":"Constructs object in list before specified iterator.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the list."},{"type":"_Args &&...","kind":"","declname":"__args","desc":"Arguments."}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace_back":{"name":"emplace_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::emplace_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace_front":{"name":"emplace_front","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::emplace_front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"empty":{"name":"empty","kind":"function","type":["bool"],"specialkind":"none","def":"bool std::list< _Tp, _Alloc >::empty","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"end":{"name":"end","kind":"function","type":[""],"specialkind":"none","def":"iterator std::list< _Tp, _Alloc >::end","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"erase":{"name":"erase","kind":"function","type":[""],"specialkind":"none","def":"iterator std::list< _Tp, _Alloc >::erase","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position) noexcept","desc":"Remove element at given position.","params":[{"type":"","kind":"","declname":"__position","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __first, const_iterator __last) noexcept","desc":"Remove a range of elements.","params":[{"type":"","kind":"","declname":"__first","desc":""},{"type":"","kind":"","declname":"__last","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"front":{"name":"front","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::list< _Tp, _Alloc >::front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"get_allocator":{"name":"get_allocator","kind":"function","type":["allocator_type"],"specialkind":"none","def":"allocator_type std::list< _Tp, _Alloc >::get_allocator","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"Get a copy of the memory allocation object.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"insert":{"name":"insert","kind":"function","type":[""],"specialkind":"none","def":"iterator std::list< _Tp, _Alloc >::insert","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, const value_type &__x)","desc":"Inserts given value into list before specified iterator.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the list."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, value_type &&__x)","desc":"Inserts given rvalue into list before specified iterator.","params":[{"type":"","kind":"","declname":"__position","desc":"A const_iterator into the list."},{"type":"value_type &&","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __p, initializer_list< value_type > __l)","desc":"Inserts the contents of an initializer_list into list before specified const_iterator.","params":[{"type":"","kind":"","declname":"__p","desc":""},{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, size_type __n, const value_type &__x)","desc":"Inserts a number of copies of given data into the list.","params":[{"type":"","kind":"","declname":"__position","desc":""},{"type":"size_type","kind":"","declname":"__n","desc":""},{"type":"const value_type &","kind":"","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _InputIterator __first, _InputIterator __last)","desc":"Inserts a range into the list.","params":[{"type":"","kind":"","declname":"__position","desc":""},{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"max_size":{"name":"max_size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::list< _Tp, _Alloc >::max_size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"merge":{"name":"merge","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::merge","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(list &&__x)","desc":"Merge sorted lists.","params":[{"type":"","kind":"","operator":"&&","declname":"__x","desc":"Sorted list to merge."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(list &__x)","desc":"","params":[{"type":"","kind":"","operator":"&","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(list &&__x, _StrictWeakOrdering __comp)","desc":"Merge sorted lists according to comparison function.","params":[{"type":"","kind":"","operator":"&&","declname":"__x","desc":""},{"type":"_StrictWeakOrdering","kind":"","declname":"__comp","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(list &__x, _StrictWeakOrdering __comp)","desc":"","params":[{"type":"","kind":"","operator":"&","declname":"__x","desc":""},{"type":"_StrictWeakOrdering","kind":"","declname":"__comp","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"pop_back":{"name":"pop_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::pop_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"Removes last element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"pop_front":{"name":"pop_front","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::pop_front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"Removes first element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"push_back":{"name":"push_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::push_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the end of the list.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"push_front":{"name":"push_front","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::push_front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the front of the list.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"rbegin":{"name":"rbegin","kind":"function","type":[""],"specialkind":"none","def":"reverse_iterator std::list< _Tp, _Alloc >::rbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"remove":{"name":"remove","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::remove","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Tp &__value)","desc":"Remove all elements equal to value.","params":[{"type":"const _Tp &","kind":"","declname":"__value","desc":"The value to remove."}]}],"apilevel":["pro"],"drawercat":["pro"]},"remove_if":{"name":"remove_if","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::remove_if","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Predicate)","desc":"Remove all elements satisfying a predicate.","params":[{"type":"_Predicate","kind":"","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"rend":{"name":"rend","kind":"function","type":[""],"specialkind":"none","def":"reverse_iterator std::list< _Tp, _Alloc >::rend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"resize":{"name":"resize","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::resize","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __new_size)","desc":"Resizes the list to the specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__new_size","desc":"Number of elements the list should contain."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __new_size, const value_type &__x)","desc":"Resizes the list to the specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__new_size","desc":"Number of elements the list should contain."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data with which new elements should be populated."}]}],"apilevel":["pro"],"drawercat":["pro"]},"reverse":{"name":"reverse","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::reverse","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"Reverse the elements in list.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"size":{"name":"size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::list< _Tp, _Alloc >::size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"sort":{"name":"sort","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::sort","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"Sort the elements.","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_StrictWeakOrdering)","desc":"Sort the elements according to comparison function.","params":[{"type":"_StrictWeakOrdering","kind":"","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"splice":{"name":"splice","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::splice","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, list &&__x) noexcept","desc":"Insert contents of another list.","params":[{"type":"","kind":"","declname":"__position","desc":""},{"type":"","kind":"","operator":"&&","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, list &__x) noexcept","desc":"","params":[{"type":"","kind":"","declname":"__position","desc":""},{"type":"","kind":"","operator":"&","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, list &&__x, const_iterator __i) noexcept","desc":"Insert element from another list.","params":[{"type":"","kind":"","declname":"__position","desc":"Const_iterator referencing the element to insert before."},{"type":"","kind":"","operator":"&&","declname":"__x","desc":"Source list."},{"type":"","kind":"","declname":"__i","desc":"Const_iterator referencing the element to move."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, list &__x, const_iterator __i) noexcept","desc":"Insert element from another list.","params":[{"type":"","kind":"","declname":"__position","desc":"Const_iterator referencing the element to insert before."},{"type":"","kind":"","operator":"&","declname":"__x","desc":"Source list."},{"type":"","kind":"","declname":"__i","desc":"Const_iterator referencing the element to move."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, list &&__x, const_iterator __first, const_iterator __last) noexcept","desc":"Insert range from another list.","params":[{"type":"","kind":"","declname":"__position","desc":""},{"type":"","kind":"","operator":"&&","declname":"__x","desc":""},{"type":"","kind":"","declname":"__first","desc":""},{"type":"","kind":"","declname":"__last","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, list &__x, const_iterator __first, const_iterator __last) noexcept","desc":"Insert range from another list.","params":[{"type":"","kind":"","declname":"__position","desc":""},{"type":"","kind":"","operator":"&","declname":"__x","desc":""},{"type":"","kind":"","declname":"__first","desc":""},{"type":"","kind":"","declname":"__last","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(list &__x)","desc":"Swaps data with another list.","params":[{"type":"","kind":"","operator":"&","declname":"__x","desc":"A list of the same element and allocator types."}]}],"apilevel":["pro"],"drawercat":["pro"]},"unique":{"name":"unique","kind":"function","type":["void"],"specialkind":"none","def":"void std::list< _Tp, _Alloc >::unique","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"Remove consecutive duplicate elements.","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_BinaryPredicate)","desc":"Remove consecutive elements satisfying a predicate.","params":[{"type":"_BinaryPredicate","kind":"","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":"A standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence.","id":"classstd_1_1list","kind":"class","apilevel":["pro"],"drawercat":["pro"]},"std::map":{"name":"std::map","members":{"map":{"name":"map","kind":"function","type":[""],"specialkind":"constructor","def":"std::map< _Key, _Tp, _Compare, _Alloc >::map","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"Default constructor creates no elements.","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Compare &__comp, const allocator_type &__a=allocator_type())","desc":"Creates a map with no elements.","params":[{"type":"const _Compare &","kind":"","declname":"__comp","desc":"A comparison object."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const map &__x)","desc":"Map copy constructor.","params":[{"type":"map","kind":"","operator":"const\n                \n &","declname":"__x","desc":"A map of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(map &&__x) noexcept(is_nothrow_copy_constructible< _Compare >::value)","desc":"Map move constructor.","params":[{"type":"map","kind":"","operator":"&&","declname":"__x","desc":"A map of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l, const _Compare &__comp=_Compare(), const allocator_type &__a=allocator_type())","desc":"Builds a map from an initializer_list.","params":[{"type":"value_type","kind":"","operator":"initializer_list<\n                \n >","declname":"__l","desc":"An initializer_list."},{"type":"const _Compare &","kind":"","declname":"__comp","desc":"A comparison object."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const allocator_type &__a)","desc":"Allocator-extended default constructor.","params":[{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const map &__m, const allocator_type &__a)","desc":"Allocator-extended copy constructor.","params":[{"type":"map","kind":"","operator":"const\n                \n &","declname":"__m","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(map &&__m, const allocator_type &__a) noexcept(is_nothrow_copy_constructible< _Compare >::value &&_Alloc_traits::_S_always_equal())","desc":"Allocator-extended move constructor.","params":[{"type":"map","kind":"","operator":"&&","declname":"__m","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l, const allocator_type &__a)","desc":"Allocator-extended initialier-list constructor.","params":[{"type":"value_type","kind":"","operator":"initializer_list<\n                \n >","declname":"__l","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const allocator_type &__a)","desc":"Allocator-extended range constructor.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last)","desc":"Builds a map from a range.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const _Compare &__comp, const allocator_type &__a=allocator_type())","desc":"Builds a map from a range.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"An input iterator."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"An input iterator."},{"type":"const _Compare &","kind":"","declname":"__comp","desc":"A comparison functor."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]}],"apilevel":["pro"],"drawercat":["pro"]},"at":{"name":"at","kind":"function","type":["mapped_type &"],"specialkind":"none","def":"mapped_type& std::map< _Key, _Tp, _Compare, _Alloc >::at","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__k)","desc":"Access to map data.","params":[{"type":"const key_type &","kind":"","declname":"__k","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__k) const","desc":"","params":[{"type":"const key_type &","kind":"","declname":"__k","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"begin":{"name":"begin","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::begin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cbegin":{"name":"cbegin","kind":"function","type":["const_iterator"],"specialkind":"none","def":"const_iterator std::map< _Key, _Tp, _Compare, _Alloc >::cbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cend":{"name":"cend","kind":"function","type":["const_iterator"],"specialkind":"none","def":"const_iterator std::map< _Key, _Tp, _Compare, _Alloc >::cend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"clear":{"name":"clear","kind":"function","type":["void"],"specialkind":"none","def":"void std::map< _Key, _Tp, _Compare, _Alloc >::clear","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"count":{"name":"count","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::map< _Key, _Tp, _Compare, _Alloc >::count","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x) const","desc":"Finds the number of elements with given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pairs to be located."}]}],"apilevel":["pro"],"drawercat":["pro"]},"crbegin":{"name":"crbegin","kind":"function","type":["const_reverse_iterator"],"specialkind":"none","def":"const_reverse_iterator std::map< _Key, _Tp, _Compare, _Alloc >::crbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crend":{"name":"crend","kind":"function","type":["const_reverse_iterator"],"specialkind":"none","def":"const_reverse_iterator std::map< _Key, _Tp, _Compare, _Alloc >::crend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace":{"name":"emplace","kind":"function","type":["std::pair"],"specialkind":"none","def":"std::pair<iterator, bool> std::map< _Key, _Tp, _Compare, _Alloc >::emplace","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"Attempts to build and insert a std::pair into the map.","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace_hint":{"name":"emplace_hint","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::emplace_hint","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __pos, _Args &&...__args)","desc":"Attempts to build and insert a std::pair into the map.","params":[{"type":"const_iterator","kind":"","declname":"__pos","desc":""},{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"empty":{"name":"empty","kind":"function","type":["bool"],"specialkind":"none","def":"bool std::map< _Key, _Tp, _Compare, _Alloc >::empty","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"end":{"name":"end","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::end","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"equal_range":{"name":"equal_range","kind":"function","type":["std::pair"],"specialkind":"none","def":"std::pair<iterator, iterator> std::map< _Key, _Tp, _Compare, _Alloc >::equal_range","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x)","desc":"Finds a subsequence matching given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x) const","desc":"Finds a subsequence matching given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"erase":{"name":"erase","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::erase","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position)","desc":"Erases an element from a map.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":"An iterator pointing to the element to be erased."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(iterator __position)","desc":"","params":[{"type":"iterator","kind":"","declname":"__position","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x)","desc":"Erases elements according to the provided key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of element to be erased."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __first, const_iterator __last)","desc":"Erases a [first,last) range of elements from a map.","params":[{"type":"const_iterator","kind":"","declname":"__first","desc":"Iterator pointing to the start of the range to be erased."},{"type":"const_iterator","kind":"","declname":"__last","desc":"Iterator pointing to the end of the range to be erased."}]}],"apilevel":["pro"],"drawercat":["pro"]},"find":{"name":"find","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::find","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x)","desc":"Tries to locate an element in a map.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pair to be located."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x) const","desc":"Tries to locate an element in a map.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pair to be located."}]}],"apilevel":["pro"],"drawercat":["pro"]},"get_allocator":{"name":"get_allocator","kind":"function","type":["allocator_type"],"specialkind":"none","def":"allocator_type std::map< _Key, _Tp, _Compare, _Alloc >::get_allocator","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"Get a copy of the memory allocation object.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"insert":{"name":"insert","kind":"function","type":["std::pair"],"specialkind":"none","def":"std::pair<iterator, bool> std::map< _Key, _Tp, _Compare, _Alloc >::insert","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Attempts to insert a std::pair into the map.","params":[{"type":"value_type","kind":"","operator":"const\n                \n &","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Pair &&__x)","desc":"","params":[{"type":"_Pair &&","kind":"","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(std::initializer_list< value_type > __list)","desc":"Attempts to insert a list of std::pairs into the map.","params":[{"type":"value_type","kind":"","operator":"std::initializer_list<\n                \n >","declname":"__list","desc":"A std::initializer_list<value_type> of pairs to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, const value_type &__x)","desc":"Attempts to insert a std::pair into the map.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":""},{"type":"value_type","kind":"","operator":"const\n                \n &","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _Pair &&__x)","desc":"","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":""},{"type":"_Pair &&","kind":"","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last)","desc":"Template function that attempts to insert a range of elements.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":"Iterator pointing to the start of the range to be inserted."},{"type":"_InputIterator","kind":"","declname":"__last","desc":"Iterator pointing to the end of the range."}]}],"apilevel":["pro"],"drawercat":["pro"]},"key_comp":{"name":"key_comp","kind":"function","type":["key_compare"],"specialkind":"none","def":"key_compare std::map< _Key, _Tp, _Compare, _Alloc >::key_comp","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"lower_bound":{"name":"lower_bound","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::lower_bound","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x)","desc":"Finds the beginning of a subsequence matching given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pair to be located."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x) const","desc":"Finds the beginning of a subsequence matching given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pair to be located."}]}],"apilevel":["pro"],"drawercat":["pro"]},"max_size":{"name":"max_size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::map< _Key, _Tp, _Compare, _Alloc >::max_size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"rbegin":{"name":"rbegin","kind":"function","type":["reverse_iterator"],"specialkind":"none","def":"reverse_iterator std::map< _Key, _Tp, _Compare, _Alloc >::rbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"rend":{"name":"rend","kind":"function","type":["reverse_iterator"],"specialkind":"none","def":"reverse_iterator std::map< _Key, _Tp, _Compare, _Alloc >::rend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"size":{"name":"size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::map< _Key, _Tp, _Compare, _Alloc >::size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void std::map< _Key, _Tp, _Compare, _Alloc >::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(map &__x) noexcept(_Alloc_traits::_S_nothrow_swap())","desc":"Swaps data with another map.","params":[{"type":"map","kind":"","operator":"&","declname":"__x","desc":"A map of the same element and allocator types."}]}],"apilevel":["pro"],"drawercat":["pro"]},"upper_bound":{"name":"upper_bound","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::map< _Key, _Tp, _Compare, _Alloc >::upper_bound","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x)","desc":"Finds the end of a subsequence matching given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pair to be located."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const key_type &__x) const","desc":"Finds the end of a subsequence matching given key.","params":[{"type":"const key_type &","kind":"","declname":"__x","desc":"Key of (key, value) pair to be located."}]}],"apilevel":["pro"],"drawercat":["pro"]},"value_comp":{"name":"value_comp","kind":"function","type":["value_compare"],"specialkind":"none","def":"value_compare std::map< _Key, _Tp, _Compare, _Alloc >::value_comp","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":"A standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time.","id":"classstd_1_1map","kind":"class","apilevel":["pro"],"drawercat":["pro"]},"std::queue":{"name":"std::queue","members":{"queue":{"name":"queue","kind":"function","type":[""],"specialkind":"constructor","def":"std::queue< _Tp, _Sequence >::queue","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Sequence &__c)","desc":"Default constructor creates no elements.","params":[{"type":"const _Sequence &","kind":"","declname":"__c","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Sequence &&__c=_Sequence())","desc":"","params":[{"type":"_Sequence &&","kind":"","declname":"__c","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"back":{"name":"back","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::queue< _Tp, _Sequence >::back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace":{"name":"emplace","kind":"function","type":["void"],"specialkind":"none","def":"void std::queue< _Tp, _Sequence >::emplace","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"empty":{"name":"empty","kind":"function","type":["bool"],"specialkind":"none","def":"bool std::queue< _Tp, _Sequence >::empty","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"front":{"name":"front","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::queue< _Tp, _Sequence >::front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"pop":{"name":"pop","kind":"function","type":["void"],"specialkind":"none","def":"void std::queue< _Tp, _Sequence >::pop","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"Removes first element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"push":{"name":"push","kind":"function","type":["void"],"specialkind":"none","def":"void std::queue< _Tp, _Sequence >::push","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the end of the queue.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"size":{"name":"size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::queue< _Tp, _Sequence >::size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void std::queue< _Tp, _Sequence >::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(queue &__q) noexcept(noexcept(swap(c, __q.c)))","desc":"","params":[{"type":"","kind":"","operator":"&","declname":"__q","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":"A standard container giving FIFO behavior.","id":"classstd_1_1queue","kind":"class","apilevel":["pro"],"drawercat":["pro"]},"std::stack":{"name":"std::stack","members":{"stack":{"name":"stack","kind":"function","type":[""],"specialkind":"constructor","def":"std::stack< _Tp, _Sequence >::stack","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const _Sequence &__c)","desc":"Default constructor creates no elements.","params":[{"type":"const _Sequence &","kind":"","declname":"__c","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Sequence &&__c=_Sequence())","desc":"","params":[{"type":"_Sequence &&","kind":"","declname":"__c","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace":{"name":"emplace","kind":"function","type":["void"],"specialkind":"none","def":"void std::stack< _Tp, _Sequence >::emplace","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"empty":{"name":"empty","kind":"function","type":["bool"],"specialkind":"none","def":"bool std::stack< _Tp, _Sequence >::empty","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"pop":{"name":"pop","kind":"function","type":["void"],"specialkind":"none","def":"void std::stack< _Tp, _Sequence >::pop","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"Removes first element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"push":{"name":"push","kind":"function","type":["void"],"specialkind":"none","def":"void std::stack< _Tp, _Sequence >::push","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the top of the stack.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"size":{"name":"size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::stack< _Tp, _Sequence >::size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void std::stack< _Tp, _Sequence >::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(stack &__s) noexcept(noexcept(swap(c, __s.c)))","desc":"","params":[{"type":"","kind":"","operator":"&","declname":"__s","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"top":{"name":"top","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::stack< _Tp, _Sequence >::top","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":"A standard container giving FILO behavior.","id":"classstd_1_1stack","kind":"class","apilevel":["pro"],"drawercat":["pro"]},"std::vector":{"name":"std::vector","members":{"vector":{"name":"vector","kind":"function","type":[""],"specialkind":"constructor","def":"std::vector< _Tp, _Alloc >::vector","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept(is_nothrow_default_constructible< _Alloc >::value)","desc":"Creates a vector with no elements.","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const allocator_type &__a) noexcept","desc":"Creates a vector with no elements.","params":[{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator object."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const allocator_type &__a=allocator_type())","desc":"Creates a vector with default constructed elements.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"The number of elements to initially create."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const value_type &__value, const allocator_type &__a=allocator_type())","desc":"Creates a vector with copies of an exemplar element.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"The number of elements to initially create."},{"type":"const value_type &","kind":"","declname":"__value","desc":"An element to copy."},{"type":"const allocator_type &","kind":"","declname":"__a","desc":"An allocator."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const vector &__x)","desc":"Vector copy constructor.","params":[{"type":"","kind":"","operator":"const                \n                        \n &","declname":"__x","desc":"A vector of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(vector &&__x) noexcept","desc":"Vector move constructor.","params":[{"type":"","kind":"","operator":"&&","declname":"__x","desc":"A vector of identical element and allocator types."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const vector &__x, const allocator_type &__a)","desc":"Copy constructor with alternative allocator.","params":[{"type":"","kind":"","operator":"const                \n                        \n &","declname":"__x","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(vector &&__rv, const allocator_type &__m) noexcept(_Alloc_traits::_S_always_equal())","desc":"Move constructor with alternative allocator.","params":[{"type":"","kind":"","operator":"&&","declname":"__rv","desc":""},{"type":"const allocator_type &","kind":"","declname":"__m","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l, const allocator_type &__a=allocator_type())","desc":"Builds a vector from an initializer list.","params":[{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())","desc":"Builds a vector from a range.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""},{"type":"const allocator_type &","kind":"","declname":"__a","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"assign":{"name":"assign","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::assign","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n, const value_type &__val)","desc":"Assigns a given value to a vector.","params":[{"type":"size_type","kind":"","declname":"__n","desc":"Number of elements to be assigned."},{"type":"const value_type &","kind":"","declname":"__val","desc":"Value to be assigned."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_InputIterator __first, _InputIterator __last)","desc":"Assigns a range to a vector.","params":[{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(initializer_list< value_type > __l)","desc":"Assigns an initializer list to a vector.","params":[{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"at":{"name":"at","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::vector< _Tp, _Alloc >::at","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n)","desc":"Provides access to the data contained in the vector.","params":[{"type":"size_type","kind":"","declname":"__n","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n) const","desc":"Provides access to the data contained in the vector.","params":[{"type":"size_type","kind":"","declname":"__n","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"back":{"name":"back","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::vector< _Tp, _Alloc >::back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"begin":{"name":"begin","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::vector< _Tp, _Alloc >::begin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"capacity":{"name":"capacity","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::vector< _Tp, _Alloc >::capacity","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cbegin":{"name":"cbegin","kind":"function","type":["const_iterator"],"specialkind":"none","def":"const_iterator std::vector< _Tp, _Alloc >::cbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"cend":{"name":"cend","kind":"function","type":["const_iterator"],"specialkind":"none","def":"const_iterator std::vector< _Tp, _Alloc >::cend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"clear":{"name":"clear","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::clear","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crbegin":{"name":"crbegin","kind":"function","type":[""],"specialkind":"none","def":"const_reverse_iterator std::vector< _Tp, _Alloc >::crbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"crend":{"name":"crend","kind":"function","type":[""],"specialkind":"none","def":"const_reverse_iterator std::vector< _Tp, _Alloc >::crend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"data":{"name":"data","kind":"function","type":["_Tp *"],"specialkind":"none","def":"_Tp* std::vector< _Tp, _Alloc >::data","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace":{"name":"emplace","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::vector< _Tp, _Alloc >::emplace","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _Args &&...__args)","desc":"Inserts an object in vector before specified iterator.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":"A const_iterator into the vector."},{"type":"_Args &&...","kind":"","declname":"__args","desc":"Arguments."}]}],"apilevel":["pro"],"drawercat":["pro"]},"emplace_back":{"name":"emplace_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::emplace_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(_Args &&...__args)","desc":"","params":[{"type":"_Args &&...","kind":"","declname":"__args","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"empty":{"name":"empty","kind":"function","type":["bool"],"specialkind":"none","def":"bool std::vector< _Tp, _Alloc >::empty","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"end":{"name":"end","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::vector< _Tp, _Alloc >::end","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"erase":{"name":"erase","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::vector< _Tp, _Alloc >::erase","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position)","desc":"Remove element at given position.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __first, const_iterator __last)","desc":"Remove a range of elements.","params":[{"type":"const_iterator","kind":"","declname":"__first","desc":""},{"type":"const_iterator","kind":"","declname":"__last","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"front":{"name":"front","kind":"function","type":["reference"],"specialkind":"none","def":"reference std::vector< _Tp, _Alloc >::front","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"insert":{"name":"insert","kind":"function","type":["iterator"],"specialkind":"none","def":"iterator std::vector< _Tp, _Alloc >::insert","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, const value_type &__x)","desc":"Inserts given value into vector before specified iterator.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":"A const_iterator into the vector."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, value_type &&__x)","desc":"Inserts given rvalue into vector before specified iterator.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":"A const_iterator into the vector."},{"type":"value_type &&","kind":"","declname":"__x","desc":"Data to be inserted."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, initializer_list< value_type > __l)","desc":"Inserts an initializer_list into the vector.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":""},{"type":"initializer_list< value_type >","kind":"","declname":"__l","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, size_type __n, const value_type &__x)","desc":"Inserts a number of copies of given data into the vector.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":""},{"type":"size_type","kind":"","declname":"__n","desc":""},{"type":"const value_type &","kind":"","declname":"__x","desc":""}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const_iterator __position, _InputIterator __first, _InputIterator __last)","desc":"Inserts a range into the vector.","params":[{"type":"const_iterator","kind":"","declname":"__position","desc":""},{"type":"_InputIterator","kind":"","declname":"__first","desc":""},{"type":"_InputIterator","kind":"","declname":"__last","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"max_size":{"name":"max_size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::vector< _Tp, _Alloc >::max_size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"pop_back":{"name":"pop_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::pop_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"Removes last element.","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"push_back":{"name":"push_back","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::push_back","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(const value_type &__x)","desc":"Add data to the end of the vector.","params":[{"type":"const value_type &","kind":"","declname":"__x","desc":"Data to be added."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(value_type &&__x)","desc":"","params":[{"type":"value_type &&","kind":"","declname":"__x","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"rbegin":{"name":"rbegin","kind":"function","type":[""],"specialkind":"none","def":"reverse_iterator std::vector< _Tp, _Alloc >::rbegin","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"rend":{"name":"rend","kind":"function","type":[""],"specialkind":"none","def":"reverse_iterator std::vector< _Tp, _Alloc >::rend","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() noexcept","desc":"","params":[]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"reserve":{"name":"reserve","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::reserve","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __n)","desc":"Attempt to preallocate enough memory for specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__n","desc":""}]}],"apilevel":["pro"],"drawercat":["pro"]},"resize":{"name":"resize","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::resize","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __new_size)","desc":"Resizes the vector to the specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__new_size","desc":"Number of elements the vector should contain."}]},{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(size_type __new_size, const value_type &__x)","desc":"Resizes the vector to the specified number of elements.","params":[{"type":"size_type","kind":"","declname":"__new_size","desc":"Number of elements the vector should contain."},{"type":"const value_type &","kind":"","declname":"__x","desc":"Data with which new elements should be populated."}]}],"apilevel":["pro"],"drawercat":["pro"]},"shrink_to_fit":{"name":"shrink_to_fit","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::shrink_to_fit","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"()","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"size":{"name":"size","kind":"function","type":["size_type"],"specialkind":"none","def":"size_type std::vector< _Tp, _Alloc >::size","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"() const noexcept","desc":"","params":[]}],"apilevel":["pro"],"drawercat":["pro"]},"swap":{"name":"swap","kind":"function","type":["void"],"specialkind":"none","def":"void std::vector< _Tp, _Alloc >::swap","static":false,"overloads":[{"apilevel":["pro"],"drawercat":["pro"],"argsstring":"(vector &__x) noexcept(_Alloc_traits::_S_nothrow_swap())","desc":"Swaps data with another vector.","params":[{"type":"","kind":"","operator":"&","declname":"__x","desc":"A vector of the same element and allocator types."}]}],"apilevel":["pro"],"drawercat":["pro"]}},"desc":"A standard container which offers fixed time access to individual elements in any order.","id":"classstd_1_1vector","kind":"class","apilevel":["pro"],"drawercat":["pro"]}},"files":{"stdio.h":{"name":"stdio.h","members":{"tmpfile":{"name":"tmpfile","kind":"function","type":[""],"def":"FILE* tmpfile","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(void)","desc":""}]},"tmpnam":{"name":"tmpnam","kind":"function","type":["char *"],"def":"char* tmpnam","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *)","desc":""}]},"tempnam":{"name":"tempnam","kind":"function","type":["char *"],"def":"char* tempnam","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *)","desc":""}]},"fclose":{"name":"fclose","kind":"function","type":["int"],"def":"int fclose","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fflush":{"name":"fflush","kind":"function","type":["int"],"def":"int fflush","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"freopen":{"name":"freopen","kind":"function","type":[""],"def":"FILE* freopen","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict, const char *__restrict, FILE *__restrict)","desc":""}]},"setbuf":{"name":"setbuf","kind":"function","type":["void"],"def":"void setbuf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *__restrict, char *__restrict)","desc":""}]},"setvbuf":{"name":"setvbuf","kind":"function","type":["int"],"def":"int setvbuf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *__restrict, char *__restrict, int, size_t)","desc":""}]},"fprintf":{"name":"fprintf","kind":"function","type":["int"],"def":"int fprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"fscanf":{"name":"fscanf","kind":"function","type":["int"],"def":"int fscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__scanf__, 2, 3)))","desc":""}]},"printf":{"name":"printf","kind":"function","type":["int"],"def":"int printf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 1, 2)))","desc":""}]},"scanf":{"name":"scanf","kind":"function","type":["int"],"def":"int scanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict,...) _ATTRIBUTE((__format__(__scanf__, 1, 2)))","desc":""}]},"sscanf":{"name":"sscanf","kind":"function","type":["int"],"def":"int sscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__scanf__, 2, 3)))","desc":""}]},"vfprintf":{"name":"vfprintf","kind":"function","type":["int"],"def":"int vfprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"vprintf":{"name":"vprintf","kind":"function","type":["int"],"def":"int vprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 1, 0)))","desc":""}]},"vsprintf":{"name":"vsprintf","kind":"function","type":["int"],"def":"int vsprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"fgetc":{"name":"fgetc","kind":"function","type":["int"],"def":"int fgetc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fgets":{"name":"fgets","kind":"function","type":["char *"],"def":"char* fgets","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, int, FILE *__restrict)","desc":""}]},"fputc":{"name":"fputc","kind":"function","type":["int"],"def":"int fputc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, FILE *)","desc":""}]},"fputs":{"name":"fputs","kind":"function","type":["int"],"def":"int fputs","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict, FILE *__restrict)","desc":""}]},"getc":{"name":"getc","kind":"function","type":["int"],"def":"int getc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"getchar":{"name":"getchar","kind":"function","type":["int"],"def":"int getchar","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(void)","desc":""}]},"gets":{"name":"gets","kind":"function","type":["char *"],"def":"char* gets","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *)","desc":""}]},"putc":{"name":"putc","kind":"function","type":["int"],"def":"int putc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, FILE *)","desc":""}]},"putchar":{"name":"putchar","kind":"function","type":["int"],"def":"int putchar","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int)","desc":""}]},"puts":{"name":"puts","kind":"function","type":["int"],"def":"int puts","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *)","desc":""}]},"ungetc":{"name":"ungetc","kind":"function","type":["int"],"def":"int ungetc","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, FILE *)","desc":""}]},"fread":{"name":"fread","kind":"function","type":["size_t"],"def":"size_t fread","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(_PTR __restrict, size_t _size, size_t _n, FILE *__restrict)","desc":""}]},"fwrite":{"name":"fwrite","kind":"function","type":["size_t"],"def":"size_t fwrite","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const _PTR __restrict, size_t _size, size_t _n, FILE *)","desc":""}]},"fgetpos":{"name":"fgetpos","kind":"function","type":["int"],"def":"int fgetpos","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, _fpos_t *)","desc":""}]},"fseek":{"name":"fseek","kind":"function","type":["int"],"def":"int fseek","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, long, int)","desc":""}]},"fsetpos":{"name":"fsetpos","kind":"function","type":["int"],"def":"int fsetpos","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, const _fpos_t *)","desc":""}]},"ftell":{"name":"ftell","kind":"function","type":["long"],"def":"long ftell","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"rewind":{"name":"rewind","kind":"function","type":["void"],"def":"void rewind","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"clearerr":{"name":"clearerr","kind":"function","type":["void"],"def":"void clearerr","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"feof":{"name":"feof","kind":"function","type":["int"],"def":"int feof","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"ferror":{"name":"ferror","kind":"function","type":["int"],"def":"int ferror","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"perror":{"name":"perror","kind":"function","type":["void"],"def":"void perror","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *)","desc":""}]},"fopen":{"name":"fopen","kind":"function","type":[""],"def":"FILE* fopen","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict _name, const char *__restrict _type)","desc":""}]},"sprintf":{"name":"sprintf","kind":"function","type":["int"],"def":"int sprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"remove":{"name":"remove","kind":"function","type":["int"],"def":"int remove","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *)","desc":""}]},"rename":{"name":"rename","kind":"function","type":["int"],"def":"int rename","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *)","desc":""}]},"_rename":{"name":"_rename","kind":"function","type":["int"],"def":"int _rename","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *)","desc":""}]},"fseeko":{"name":"fseeko","kind":"function","type":["int"],"def":"int fseeko","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, _off_t, int)","desc":""}]},"ftello":{"name":"ftello","kind":"function","type":["_off_t"],"def":"off_t ftello","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fcloseall":{"name":"fcloseall","kind":"function","type":["int"],"def":"int fcloseall","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(_VOID)","desc":""}]},"asiprintf":{"name":"asiprintf","kind":"function","type":["int"],"def":"int asiprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **, const char *,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"asniprintf":{"name":"asniprintf","kind":"function","type":["char *"],"def":"char* asniprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, size_t *, const char *,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"asnprintf":{"name":"asnprintf","kind":"function","type":["char *"],"def":"char* asnprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, size_t *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"asprintf":{"name":"asprintf","kind":"function","type":["int"],"def":"int asprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"diprintf":{"name":"diprintf","kind":"function","type":["int"],"def":"int diprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"fiprintf":{"name":"fiprintf","kind":"function","type":["int"],"def":"int fiprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, const char *,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"fiscanf":{"name":"fiscanf","kind":"function","type":["int"],"def":"int fiscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, const char *,...) _ATTRIBUTE((__format__(__scanf__, 2, 3)))","desc":""}]},"iprintf":{"name":"iprintf","kind":"function","type":["int"],"def":"int iprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *,...) _ATTRIBUTE((__format__(__printf__, 1, 2)))","desc":""}]},"iscanf":{"name":"iscanf","kind":"function","type":["int"],"def":"int iscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *,...) _ATTRIBUTE((__format__(__scanf__, 1, 2)))","desc":""}]},"siprintf":{"name":"siprintf","kind":"function","type":["int"],"def":"int siprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, const char *,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"siscanf":{"name":"siscanf","kind":"function","type":["int"],"def":"int siscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *,...) _ATTRIBUTE((__format__(__scanf__, 2, 3)))","desc":""}]},"snprintf":{"name":"snprintf","kind":"function","type":["int"],"def":"int snprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, size_t, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"sniprintf":{"name":"sniprintf","kind":"function","type":["int"],"def":"int sniprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, size_t, const char *,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"vasiprintf":{"name":"vasiprintf","kind":"function","type":["int"],"def":"int vasiprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"vasniprintf":{"name":"vasniprintf","kind":"function","type":["char *"],"def":"char* vasniprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, size_t *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"vasnprintf":{"name":"vasnprintf","kind":"function","type":["char *"],"def":"char* vasnprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, size_t *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"vasprintf":{"name":"vasprintf","kind":"function","type":["int"],"def":"int vasprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"vdiprintf":{"name":"vdiprintf","kind":"function","type":["int"],"def":"int vdiprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"vfiprintf":{"name":"vfiprintf","kind":"function","type":["int"],"def":"int vfiprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"vfiscanf":{"name":"vfiscanf","kind":"function","type":["int"],"def":"int vfiscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 2, 0)))","desc":""}]},"vfscanf":{"name":"vfscanf","kind":"function","type":["int"],"def":"int vfscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__scanf__, 2, 0)))","desc":""}]},"viprintf":{"name":"viprintf","kind":"function","type":["int"],"def":"int viprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 1, 0)))","desc":""}]},"viscanf":{"name":"viscanf","kind":"function","type":["int"],"def":"int viscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 1, 0)))","desc":""}]},"vscanf":{"name":"vscanf","kind":"function","type":["int"],"def":"int vscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 1, 0)))","desc":""}]},"vsiprintf":{"name":"vsiprintf","kind":"function","type":["int"],"def":"int vsiprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"vsiscanf":{"name":"vsiscanf","kind":"function","type":["int"],"def":"int vsiscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 2, 0)))","desc":""}]},"vsniprintf":{"name":"vsniprintf","kind":"function","type":["int"],"def":"int vsniprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *, size_t, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"vsnprintf":{"name":"vsnprintf","kind":"function","type":["int"],"def":"int vsnprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, size_t, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"vsscanf":{"name":"vsscanf","kind":"function","type":["int"],"def":"int vsscanf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__scanf__, 2, 0)))","desc":""}]},"fdopen":{"name":"fdopen","kind":"function","type":[""],"def":"FILE* fdopen","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *)","desc":""}]},"fileno":{"name":"fileno","kind":"function","type":["int"],"def":"int fileno","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"getw":{"name":"getw","kind":"function","type":["int"],"def":"int getw","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"pclose":{"name":"pclose","kind":"function","type":["int"],"def":"int pclose","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"popen":{"name":"popen","kind":"function","type":[""],"def":"FILE* popen","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *)","desc":""}]},"putw":{"name":"putw","kind":"function","type":["int"],"def":"int putw","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, FILE *)","desc":""}]},"setbuffer":{"name":"setbuffer","kind":"function","type":["void"],"def":"void setbuffer","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, char *, int)","desc":""}]},"setlinebuf":{"name":"setlinebuf","kind":"function","type":["int"],"def":"int setlinebuf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"getc_unlocked":{"name":"getc_unlocked","kind":"function","type":["int"],"def":"int getc_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"getchar_unlocked":{"name":"getchar_unlocked","kind":"function","type":["int"],"def":"int getchar_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(void)","desc":""}]},"flockfile":{"name":"flockfile","kind":"function","type":["void"],"def":"void flockfile","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"ftrylockfile":{"name":"ftrylockfile","kind":"function","type":["int"],"def":"int ftrylockfile","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"funlockfile":{"name":"funlockfile","kind":"function","type":["void"],"def":"void funlockfile","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"putc_unlocked":{"name":"putc_unlocked","kind":"function","type":["int"],"def":"int putc_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, FILE *)","desc":""}]},"putchar_unlocked":{"name":"putchar_unlocked","kind":"function","type":["int"],"def":"int putchar_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int)","desc":""}]},"dprintf":{"name":"dprintf","kind":"function","type":["int"],"def":"int dprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"fmemopen":{"name":"fmemopen","kind":"function","type":[""],"def":"FILE* fmemopen","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(void *__restrict, size_t, const char *__restrict)","desc":""}]},"open_memstream":{"name":"open_memstream","kind":"function","type":[""],"def":"FILE* open_memstream","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **, size_t *)","desc":""}]},"renameat":{"name":"renameat","kind":"function","type":["int"],"def":"int renameat","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *, int, const char *)","desc":""}]},"vdprintf":{"name":"vdprintf","kind":"function","type":["int"],"def":"int vdprintf","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"_asiprintf_r":{"name":"_asiprintf_r","kind":"function","type":["int"],"def":"int _asiprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char **, const char *,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_asniprintf_r":{"name":"_asniprintf_r","kind":"function","type":["char *"],"def":"char* _asniprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, size_t *, const char *,...) _ATTRIBUTE((__format__(__printf__, 4, 5)))","desc":""}]},"_asnprintf_r":{"name":"_asnprintf_r","kind":"function","type":["char *"],"def":"char* _asnprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, size_t *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 4, 5)))","desc":""}]},"_asprintf_r":{"name":"_asprintf_r","kind":"function","type":["int"],"def":"int _asprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char **__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_diprintf_r":{"name":"_diprintf_r","kind":"function","type":["int"],"def":"int _diprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, const char *,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_dprintf_r":{"name":"_dprintf_r","kind":"function","type":["int"],"def":"int _dprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_fclose_r":{"name":"_fclose_r","kind":"function","type":["int"],"def":"int _fclose_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fcloseall_r":{"name":"_fcloseall_r","kind":"function","type":["int"],"def":"int _fcloseall_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *)","desc":""}]},"_fdopen_r":{"name":"_fdopen_r","kind":"function","type":[""],"def":"FILE* _fdopen_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, const char *)","desc":""}]},"_fflush_r":{"name":"_fflush_r","kind":"function","type":["int"],"def":"int _fflush_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fgetc_r":{"name":"_fgetc_r","kind":"function","type":["int"],"def":"int _fgetc_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fgetc_unlocked_r":{"name":"_fgetc_unlocked_r","kind":"function","type":["int"],"def":"int _fgetc_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fgets_r":{"name":"_fgets_r","kind":"function","type":["char *"],"def":"char* _fgets_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, int, FILE *__restrict)","desc":""}]},"_fgets_unlocked_r":{"name":"_fgets_unlocked_r","kind":"function","type":["char *"],"def":"char* _fgets_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, int, FILE *__restrict)","desc":""}]},"_fgetpos_r":{"name":"_fgetpos_r","kind":"function","type":["int"],"def":"int _fgetpos_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *__restrict, _fpos_t *__restrict)","desc":""}]},"_fsetpos_r":{"name":"_fsetpos_r","kind":"function","type":["int"],"def":"int _fsetpos_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, const _fpos_t *)","desc":""}]},"_fiprintf_r":{"name":"_fiprintf_r","kind":"function","type":["int"],"def":"int _fiprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, const char *,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_fiscanf_r":{"name":"_fiscanf_r","kind":"function","type":["int"],"def":"int _fiscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, const char *,...) _ATTRIBUTE((__format__(__scanf__, 3, 4)))","desc":""}]},"_fmemopen_r":{"name":"_fmemopen_r","kind":"function","type":[""],"def":"FILE* _fmemopen_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, void *__restrict, size_t, const char *__restrict)","desc":""}]},"_fopen_r":{"name":"_fopen_r","kind":"function","type":[""],"def":"FILE* _fopen_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, const char *__restrict)","desc":""}]},"_freopen_r":{"name":"_freopen_r","kind":"function","type":[""],"def":"FILE* _freopen_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, const char *__restrict, FILE *__restrict)","desc":""}]},"_fprintf_r":{"name":"_fprintf_r","kind":"function","type":["int"],"def":"int _fprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_fpurge_r":{"name":"_fpurge_r","kind":"function","type":["int"],"def":"int _fpurge_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fputc_r":{"name":"_fputc_r","kind":"function","type":["int"],"def":"int _fputc_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, FILE *)","desc":""}]},"_fputc_unlocked_r":{"name":"_fputc_unlocked_r","kind":"function","type":["int"],"def":"int _fputc_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, FILE *)","desc":""}]},"_fputs_r":{"name":"_fputs_r","kind":"function","type":["int"],"def":"int _fputs_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, FILE *__restrict)","desc":""}]},"_fputs_unlocked_r":{"name":"_fputs_unlocked_r","kind":"function","type":["int"],"def":"int _fputs_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, FILE *__restrict)","desc":""}]},"_fread_r":{"name":"_fread_r","kind":"function","type":["size_t"],"def":"size_t _fread_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, _PTR __restrict, size_t _size, size_t _n, FILE *__restrict)","desc":""}]},"_fread_unlocked_r":{"name":"_fread_unlocked_r","kind":"function","type":["size_t"],"def":"size_t _fread_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, _PTR __restrict, size_t _size, size_t _n, FILE *__restrict)","desc":""}]},"_fscanf_r":{"name":"_fscanf_r","kind":"function","type":["int"],"def":"int _fscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__scanf__, 3, 4)))","desc":""}]},"_fseek_r":{"name":"_fseek_r","kind":"function","type":["int"],"def":"int _fseek_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, long, int)","desc":""}]},"_fseeko_r":{"name":"_fseeko_r","kind":"function","type":["int"],"def":"int _fseeko_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, _off_t, int)","desc":""}]},"_ftell_r":{"name":"_ftell_r","kind":"function","type":["long"],"def":"long _ftell_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_ftello_r":{"name":"_ftello_r","kind":"function","type":["_off_t"],"def":"_off_t _ftello_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_rewind_r":{"name":"_rewind_r","kind":"function","type":["void"],"def":"void _rewind_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fwrite_r":{"name":"_fwrite_r","kind":"function","type":["size_t"],"def":"size_t _fwrite_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const _PTR __restrict, size_t _size, size_t _n, FILE *__restrict)","desc":""}]},"_fwrite_unlocked_r":{"name":"_fwrite_unlocked_r","kind":"function","type":["size_t"],"def":"size_t _fwrite_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const _PTR __restrict, size_t _size, size_t _n, FILE *__restrict)","desc":""}]},"_getc_r":{"name":"_getc_r","kind":"function","type":["int"],"def":"int _getc_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_getc_unlocked_r":{"name":"_getc_unlocked_r","kind":"function","type":["int"],"def":"int _getc_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_getchar_r":{"name":"_getchar_r","kind":"function","type":["int"],"def":"int _getchar_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *)","desc":""}]},"_getchar_unlocked_r":{"name":"_getchar_unlocked_r","kind":"function","type":["int"],"def":"int _getchar_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *)","desc":""}]},"_gets_r":{"name":"_gets_r","kind":"function","type":["char *"],"def":"char* _gets_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *)","desc":""}]},"_iprintf_r":{"name":"_iprintf_r","kind":"function","type":["int"],"def":"int _iprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"_iscanf_r":{"name":"_iscanf_r","kind":"function","type":["int"],"def":"int _iscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *,...) _ATTRIBUTE((__format__(__scanf__, 2, 3)))","desc":""}]},"_open_memstream_r":{"name":"_open_memstream_r","kind":"function","type":[""],"def":"FILE* _open_memstream_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char **, size_t *)","desc":""}]},"_perror_r":{"name":"_perror_r","kind":"function","type":["void"],"def":"void _perror_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *)","desc":""}]},"_printf_r":{"name":"_printf_r","kind":"function","type":["int"],"def":"int _printf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 2, 3)))","desc":""}]},"_putc_r":{"name":"_putc_r","kind":"function","type":["int"],"def":"int _putc_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, FILE *)","desc":""}]},"_putc_unlocked_r":{"name":"_putc_unlocked_r","kind":"function","type":["int"],"def":"int _putc_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, FILE *)","desc":""}]},"_putchar_unlocked_r":{"name":"_putchar_unlocked_r","kind":"function","type":["int"],"def":"int _putchar_unlocked_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int)","desc":""}]},"_putchar_r":{"name":"_putchar_r","kind":"function","type":["int"],"def":"int _putchar_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int)","desc":""}]},"_puts_r":{"name":"_puts_r","kind":"function","type":["int"],"def":"int _puts_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *)","desc":""}]},"_remove_r":{"name":"_remove_r","kind":"function","type":["int"],"def":"int _remove_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *)","desc":""}]},"_rename_r":{"name":"_rename_r","kind":"function","type":["int"],"def":"int _rename_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *_old, const char *_new)","desc":""}]},"_scanf_r":{"name":"_scanf_r","kind":"function","type":["int"],"def":"int _scanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict,...) _ATTRIBUTE((__format__(__scanf__, 2, 3)))","desc":""}]},"_siprintf_r":{"name":"_siprintf_r","kind":"function","type":["int"],"def":"int _siprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, const char *,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_siscanf_r":{"name":"_siscanf_r","kind":"function","type":["int"],"def":"int _siscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *, const char *,...) _ATTRIBUTE((__format__(__scanf__, 3, 4)))","desc":""}]},"_sniprintf_r":{"name":"_sniprintf_r","kind":"function","type":["int"],"def":"int _sniprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, size_t, const char *,...) _ATTRIBUTE((__format__(__printf__, 4, 5)))","desc":""}]},"_snprintf_r":{"name":"_snprintf_r","kind":"function","type":["int"],"def":"int _snprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, size_t, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 4, 5)))","desc":""}]},"_sprintf_r":{"name":"_sprintf_r","kind":"function","type":["int"],"def":"int _sprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__printf__, 3, 4)))","desc":""}]},"_sscanf_r":{"name":"_sscanf_r","kind":"function","type":["int"],"def":"int _sscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, const char *__restrict,...) _ATTRIBUTE((__format__(__scanf__, 3, 4)))","desc":""}]},"_tempnam_r":{"name":"_tempnam_r","kind":"function","type":["char *"],"def":"char* _tempnam_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *, const char *)","desc":""}]},"_tmpfile_r":{"name":"_tmpfile_r","kind":"function","type":[""],"def":"FILE* _tmpfile_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *)","desc":""}]},"_tmpnam_r":{"name":"_tmpnam_r","kind":"function","type":["char *"],"def":"char* _tmpnam_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *)","desc":""}]},"_ungetc_r":{"name":"_ungetc_r","kind":"function","type":["int"],"def":"int _ungetc_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, FILE *)","desc":""}]},"_vasiprintf_r":{"name":"_vasiprintf_r","kind":"function","type":["int"],"def":"int _vasiprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char **, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vasniprintf_r":{"name":"_vasniprintf_r","kind":"function","type":["char *"],"def":"char* _vasniprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, size_t *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 4, 0)))","desc":""}]},"_vasnprintf_r":{"name":"_vasnprintf_r","kind":"function","type":["char *"],"def":"char* _vasnprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, size_t *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 4, 0)))","desc":""}]},"_vasprintf_r":{"name":"_vasprintf_r","kind":"function","type":["int"],"def":"int _vasprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char **, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vdiprintf_r":{"name":"_vdiprintf_r","kind":"function","type":["int"],"def":"int _vdiprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vdprintf_r":{"name":"_vdprintf_r","kind":"function","type":["int"],"def":"int _vdprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vfiprintf_r":{"name":"_vfiprintf_r","kind":"function","type":["int"],"def":"int _vfiprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vfiscanf_r":{"name":"_vfiscanf_r","kind":"function","type":["int"],"def":"int _vfiscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 3, 0)))","desc":""}]},"_vfprintf_r":{"name":"_vfprintf_r","kind":"function","type":["int"],"def":"int _vfprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vfscanf_r":{"name":"_vfscanf_r","kind":"function","type":["int"],"def":"int _vfscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__scanf__, 3, 0)))","desc":""}]},"_viprintf_r":{"name":"_viprintf_r","kind":"function","type":["int"],"def":"int _viprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"_viscanf_r":{"name":"_viscanf_r","kind":"function","type":["int"],"def":"int _viscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 2, 0)))","desc":""}]},"_vprintf_r":{"name":"_vprintf_r","kind":"function","type":["int"],"def":"int _vprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 2, 0)))","desc":""}]},"_vscanf_r":{"name":"_vscanf_r","kind":"function","type":["int"],"def":"int _vscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__scanf__, 2, 0)))","desc":""}]},"_vsiprintf_r":{"name":"_vsiprintf_r","kind":"function","type":["int"],"def":"int _vsiprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vsiscanf_r":{"name":"_vsiscanf_r","kind":"function","type":["int"],"def":"int _vsiscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *, const char *, __VALIST) _ATTRIBUTE((__format__(__scanf__, 3, 0)))","desc":""}]},"_vsniprintf_r":{"name":"_vsniprintf_r","kind":"function","type":["int"],"def":"int _vsniprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *, size_t, const char *, __VALIST) _ATTRIBUTE((__format__(__printf__, 4, 0)))","desc":""}]},"_vsnprintf_r":{"name":"_vsnprintf_r","kind":"function","type":["int"],"def":"int _vsnprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, size_t, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 4, 0)))","desc":""}]},"_vsprintf_r":{"name":"_vsprintf_r","kind":"function","type":["int"],"def":"int _vsprintf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, char *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__printf__, 3, 0)))","desc":""}]},"_vsscanf_r":{"name":"_vsscanf_r","kind":"function","type":["int"],"def":"int _vsscanf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *__restrict, const char *__restrict, __VALIST) _ATTRIBUTE((__format__(__scanf__, 3, 0)))","desc":""}]},"fpurge":{"name":"fpurge","kind":"function","type":["int"],"def":"int fpurge","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"__getdelim":{"name":"__getdelim","kind":"function","type":["ssize_t"],"def":"ssize_t __getdelim","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **, size_t *, int, FILE *)","desc":""}]},"__getline":{"name":"__getline","kind":"function","type":["ssize_t"],"def":"ssize_t __getline","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char **, size_t *, FILE *)","desc":""}]},"clearerr_unlocked":{"name":"clearerr_unlocked","kind":"function","type":["void"],"def":"void clearerr_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"feof_unlocked":{"name":"feof_unlocked","kind":"function","type":["int"],"def":"int feof_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"ferror_unlocked":{"name":"ferror_unlocked","kind":"function","type":["int"],"def":"int ferror_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fileno_unlocked":{"name":"fileno_unlocked","kind":"function","type":["int"],"def":"int fileno_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fflush_unlocked":{"name":"fflush_unlocked","kind":"function","type":["int"],"def":"int fflush_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fgetc_unlocked":{"name":"fgetc_unlocked","kind":"function","type":["int"],"def":"int fgetc_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fputc_unlocked":{"name":"fputc_unlocked","kind":"function","type":["int"],"def":"int fputc_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, FILE *)","desc":""}]},"fread_unlocked":{"name":"fread_unlocked","kind":"function","type":["size_t"],"def":"size_t fread_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(_PTR __restrict, size_t _size, size_t _n, FILE *__restrict)","desc":""}]},"fwrite_unlocked":{"name":"fwrite_unlocked","kind":"function","type":["size_t"],"def":"size_t fwrite_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const _PTR __restrict, size_t _size, size_t _n, FILE *)","desc":""}]},"fgets_unlocked":{"name":"fgets_unlocked","kind":"function","type":["char *"],"def":"char* fgets_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(char *__restrict, int, FILE *__restrict)","desc":""}]},"fputs_unlocked":{"name":"fputs_unlocked","kind":"function","type":["int"],"def":"int fputs_unlocked","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *__restrict, FILE *__restrict)","desc":""}]},"fdopen64":{"name":"fdopen64","kind":"function","type":[""],"def":"FILE* fdopen64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(int, const char *)","desc":""}]},"fopen64":{"name":"fopen64","kind":"function","type":[""],"def":"FILE* fopen64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const char *, const char *)","desc":""}]},"freopen64":{"name":"freopen64","kind":"function","type":[""],"def":"FILE* freopen64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(_CONST char *, _CONST char *, FILE *)","desc":""}]},"ftello64":{"name":"ftello64","kind":"function","type":["_off64_t"],"def":"_off64_t ftello64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *)","desc":""}]},"fseeko64":{"name":"fseeko64","kind":"function","type":["_off64_t"],"def":"_off64_t fseeko64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, _off64_t, int)","desc":""}]},"fgetpos64":{"name":"fgetpos64","kind":"function","type":["int"],"def":"int fgetpos64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, _fpos64_t *)","desc":""}]},"fsetpos64":{"name":"fsetpos64","kind":"function","type":["int"],"def":"int fsetpos64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(FILE *, const _fpos64_t *)","desc":""}]},"tmpfile64":{"name":"tmpfile64","kind":"function","type":[""],"def":"FILE* tmpfile64","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(void)","desc":""}]},"_fdopen64_r":{"name":"_fdopen64_r","kind":"function","type":[""],"def":"FILE* _fdopen64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, const char *)","desc":""}]},"_fopen64_r":{"name":"_fopen64_r","kind":"function","type":[""],"def":"FILE* _fopen64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const char *, const char *)","desc":""}]},"_freopen64_r":{"name":"_freopen64_r","kind":"function","type":[""],"def":"FILE* _freopen64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, _CONST char *, _CONST char *, FILE *)","desc":""}]},"_ftello64_r":{"name":"_ftello64_r","kind":"function","type":["_off64_t"],"def":"_off64_t _ftello64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"_fseeko64_r":{"name":"_fseeko64_r","kind":"function","type":["_off64_t"],"def":"_off64_t _fseeko64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, _off64_t, int)","desc":""}]},"_fgetpos64_r":{"name":"_fgetpos64_r","kind":"function","type":["int"],"def":"int _fgetpos64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, _fpos64_t *)","desc":""}]},"_fsetpos64_r":{"name":"_fsetpos64_r","kind":"function","type":["int"],"def":"int _fsetpos64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *, const _fpos64_t *)","desc":""}]},"_tmpfile64_r":{"name":"_tmpfile64_r","kind":"function","type":[""],"def":"FILE* _tmpfile64_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *)","desc":""}]},"__srget_r":{"name":"__srget_r","kind":"function","type":["int"],"def":"int __srget_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, FILE *)","desc":""}]},"__swbuf_r":{"name":"__swbuf_r","kind":"function","type":["int"],"def":"int __swbuf_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, int, FILE *)","desc":""}]},"funopen":{"name":"funopen","kind":"function","type":[""],"def":"FILE* funopen","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(const _PTR __cookie, int(*__readfn)(_PTR __c, char *__buf, _READ_WRITE_BUFSIZE_TYPE __n), int(*__writefn)(_PTR __c, const char *__buf, _READ_WRITE_BUFSIZE_TYPE __n), _fpos64_t(*__seekfn)(_PTR __c, _fpos64_t __off, int __whence), int(*__closefn)(_PTR __c))","desc":""}]},"_funopen_r":{"name":"_funopen_r","kind":"function","type":[""],"def":"FILE* _funopen_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, const _PTR __cookie, int(*__readfn)(_PTR __c, char *__buf, _READ_WRITE_BUFSIZE_TYPE __n), int(*__writefn)(_PTR __c, const char *__buf, _READ_WRITE_BUFSIZE_TYPE __n), _fpos64_t(*__seekfn)(_PTR __c, _fpos64_t __off, int __whence), int(*__closefn)(_PTR __c))","desc":""}]},"fopencookie":{"name":"fopencookie","kind":"function","type":[""],"def":"FILE* fopencookie","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(void *__cookie, const char *__mode, cookie_io_functions_t __functions)","desc":""}]},"_fopencookie_r":{"name":"_fopencookie_r","kind":"function","type":[""],"def":"FILE* _fopencookie_r","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"argsstring":"(struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)","desc":""}]},"__sgetc_r":{"name":"__sgetc_r","kind":"function","type":["_ELIDABLE_INLINE int"],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"desc":""}]},"__sputc_r":{"name":"__sputc_r","kind":"function","type":["_ELIDABLE_INLINE int"],"def":"","apilevel":["pro"],"drawercat":["pro"],"static":false,"overloads":[{"desc":""}]}},"desc":"","id":"stdio_8h","kind":"file"}},"desc":"ISO C++ entities toplevel namespace is std.","id":"namespacestd","kind":"namespace"}}};

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    (this || window).CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
  var webkit = /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) display.input.focus();
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    var cm = this;

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || cm.hasFocus())
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);

    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
      optionHandlers[opt](this, options[opt], Init);
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) options.finishInit(this);
    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      display.lineDiv.style.textRendering = "auto";
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;

    if (place) {
      if (place.appendChild) place.appendChild(d.wrapper);
      else place(d.wrapper);
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    input.init(d);
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    place(vert); place(horiz);

    on(vert, "scroll", function() {
      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
  }

  NativeScrollbars.prototype = copyObj({
    update: function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;

      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        // A bug in IE8 can cause this value to be negative, so guard it.
        this.vert.firstChild.style.height =
          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }

      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width =
          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }

      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) this.zeroWidthHack();
        this.checkedZeroWidth = true;
      }

      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
    },
    setScrollLeft: function(pos) {
      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
    },
    setScrollTop: function(pos) {
      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
    },
    zeroWidthHack: function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed;
      this.disableVert = new Delayed;
    },
    enableZeroWidthBar: function(bar, delay) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        // To find out whether the scrollbar is still visible, we
        // check whether the element under the pixel in the bottom
        // left corner of the scrollbar box is the scrollbar box
        // itself (when the bar is still visible) or its filler child
        // (when the bar is hidden). If it is still visible, we keep
        // it enabled, if it's hidden, we disable pointer events.
        var box = bar.getBoundingClientRect();
        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
        if (elt != bar) bar.style.pointerEvents = "none";
        else delay.set(1000, maybeDisable);
      }
      delay.set(1000, maybeDisable);
    },
    clear: function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    }
  }, NativeScrollbars.prototype);

  function NullScrollbars() {}

  NullScrollbars.prototype = copyObj({
    update: function() { return {bottom: 0, right: 0}; },
    setScrollLeft: function() {},
    setScrollTop: function() {},
    clear: function() {}
  }, NullScrollbars.prototype);

  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }

    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function() {
        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") setScrollLeft(cm, pos);
      else setScrollTop(cm, pos);
    }, cm);
    if (cm.display.scrollbars.addClass)
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
  }

  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        updateHeightsInViewport(cm);
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else d.scrollbarFiller.style.display = "";
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else d.gutterFiller.style.display = "";
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          view[i].gutter.style.left = left;
        if (view[i].gutterBackground)
          view[i].gutterBackground.style.left = left;
      }
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  }

  DisplayUpdate.prototype.signal = function(emitter, type) {
    if (hasHandler(emitter, type))
      this.events.push(arguments);
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i = 0; i < this.events.length; i++)
      signal.apply(null, this.events[i]);
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      return false;

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      return false;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          break;
      }
      if (!updateDisplayIfNeeded(cm, update)) break;
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
                                      "px; width: " + dims.gutterTotalWidth + "px");
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        gutterWrap.className += " " + lineView.line.gutterClass;
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // INPUT HANDLING

  function ensureFocus(cm) {
    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) sel = doc.sel;

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = doc.splitLines(inserted), multiPaste = null
    // When pasing N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
        }
      } else if (textLines.length == sel.ranges.length) {
        multiPaste = map(textLines, function(l) { return [l]; });
      }
    }

    // Normal behavior is to insert the new text into every selection
    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          from = Pos(from.line, from.ch - deleted);
        else if (cm.state.overwrite && !paste) // Handle overwrite
          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
          from = to = Pos(from.line, 0)
      }
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      triggerElectric(cm, inserted);

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) return;
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break;
          }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          indented = indentLine(cm, range.head.line, "smart");
      }
      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges};
  }

  function disableBrowserMagic(field, spellcheck) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  // TEXTAREA INPUT STYLE

  function TextareaInput(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Tracks when input.reset has punted to just putting a short
    // string into the textarea instead of the full selection.
    this.inaccurateSelection = false;
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) te.style.width = "1000px";
    else te.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) te.style.border = "1px solid black";
    disableBrowserMagic(te);
    return div;
  }

  TextareaInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = this.cm;

      // Wraps and hides input textarea
      var div = this.wrapper = hiddenTextarea();
      // The semihidden textarea that is focused when the editor is
      // focused, and receives input.
      var te = this.textarea = div.firstChild;
      display.wrapper.insertBefore(div, display.wrapper.firstChild);

      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
      if (ios) te.style.width = "0px";

      on(te, "input", function() {
        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
        input.poll();
      });

      on(te, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return

        cm.state.pasteIncoming = true;
        input.fastPoll();
      });

      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = {lineWise: false, text: cm.getSelections()};
          if (input.inaccurateSelection) {
            input.prevInput = "";
            input.inaccurateSelection = false;
            te.value = lastCopied.text.join("\n");
            selectInput(te);
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = {lineWise: true, text: ranges.text};
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te.value = ranges.text.join("\n");
            selectInput(te);
          }
        }
        if (e.type == "cut") cm.state.cutIncoming = true;
      }
      on(te, "cut", prepareCopyCut);
      on(te, "copy", prepareCopyCut);

      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
        cm.state.pasteIncoming = true;
        input.focus();
      });

      // Prevent normal selection in the editor (we handle our own)
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) e_preventDefault(e);
      });

      on(te, "compositionstart", function() {
        var start = cm.getCursor("from");
        if (input.composing) input.composing.range.clear()
        input.composing = {
          start: start,
          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
        };
      });
      on(te, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    },

    prepareSelection: function() {
      // Redraw the selection and/or cursor
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result = prepareSelection(cm);

      // Move the hidden textarea near the cursor to prevent scrolling artifacts
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                            headPos.top + lineOff.top - wrapOff.top));
        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                             headPos.left + lineOff.left - wrapOff.left));
      }

      return result;
    },

    showSelection: function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    },

    // Reset the input to correspond to the selection (or to be empty,
    // when not typing and nothing is selected)
    reset: function(typing) {
      if (this.contextMenuPending) return;
      var minimal, selected, cm = this.cm, doc = cm.doc;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var range = doc.sel.primary();
        minimal = hasCopyEvent &&
          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
        var content = minimal ? "-" : selected || cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) selectInput(this.textarea);
        if (ie && ie_version >= 9) this.hasSelection = content;
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie && ie_version >= 9) this.hasSelection = null;
      }
      this.inaccurateSelection = minimal;
    },

    getField: function() { return this.textarea; },

    supportsTouch: function() { return false; },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try { this.textarea.focus(); }
        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
      }
    },

    blur: function() { this.textarea.blur(); },

    resetPosition: function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    },

    receivedFocus: function() { this.slowPoll(); },

    // Poll for input changes, using the normal rate of polling. This
    // runs as long as the editor is focused.
    slowPoll: function() {
      var input = this;
      if (input.pollingFast) return;
      input.polling.set(this.cm.options.pollInterval, function() {
        input.poll();
        if (input.cm.state.focused) input.slowPoll();
      });
    },

    // When an event has just come in that is likely to add or change
    // something in the input textarea, we poll faster, to ensure that
    // the change appears on the screen quickly.
    fastPoll: function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p() {
        var changed = input.poll();
        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
        else {input.pollingFast = false; input.slowPoll();}
      }
      input.polling.set(20, p);
    },

    // Read input from the textarea, and update the document to match.
    // When something is selected, it is present in the textarea, and
    // selected (unless it is huge, in which case a placeholder is
    // used). When nothing is selected, the cursor sits after previously
    // seen text (can be empty), which is stored in prevInput (we must
    // not reset the textarea when typing, because that breaks IME).
    poll: function() {
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      // Since this is called a *lot*, try to bail out as cheaply as
      // possible when it is clear that nothing happened. hasSelection
      // will be the case when there is a lot of text in the textarea,
      // in which case reading its value would be expensive.
      if (this.contextMenuPending || !cm.state.focused ||
          (hasSelection(input) && !prevInput && !this.composing) ||
          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
        return false;

      var text = input.value;
      // If nothing changed, bail.
      if (text == prevInput && !cm.somethingSelected()) return false;
      // Work around nonsensical selection resetting in IE9/10, and
      // inexplicable appearance of private area unicode characters on
      // some key combos in Mac (#2689).
      if (ie && ie_version >= 9 && this.hasSelection === text ||
          mac && /[\uf700-\uf7ff]/.test(text)) {
        cm.display.input.reset();
        return false;
      }

      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text.charCodeAt(0);
        if (first == 0x200b && !prevInput) prevInput = "\u200b";
        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
      }
      // Find the part of the input that is actually new
      var same = 0, l = Math.min(prevInput.length, text.length);
      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;

      var self = this;
      runInOp(cm, function() {
        applyTextInput(cm, text.slice(same), prevInput.length - same,
                       null, self.composing ? "*compose" : null);

        // Don't leave long text in the textarea, since it makes further polling slow
        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
        else self.prevInput = text;

        if (self.composing) {
          self.composing.range.clear();
          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
                                             {className: "CodeMirror-composing"});
        }
      });
      return true;
    },

    ensurePolled: function() {
      if (this.pollingFast && this.poll()) this.pollingFast = false;
    },

    onKeyPress: function() {
      if (ie && ie_version >= 9) this.hasSelection = null;
      this.fastPoll();
    },

    onContextMenu: function(e) {
      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) return; // Opera is difficult.

      // Reset the current text selection only if the click is done outside of the selection
      // and 'resetSelectionOnContextMenu' option is true.
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1)
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      input.wrapper.style.cssText = "position: absolute"
      var wrapperBox = input.wrapper.getBoundingClientRect()
      te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +
        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +
        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
      display.input.focus();
      if (webkit) window.scrollTo(null, oldScrollY);
      display.input.reset();
      // Adds "Select all" to context menu in FF
      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
      input.contextMenuPending = true;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);

      // Select-all will be greyed out if there's nothing to select, so
      // this adds a zero-width space so that we can later check whether
      // it got selected.
      function prepareSelectAllHack() {
        if (te.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200b" + (selected ? te.value : "");
          te.value = "\u21da"; // Used to catch context-menu undo
          te.value = extval;
          input.prevInput = selected ? "" : "\u200b";
          te.selectionStart = 1; te.selectionEnd = extval.length;
          // Re-set this, in case some other handler touched the
          // selection in the meantime.
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS
        te.style.cssText = oldCSS;
        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);

        // Try to detect the user choosing select-all
        if (te.selectionStart != null) {
          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
          var i = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
                te.selectionEnd > 0 && input.prevInput == "\u200b")
              operation(cm, commands.selectAll)(cm);
            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
            else display.input.reset();
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }

      if (ie && ie_version >= 9) prepareSelectAllHack();
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    },

    readOnlyChanged: function(val) {
      if (!val) this.reset();
    },

    setUneditable: nothing,

    needsContentAttribute: false
  }, TextareaInput.prototype);

  // CONTENTEDITABLE INPUT STYLE

  function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.gracePeriod = false;
  }

  ContentEditableInput.prototype = copyObj({
    init: function(display) {
      var input = this, cm = input.cm;
      var div = input.div = display.lineDiv;
      disableBrowserMagic(div, cm.options.spellcheck);

      on(div, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return
        // IE doesn't fire input events, so we schedule a read for the pasted content in this way
        if (ie_version <= 11) setTimeout(operation(cm, function() {
          if (!input.pollContent()) regChange(cm);
        }), 20)
      })

      on(div, "compositionstart", function(e) {
        var data = e.data;
        input.composing = {sel: cm.doc.sel, data: data, startData: data};
        if (!data) return;
        var prim = cm.doc.sel.primary();
        var line = cm.getLine(prim.head.line);
        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
        if (found > -1 && found <= prim.head.ch)
          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
                                                Pos(prim.head.line, found + data.length));
      });
      on(div, "compositionupdate", function(e) {
        input.composing.data = e.data;
      });
      on(div, "compositionend", function(e) {
        var ours = input.composing;
        if (!ours) return;
        if (e.data != ours.startData && !/\u200b/.test(e.data))
          ours.data = e.data;
        // Need a small delay to prevent other code (input event,
        // selection polling) from doing damage when fired right after
        // compositionend.
        setTimeout(function() {
          if (!ours.handled)
            input.applyComposition(ours);
          if (input.composing == ours)
            input.composing = null;
        }, 50);
      });

      on(div, "touchstart", function() {
        input.forceCompositionEnd();
      });

      on(div, "input", function() {
        if (input.composing) return;
        if (cm.isReadOnly() || !input.pollContent())
          runInOp(input.cm, function() {regChange(cm);});
      });

      function onCopyCut(e) {
        if (signalDOMEvent(cm, e)) return
        if (cm.somethingSelected()) {
          lastCopied = {lineWise: false, text: cm.getSelections()};
          if (e.type == "cut") cm.replaceSelection("", null, "cut");
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          lastCopied = {lineWise: true, text: ranges.text};
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied.text.join("\n")
          // iOS exposes the clipboard API, but seems to discard content inserted into it
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return
          }
        }
        // Old-fashioned briefly-focus-a-textarea hack
        var kludge = hiddenTextarea(), te = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te.value = lastCopied.text.join("\n");
        var hadFocus = document.activeElement;
        selectInput(te);
        setTimeout(function() {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div) input.showPrimarySelection()
        }, 50);
      }
      on(div, "copy", onCopyCut);
      on(div, "cut", onCopyCut);
    },

    prepareSelection: function() {
      var result = prepareSelection(this.cm, false);
      result.focus = this.cm.state.focused;
      return result;
    },

    showSelection: function(info, takeFocus) {
      if (!info || !this.cm.display.view.length) return;
      if (info.focus || takeFocus) this.showPrimarySelection();
      this.showMultipleSelections(info);
    },

    showPrimarySelection: function() {
      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
        return;

      var start = posToDOM(this.cm, prim.from());
      var end = posToDOM(this.cm, prim.to());
      if (!start && !end) return;

      var view = this.cm.display.view;
      var old = sel.rangeCount && sel.getRangeAt(0);
      if (!start) {
        start = {node: view[0].measure.map[2], offset: 0};
      } else if (!end) { // FIXME dangerously hacky
        var measure = view[view.length - 1].measure;
        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
      }

      try { var rng = range(start.node, start.offset, end.offset, end.node); }
      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
      if (rng) {
        if (!gecko && this.cm.state.focused) {
          sel.collapse(start.node, start.offset);
          if (!rng.collapsed) sel.addRange(rng);
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) sel.addRange(old);
        else if (gecko) this.startGracePeriod();
      }
      this.rememberSelection();
    },

    startGracePeriod: function() {
      var input = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        input.gracePeriod = false;
        if (input.selectionChanged())
          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
      }, 20);
    },

    showMultipleSelections: function(info) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
    },

    rememberSelection: function() {
      var sel = window.getSelection();
      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
    },

    selectionInEditor: function() {
      var sel = window.getSelection();
      if (!sel.rangeCount) return false;
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    },

    focus: function() {
      if (this.cm.options.readOnly != "nocursor") this.div.focus();
    },
    blur: function() { this.div.blur(); },
    getField: function() { return this.div; },

    supportsTouch: function() { return true; },

    receivedFocus: function() {
      var input = this;
      if (this.selectionInEditor())
        this.pollSelection();
      else
        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });

      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    },

    selectionChanged: function() {
      var sel = window.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    },

    pollSelection: function() {
      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
        var sel = window.getSelection(), cm = this.cm;
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
        });
      }
    },

    pollContent: function() {
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;

      var fromIndex;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        var fromLine = lineNo(display.view[0].line);
        var fromNode = display.view[0].node;
      } else {
        var fromLine = lineNo(display.view[fromIndex].line);
        var fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      if (toIndex == display.view.length - 1) {
        var toLine = display.viewTo - 1;
        var toNode = display.lineDiv.lastChild;
      } else {
        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
        var toNode = display.view[toIndex + 1].node.previousSibling;
      }

      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
        else break;
      }

      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
        ++cutFront;
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
        ++cutEnd;

      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
      newText[0] = newText[0].slice(cutFront);

      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    },

    ensurePolled: function() {
      this.forceCompositionEnd();
    },
    reset: function() {
      this.forceCompositionEnd();
    },
    forceCompositionEnd: function() {
      if (!this.composing || this.composing.handled) return;
      this.applyComposition(this.composing);
      this.composing.handled = true;
      this.div.blur();
      this.div.focus();
    },
    applyComposition: function(composing) {
      if (this.cm.isReadOnly())
        operation(this.cm, regChange)(this.cm)
      else if (composing.data && composing.data != composing.startData)
        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
    },

    setUneditable: function(node) {
      node.contentEditable = "false"
    },

    onKeyPress: function(e) {
      e.preventDefault();
      if (!this.cm.isReadOnly())
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    },

    readOnlyChanged: function(val) {
      this.div.contentEditable = String(val != "nocursor")
    },

    onContextMenu: nothing,
    resetPosition: nothing,

    needsContentAttribute: true
  }, ContentEditableInput.prototype);

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) return null;
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) return null;
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        return locateNodeInLineView(lineView, node, offset);
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) offset = textNode.nodeValue.length;
    }
    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
            return Pos(line, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) return badPos(found, bad);

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        return badPos(Pos(found.line, found.ch - dist), bad);
      else
        dist += after.textContent.length;
    }
    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        return badPos(Pos(found.line, found.ch + dist), bad);
      else
        dist += before.textContent.length;
    }
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator();
    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText != null) {
          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
          text += cmText;
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find()))
            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
          return;
        }
        if (node.getAttribute("contenteditable") == "false") return;
        for (var i = 0; i < node.childNodes.length; i++)
          walk(node.childNodes[i]);
        if (/^(pre|div|p)$/i.test(node.nodeName))
          closing = true;
      } else if (node.nodeType == 3) {
        var val = node.nodeValue;
        if (!val) return;
        if (closing) {
          text += lineSep;
          closing = false;
        }
        text += val;
      }
    }
    for (;;) {
      walk(from);
      if (from == to) break;
      from = from.nextSibling;
    }
    return text;
  }

  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel, options);

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;
      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) break;
            else {--i; continue;}
          }
        }
        if (!m.atomic) continue;

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff;
          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            return skipAtomicInner(doc, near, pos, dir, mayClear);
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
          far = movePos(doc, far, dir, far.line == pos.line ? line : null);
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
      }
    }
    return pos;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }
    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
      else return null;
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
      else return null;
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  // SELECTION DRAWING

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (primary === false && i == doc.sel.primIndex) continue;
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range.head, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }
    return result;
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    else if (cm.options.cursorBlinkRate < 0)
      display.cursorDiv.style.visibility = "hidden";
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changedLines = [];

    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) line.styleClasses = newCls;
        else if (oldCls) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) changedLines.push(doc.frontier);
        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changedLines.length) runInOp(cm, function() {
      for (var i = 0; i < changedLines.length; i++)
        regLineChange(cm, changedLines[i], "text");
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect
    if (bias == "left") for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) break
    } else for (var i = rects.length - 1; i >= 0; i--) {
      if ((rect = rects[i]).left != rect.right) break
    }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          rect = node.parentNode.getBoundingClientRect();
        else
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)
        if (rect.left || rect.right || start == 0) break;
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (mid < heights[i]) break;
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result;
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      return rect;
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var outside = ch == from ? fromOutside : toOutside
        var xDiff = x - (ch == from ? fromX : toX);
        // This is a kludge to handle the case where the coordinates
        // are after a line-wrapped line. We should replace it with a
        // more general handling of cursor positions around line
        // breaks. (Issue #4078)
        if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&
            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
          var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
            outside = false
            ch++
            xDiff = x - charSize.right
          }
        }
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i].call(null);
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
      }
    } while (i < callbacks.length);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, group = op.ownsGroup;
    if (!group) return;

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      for (var i = 0; i < group.ops.length; i++)
        group.ops[i].cm.curOp = null;
      endOperations(group);
    }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W1(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_R2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
      endOperation_W2(ops[i]);
    for (var i = 0; i < ops.length; i++) // Read DOM
      endOperation_finish(ops[i]);
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) findMaxLine(cm);

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) updateHeightsInViewport(cm);

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      op.preparedSelection = display.input.prepareSelection(op.focus);
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
    if (op.preparedSelection)
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      updateScrollbars(cm, op.barMeasure);
    if (op.updatedDisplay)
      setDocumentHeight(cm, op.barMeasure);

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      cm.display.input.reset(op.typing);
    if (takeFocus) ensureFocus(op.cm);
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      display.wheelStartX = display.wheelStartY = null;

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scrollbars.setScrollTop(doc.scrollTop);
      display.scroller.scrollTop = doc.scrollTop;
    }
    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scrollbars.setScrollLeft(doc.scrollLeft);
      display.scroller.scrollLeft = doc.scrollLeft;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    if (display.wrapper.offsetHeight)
      doc.scrollTop = cm.display.scroller.scrollTop;

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (op.update)
      op.update.finish();
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    };
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) return false;
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) return true;
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) d.activeTouch.moved = true;
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          range = new Range(pos, pos);
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          range = cm.findWordAt(pos);
        else // Triple tap
          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function(e){onDragStart(cm, e);},
      drop: operation(cm, onDrop),
      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { onFocus(cm, e); });
    on(inp, "blur", function (e) { onBlur(cm, e); });
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != CodeMirror.Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
      return;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      // #3261: make sure, that we're not starting a second selection
      if (cm.state.selectingText)
        cm.state.selectingText(e);
      else if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(function() {display.input.focus();}, 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      else delayBlurEvent(cm);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    if (ie) setTimeout(bind(ensureFocus, cm), 0);
    else cm.curOp.focus = activeElt();

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        type == "single" && (contained = sel.contains(start)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
        (cmp(contained.to(), start) > 0 || start.xRel < 0))
      leftButtonStartDrag(cm, e, start, modifier);
    else
      leftButtonSelect(cm, e, start, type, modifier);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start, modifier) {
    var display = cm.display, startTime = +new Date;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        if (!modifier && +new Date - 200 < startTime)
          extendSelection(cm.doc, start);
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if (webkit || ie && ie_version == 9)
          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
        else
          display.input.focus();
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    dragEnd.copy = mac ? e.altKey : e.ctrlKey
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = cm.findWordAt(start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = cm.findWordAt(pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if (!e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
          return;

        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
          text[i] = content;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove"

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) return;
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = doc.splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return false
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return false
      } else ch = next;
      return true;
    }

    if (unit == "char") {
      moveOnce()
    } else if (unit == "column") {
      moveOnce(true)
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
    if (!cmp(pos, result)) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      insertSorted(this.state.overlays,
                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                    priority: (options && options.priority) || 0},
                   function(overlay) { return overlay.priority })
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd].call(null, this);
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 4, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("lineSeparator", null, function(cm, val) {
    cm.doc.lineSep = val;
    if (!val) return;
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function(line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) break;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
  });
  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("spellcheck", false, function(cm, val) {
    cm.getInputField().spellcheck = val
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
    }
    cm.display.input.readOnlyChanged(val)
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true, dragDropChanged);
  option("allowDropFileTypes", null);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return CodeMirror.resolveMode("application/json");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function(cm) {cm.replaceSelection("\n", "start")},
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    //language mode check 
    if (CodeMirror && CodeMirror.LanguageMode) {
      if (CodeMirror.LanguageMode != vex.helpsys.getLanguageMode()) {
        console.log(`updating language mode to " ${CodeMirror.LanguageMode}" on creating editor fromTextArea`);
        vex.helpsys.setLanguageMode(CodeMirror.LanguageMode);
      }
    }
    //adding features internally without having the need for changing the UI code
    //adding code folding 
    if (options) {
      if (options.foldGutter == undefined) options["foldGutter"] = true;
      if (options.gutters == undefined) options["gutters"] = ["CodeMirror-linenumbers", "textedit-errorgutter", "CodeMirror-foldgutter"]
      //making sure language mode matches the editor language mode
      if (options.languageMode) {
        if (options.languageMode != vex.helpsys.getLanguageMode()) {
          console.log(`changing language mode to : ${options.languageMode} for the editor : ${options.editorType}`)
          vex.helpsys.setLanguageMode(options.languageMode);
        }
      }
    }
    //////////////////////////

    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
        // VEX Custom styling - for main
        if (style == "def" && stream.current() == "main") {
          style = "control";
        }
        
        // VEX Cutsom styling - for constructors
        if (style == "builtin") {
          let stream_loc = new StringStream(text, cm.options.tabSize);
          stream_loc.pos = stream.pos;
          stream_loc.eatSpace();
          stream_loc.start = stream_loc.pos;
          let nextChar = stream_loc.next();
          if (nextChar && nextChar.trim() == "(") {
            style = "def";
          }
        }
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var state = getStateBefore(cm, lineNo(line));
      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        builder.content.className = "cm-tab-wrap-hack";
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) return text
    var spaceBefore = trailingBefore, result = ""
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i)
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        ch = "\u00a0"
      result += ch
      spaceBefore = ch == " "
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = (css ? css + ";" : "") + m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]

        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
          if (collapsed.to == pos) collapsed = false;
        }
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.extend = false;

    if (typeof text == "string") text = this.splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || this.lineSeparator());
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function(line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + sepSize;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;},

    splitLines: function(str) {
      if (this.lineSep) return str.split(this.lineSep);
      return splitLinesAuto(str);
    },
    lineSeparator: function() { return this.lineSep || "\n"; }
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var noHandlers = []
  function getHandlers(emitter, type, copy) {
    var arr = emitter._handlers && emitter._handlers[type]
    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
    else return arr || noHandlers
  }

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var handlers = getHandlers(emitter, type, false)
      for (var i = 0; i < handlers.length; ++i)
        if (handlers[i] == f) { handlers.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type, true)
    if (!handlers.length) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
  };

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type, false)
    if (!arr.length) return;
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      list.push(bnd(arr[i]));
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value)
    while (pos < array.length && score(array[pos]) <= priority) pos++
    array.splice(pos, 0, value)
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };
  function isWordChar(ch, helper) {
    if (!helper) return isWordCharBasic(ch);
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r; }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  var contains = CodeMirror.contains = function(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      child = child.parentNode;
    if (parent.contains)
      return parent.contains(child);
    do {
      if (child.nodeType == 11) child = child.host;
      if (child == parent) return true;
    } while (child = child.parentNode);
  };

  function activeElt() {
    var activeElement = document.activeElement;
    while (activeElement && activeElement.root && activeElement.root.activeElement)
      activeElement = activeElement.root.activeElement;
    return activeElement;
  }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie && ie_version < 11) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
  var rmClass = CodeMirror.rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  var addClass = CodeMirror.addClass = function(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
  };
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // WINDOW-WIDE EVENTS

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.body.getElementsByClassName) return;
    var byClass = document.body.getElementsByClassName("CodeMirror");
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) f(cm);
    }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) return;
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100);
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function() {
      forEachCodeMirror(onBlur);
    });
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) return badZoomedRects;
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }

  // KEY NAMES

  var keyNames = CodeMirror.keyNames = {
    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS);
    }
    return start;
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level == 2)
        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "5.19.0";

  return CodeMirror;
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
    (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;

  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};

  function findMatchingBracket(cm, where, strict, config) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (strict && (dir > 0) != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {from: Pos(where.line, pos), to: found && found.pos,
            match: found && found.ch == match.charAt(0), forward: dir > 0};
  }

  // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = (config && config.maxScanLineLength) || 10000;
    var maxScanLines = (config && config.maxScanLines) || 1000;

    var stack = [];
    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
          else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [], ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);
      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();

      var clear = function() {
        cm.operation(function() {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        });
      };
      if (autoclear) setTimeout(clear, 800);
      else return clear;
    }
  }

  var currentlyHighlighted = null;
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });

  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
  CodeMirror.defineExtension("findMatchingBracket", function(pos, strict, config){
    return findMatchingBracket(this, pos, strict, config);
  });
  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
    return scanForBracket(this, pos, dir, style, config);
  });
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.registerHelper("fold", "brace", function(cm, start) {
  var line = start.line, lineText = cm.getLine(line);
  var tokenType;

  function findOpening(openCh) {
    for (var at = start.ch, pass = 0;;) {
      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
      if (found == -1) {
        if (pass == 1) break;
        pass = 1;
        at = lineText.length;
        continue;
      }
      if (pass == 1 && found < start.ch) break;
      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
      if (!/^(comment|string)/.test(tokenType)) return found + 1;
      at = found - 1;
    }
  }

  var startToken = "{", endToken = "}", startCh = findOpening("{");
  //if (startCh == null) {
  //  startToken = "[", endToken = "]";
  //  startCh = findOpening("[");
  //}

  if (startCh == null) return;
  var count = 1, lastLine = cm.lastLine(), end, endCh;
  outer: for (var i = line; i <= lastLine; ++i) {
    var text = cm.getLine(i), pos = i == line ? startCh : 0;
    for (;;) {
      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
      if (nextOpen < 0) nextOpen = text.length;
      if (nextClose < 0) nextClose = text.length;
      pos = Math.min(nextOpen, nextClose);
      if (pos == text.length) break;
      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {
        if (pos == nextOpen) ++count;
        else if (!--count) { end = i; endCh = pos; break outer; }
      }
      ++pos;
    }
  }
  if (end == null || line == end && endCh == startCh) return;
  return {from: CodeMirror.Pos(line, startCh),
          to: CodeMirror.Pos(end, endCh)};
});

CodeMirror.registerHelper("fold", "import", function(cm, start) {
  function hasImport(line) {
    if (line < cm.firstLine() || line > cm.lastLine()) return null;
    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
    if (start.type != "keyword" || start.string != "import") return null;
    // Now find closing semicolon, return its position
    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
      var text = cm.getLine(i), semi = text.indexOf(";");
      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};
    }
  }

  var startLine = start.line, has = hasImport(startLine), prev;
  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))
    return null;
  for (var end = has.end;;) {
    var next = hasImport(end.line + 1);
    if (next == null) break;
    end = next.end;
  }
  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};
});

CodeMirror.registerHelper("fold", "include", function(cm, start) {
  function hasInclude(line) {
    if (line < cm.firstLine() || line > cm.lastLine()) return null;
    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
  }

  var startLine = start.line, has = hasInclude(startLine);
  if (has == null || hasInclude(startLine - 1) != null) return null;
  for (var end = startLine;;) {
    var next = hasInclude(end + 1);
    if (next == null) break;
    ++end;
  }
  return {from: CodeMirror.Pos(startLine, has + 1),
          to: cm.clipPos(CodeMirror.Pos(end))};
});

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  function doFold(cm, pos, options, force) {
    if (options && options.call) {
      var finder = options;
      options = null;
    } else {
      var finder = getOption(cm, options, "rangeFinder");
    }
    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
    var minSize = getOption(cm, options, "minFoldSize");

    function getRange(allowFolded) {
      var range = finder(cm, pos);
      if (!range || range.to.line - range.from.line < minSize) return null;
      var marks = cm.findMarksAt(range.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold && force !== "fold") {
          if (!allowFolded) return null;
          range.cleared = true;
          marks[i].clear();
        }
      }
      return range;
    }

    var range = getRange(true);
    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
      pos = CodeMirror.Pos(pos.line - 1, 0);
      range = getRange(false);
    }
    if (!range || range.cleared || force === "unfold") return;

    var myWidget = makeWidget(cm, options);
    CodeMirror.on(myWidget, "mousedown", function(e) {
      myRange.clear();
      CodeMirror.e_preventDefault(e);
    });
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: getOption(cm, options, "clearOnEnter"),
      __isFold: true
    });
    myRange.on("clear", function(from, to) {
      CodeMirror.signal(cm, "unfold", cm, from, to);
    });
    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
  }

  function makeWidget(cm, options) {
    var widget = getOption(cm, options, "widget");
    if (typeof widget == "string") {
      var text = document.createTextNode(widget);
      widget = document.createElement("span");
      widget.appendChild(text);
      widget.className = "CodeMirror-foldmarker";
    }
    return widget;
  }

  // Clumsy backwards-compatible interface
  CodeMirror.newFoldFunction = function(rangeFinder, widget) {
    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
  };

  // New-style interface
  CodeMirror.defineExtension("foldCode", function(pos, options, force) {
    doFold(this, pos, options, force);
  });

  CodeMirror.defineExtension("isFolded", function(pos) {
    var marks = this.findMarksAt(pos);
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold) return true;
  });

  CodeMirror.commands.toggleFold = function(cm) {
    cm.foldCode(cm.getCursor());
  };
  CodeMirror.commands.fold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "fold");
  };
  CodeMirror.commands.unfold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "unfold");
  };
  CodeMirror.commands.foldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
    });
  };
  CodeMirror.commands.unfoldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
    });
  };

  CodeMirror.registerHelper("fold", "combine", function() {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function(cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found) return found;
      }
    };
  });

  CodeMirror.registerHelper("fold", "auto", function(cm, start) {
    var helpers = cm.getHelpers(start, "fold");
    for (var i = 0; i < helpers.length; i++) {
      var cur = helpers[i](cm, start);
      if (cur) return cur;
    }
  });

  var defaultOptions = {
    rangeFinder: CodeMirror.fold.auto,
    widget: "\u2194",
    minFoldSize: 0,
    scanUp: false,
    clearOnEnter: true
  };

  CodeMirror.defineOption("foldOptions", null);

  function getOption(cm, options, name) {
    if (options && options[name] !== undefined)
      return options[name];
    var editorOptions = cm.options.foldOptions;
    if (editorOptions && editorOptions[name] !== undefined)
      return editorOptions[name];
    return defaultOptions[name];
  }

  CodeMirror.defineExtension("foldOption", function(options, name) {
    return getOption(this, options, name);
  });
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./foldcode"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./foldcode"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off("gutterClick", onGutterClick);
      cm.off("change", onChange);
      cm.off("viewportChange", onViewportChange);
      cm.off("fold", onFold);
      cm.off("unfold", onFold);
      cm.off("swapDoc", onChange);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on("gutterClick", onGutterClick);
      cm.on("change", onChange);
      cm.on("viewportChange", onViewportChange);
      cm.on("fold", onFold);
      cm.on("unfold", onFold);
      cm.on("swapDoc", onChange);
    }
  });

  var Pos = CodeMirror.Pos;

  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }

  function parseOptions(opts) {
    if (opts === true) opts = {};
    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
    return opts;
  }

  function isFolded(cm, line) {
    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];
  }

  function marker(spec) {
    if (typeof spec == "string") {
      var elt = document.createElement("div");
      elt.className = spec + " CodeMirror-guttermarker-subtle";
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }

  function updateFoldInfo(cm, from, to) {
    var opts = cm.state.foldGutter.options, cur = from;
    var minSize = cm.foldOption(opts, "minFoldSize");
    var func = cm.foldOption(opts, "rangeFinder");
    cm.eachLine(from, to, function(line) {
      var mark = null;
      if (isFolded(cm, cur)) {
        mark = marker(opts.indicatorFolded);
      } else {
        var pos = Pos(cur, 0);
        var range = func && func(cm, pos);
        if (range && range.to.line - range.from.line >= minSize)
          mark = marker(opts.indicatorOpen);
      }
      cm.setGutterMarker(line, opts.gutter, mark);
      ++cur;
    });
  }

  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state) return;
    cm.operation(function() {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from; state.to = vp.to;
  }

  function onGutterClick(cm, line, gutter) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    if (gutter != opts.gutter) return;
    var folded = isFolded(cm, line);
    if (folded) folded.clear();
    else cm.foldCode(Pos(line, 0), opts.rangeFinder);
  }

  function onChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);
  }

  function onViewportChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts = state.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function() {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts.updateViewportTimeSpan || 400);
  }

  function onFold(cm, from) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
});

////////// Help Tooltip Database lookup helpers//////////////////////////
var vex;
(function (vex) {
  var helpsys;
  (function (helpsys) {
    /**
     * Read the json file containing all the function definitions
     */
    function init() {
      //_readJSONFile('node_modules/@vexdev/vex-code-editor/resources/helpsys.json').then(function (data) {
      try {
        helpsys._help = __vexdev__vex_code_editor__help_data;
        // get array of builtin functions
        var words = getNamespaceMembers();
        //below logic is for local context to resolve object of vex classes declared using just classname 
        let onlyVexMems = getNamespaceMembers("vex");
        for (let j = 0; j < onlyVexMems.length; j++) {
          onlyVexMems[j] = onlyVexMems[j].replace("vex::", '').trim();
        }
        words = words.concat(onlyVexMems);
        let onlyStdMems = getNamespaceMembers("std");
        for (let j = 0; j < onlyStdMems.length; j++) {
          onlyStdMems[j] = onlyStdMems[j].replace("std::", '').trim();
        }
        words = words.concat(onlyStdMems);
        console.log(words);
        // add to the builtin clike names
        // there must be a better way.
        var spec = CodeMirror.resolveMode("text/x-c++src");
        console.log(spec);
        var obj = spec.builtin;
        if (obj == undefined) obj = {};
        for (var i = 0; i < words.length; ++i)
          obj[words[i]] = true;
        spec.builtin = obj;
      } catch (e) {
        console.log(e);
      }
      //});
    }
    helpsys.init = init;
    let _languageModes = ["block", "cpp", "pro"];
    let _languageMode = "cpp";
    function getLanguageMode() {
      return _languageMode;
    }
    helpsys.getLanguageMode = getLanguageMode;
    function setLanguageMode(level) {
      level = level.toLowerCase();
      if (_languageModes.includes(level)) {
        console.log(`setting language mode to ${level}`);
        _languageMode = level;
        console.log("current language mode : " + _languageMode);
      }
      else
        console.error("Error setting language mode. Available language modes : block, cpp & pro")
      console.log("current language mode : " + _languageMode);
    }
    helpsys.setLanguageMode = setLanguageMode;
    function checkUserLevel(userlevel) {
      let blnAllow = false;
      if (userlevel && userlevel.length > 0) {
        blnAllow = userlevel.includes(_languageMode);
      }
      return blnAllow;
    }
    helpsys.checkUserLevel = checkUserLevel;
    function getDefaultNamespace() {
      return "vex";//"std";
    }
    helpsys.getDefaultNamespace = getDefaultNamespace;
    function IsNameSpace(token) {
      return helpsys._help["Namespaces"].hasOwnProperty(token);
    }
    helpsys.IsNameSpace = IsNameSpace;
    function IsClass(namespace, token) {
      if (IsNameSpace(namespace))
        return helpsys._help["Namespaces"][namespace]["Classes"].hasOwnProperty(token);
      else
        return false;
    }
    function IsFile(namespace, token) {
      if (IsNameSpace(namespace))
        return helpsys._help["Namespaces"][namespace]["files"].hasOwnProperty(token);
      else
        return false;
    }
    helpsys.IsClass = IsClass;
    function IsMember(namespace, classname, token) {
      if (IsNameSpace(namespace) && IsClass(namespace, classname))
        return helpsys._help["Namespaces"][namespace]["Classes"][classname]["members"].hasOwnProperty(token);
      else
        false;
    }
    helpsys.IsMember = IsMember;

    function getJustClassName(fullName) {
      let ind = fullName.lastIndexOf("::");
      if (ind > 0) //coz we dont want to pull up the whole class list for just typing "::"
      {
        let arr = fullName.split("::");
        if (arr.length > 1)
          return arr[1];
        else
          arr[0];// double check
      }
      else
        return fullName;
    }
    helpsys.getJustClassName =  getJustClassName;
    function getNamespaces() {
      return Object.getOwnPropertyNames(helpsys._help["Namespaces"]);
    }
    let _Includes = { "namespaces": {} };
    _Includes["namespaces"]["vex"] = {};
    _Includes["namespaces"]["vex"]["classes"] = "*";
    _Includes["namespaces"]["vex"]["files"] = "*";
    _Includes["namespaces"]["std"] = {};
    _Includes["namespaces"]["std"]["classes"] = "*";
    _Includes["namespaces"]["std"]["files"] = "*";
    _Includes["files"] =[];
    function getIncludes() {
      //This should be from localcontext tokenzier
      //console.log(_Includes);
      return _Includes;
    }

    function setIncludes(includes) {
      _Includes["namespaces"]["std"] = {};
      _Includes["namespaces"]["std"]["classes"] = [];
      _Includes["namespaces"]["std"]["files"] = [];
      _Includes["files"] =[];
      let namespace = "std";
      for (let i = 0; i < includes.length; i++) {
        //special check for "robot-config.h" 
        if(includes[i].trim() == "robot-config.h"){
          _Includes["files"] = [includes[i].trim()];
        }
        if (IsClass(namespace, `${namespace}::${includes[i]}`) && !(_Includes["namespaces"][namespace]["classes"].includes(`${namespace}::${includes[i]}`))) {
          _Includes["namespaces"][namespace]["classes"].push(`${namespace}::${includes[i]}`);
        }
        else {
          //special condition cstdio = stdio.h 
          // to avoid duplicating DB entries
          if (includes[i] == "cstdio")
            includes[i] = "stdio.h";
          if (IsFile(namespace, includes[i]) && !(_Includes["namespaces"][namespace]["files"].includes(includes[i]))) {
            _Includes["namespaces"][namespace]["files"].push(includes[i]);
          }
        }
      }
      //
      //console.log(_Includes);
    }
    helpsys.setIncludes = setIncludes;
    
    let _Usings_Config = [];
    let _Usings_Code = [];
    function setUsings_Config(usings) {
      _Usings_Config = usings;
    }
    helpsys.setUsings_Config = setUsings_Config;
    function setUsings_Code(usings) {
      _Usings_Code = usings;
    }
    helpsys.setUsings_Code = setUsings_Code;
    function getUsings(cm) {
      if(cm && cm.options && cm.options.editorType && cm.options.editorType == "config")
        return _Usings_Config;
      let includes_ = getIncludes();
      //include usings from header only if robot-config.h is included
      if(includes_["files"] && includes_["files"].includes("robot-config.h"))
        return _Usings_Config.concat(_Usings_Code);
      else
        return _Usings_Code;
    }
    helpsys.getUsings = getUsings;
    function whichNamespace(memberName, optionalList, cm) {
      let foundnmpsc = undefined;
      if (optionalList == undefined) optionalList = getUsings(cm);
      for (let i = 0; i < optionalList.length; i++) {
        if (vex.helpsys.IsClass(optionalList[i], optionalList[i] + "::" + memberName) == true || vex.helpsys.IsNamespaceMember(optionalList[i], memberName)) {
          if (foundnmpsc) {
            console.log(`Naming conflict : ${memberName} found in multiple namespaces`)
            return foundnmpsc; // returning the first one found for now. TODO - needs to be fixed later
          }
          else {
            foundnmpsc = optionalList[i];
          }
        }
      }
      return foundnmpsc;
    }
    helpsys.whichNamespace = whichNamespace;
    function IsNamespaceMember(namespace, token) {
      if (IsNameSpace(namespace)) {
        let isdirectmem = helpsys._help["Namespaces"][namespace]["members"].hasOwnProperty(token);
        if (isdirectmem)
          return true;
        else {
          let files = getfileMembers(namespace);
          if (files)
            return files.includes(token);
          else
            return false;
        }
      }
      else
        false;
    }
    helpsys.IsNamespaceMember = IsNamespaceMember;
    function getfileMembers(namespace) {
      let nmspcArr = [];
      if (namespace == undefined) {
        nmspcArr = getNamespaces();
      }
      else {
        if (Array.isArray(namespace) == true)
          nmspcArr = namespace;
        else
          nmspcArr.push(namespace);
      }
      let classes = [];
      let includes = getIncludes();
      for (let i = 0; i < nmspcArr.length; i++) {
        //TODO: filter files based on includes
        if (includes["namespaces"][nmspcArr[i]]) {
          let inc_files = includes["namespaces"][nmspcArr[i]]["files"];
          if (Array.isArray(inc_files) == true) {
            for (let k = 0; k < inc_files.length; k++) {
              let _members = Object.getOwnPropertyNames(helpsys._help["Namespaces"][nmspcArr[i]]["files"][inc_files[k]]["members"]);
              classes = classes.concat(_members);
            }
          }
          else if (inc_files == "*") {
            let _files = Object.getOwnPropertyNames(helpsys._help["Namespaces"][nmspcArr[i]]["files"]);
            for (let j = 0; j < _files.length; j++) {
              let _members = Object.getOwnPropertyNames(helpsys._help["Namespaces"][nmspcArr[i]]["files"][_files[j]]["members"]);
              classes = classes.concat(_members);
            }
          }
        }
      }
      return (classes);
    }
    function getNamespaceMembers(namespace) {
      let nmspcArr = [];
      if (namespace == undefined || namespace == "*") {
        nmspcArr = getNamespaces();
      }
      else {
        if (Array.isArray(namespace) == true)
          nmspcArr = namespace;
        else
          nmspcArr.push(namespace);
      }
      let classes = [];
      let includes = getIncludes();
      for (let i = 0; i < nmspcArr.length; i++) {
        let _classes = [];
        ///
        //TODO: filter files based on includes
        if (includes["namespaces"][nmspcArr[i]]) {
          let inc_classes = includes["namespaces"][nmspcArr[i]]["classes"];
          if (Array.isArray(inc_classes) == true) {
            for (let k = 0; k < inc_classes.length; k++) {
              if (helpsys._help["Namespaces"][nmspcArr[i]]["Classes"].hasOwnProperty(inc_classes[k]))
                classes = classes.concat(inc_classes[k]);
            }
          }
          else if (inc_classes == "*") {
            _classes = Object.getOwnPropertyNames(helpsys._help["Namespaces"][nmspcArr[i]]["Classes"]);
          }
        }
        ///
        //let _classes = Object.getOwnPropertyNames(helpsys._help["Namespaces"][nmspcArr[i]]["Classes"]);
        let _globals = Object.getOwnPropertyNames(helpsys._help["Namespaces"][nmspcArr[i]]["members"]);
        //filtering namespace member functions based apilevel
        let _globals_final = [];
        for (let _gi = 0; _gi < _globals.length; _gi++) {
          let _gi_kind = helpsys._help["Namespaces"][nmspcArr[i]]["members"][_globals[_gi]].kind;
          if (_gi_kind == "function") {
            let _gi_apilevel = helpsys._help["Namespaces"][nmspcArr[i]]["members"][_globals[_gi]].apilevel;
            if (_gi_apilevel && checkUserLevel(_gi_apilevel)) {
              _globals_final.push(_globals[_gi]);
            }
          } else {
            _globals_final.push(_globals[_gi]);
          }
        }

        classes = classes.concat(_classes, _globals_final);

      }

      return (classes);
    }
    helpsys.names = getNamespaceMembers;
    /**
     * lookup tooltip for function
     */
    function lookupAll(className, memberName, namespace, enumName) {
      let ret = undefined;
      let included = getIncludes();
      if (namespace == undefined) {
        let nms = Object.getOwnPropertyNames(included["namespaces"]);
        for (let i = 0; i < nms.length; i++) {
          let nmsp = nms[i];
          ret = lookup(className, memberName, nmsp, enumName);
          if (ret == undefined && (className == undefined || className == "")) {
            let files = included["namespaces"][nmsp]["files"];
            if (Array.isArray(files) == true) {
              for (let j = 0; j < files.length; j++) {
                ret = lookup(className, memberName, nmsp, enumName, files[j]);
                if (ret)
                  return ret;
              }
            } else {
              //todo for All
            }
          }
          if (ret)
            return ret;
        }
      }
      else {
        ret = lookup(className, memberName, namespace, enumName);
        if (ret == undefined && (className == undefined || className == "")) {
          let files;
          if(included["namespaces"][namespace])
            files = included["namespaces"][namespace]["files"];
          if (Array.isArray(files) == true) {
            for (let j = 0; j < files.length; j++) {
              ret = lookup(className, memberName, namespace, enumName, files[j]);
              if (ret)
                return ret;
            }
          } else {
            //todo for All
          }
        }
      }

      return ret;
    }
    function lookup(className, memberName, namespace, enumName, filename) {
      if (namespace == undefined)
        namespace = getDefaultNamespace();
      if (namespace != undefined) {
        if (helpsys._help["Namespaces"][namespace]) {
          if (className) {
            if (helpsys._help["Namespaces"][namespace]["Classes"][className]) {
              if (memberName != undefined) {
                var item = helpsys._help["Namespaces"][namespace]["Classes"][className]["members"];
                if (item !== undefined)
                  return (item[memberName]);
                else
                  return (undefined);
              }
              else
                return helpsys._help["Namespaces"][namespace]["Classes"][className];
            }
            else
              return (undefined);
          }
          else {
            if (memberName) {
              if (enumName) {
                let enumV = helpsys._help["Namespaces"][namespace]["members"][memberName]["enumvalue"];
                for (let e = 0; e < enumV.length; e++) {
                  if (enumV[e].name == enumName)
                    return enumV[e];
                }
              }
              else {
                if (filename) {
                  let file = helpsys._help["Namespaces"][namespace]["files"][filename];
                  if (file) {
                    if (file["members"][memberName])
                      return file["members"][memberName];
                  }
                  else
                    return undefined;
                }
                else
                  return helpsys._help["Namespaces"][namespace]["members"][memberName];
              }
            }
            else
              return helpsys._help["Namespaces"][namespace];
          }
        }
        else
          return (undefined);
      }
      else
        console.log("Not enough information to lookup!");
    }
    helpsys.lookup = lookupAll;
    //TODO : pass namespace and create another overload for namespace member lookup
    //isStatic can be re-used for namespacemember listing
    function getMembers(className, isStatic, namespace, memberName) {
      if (namespace == undefined)
        namespace = getDefaultNamespace();
      else if (className == undefined || className.trim() == "") {
        if (IsNameSpace(namespace)) {
          if (memberName == undefined || memberName == "") {
            let mems = getNamespaceMembers(namespace);
            let obj = {};
            for (let i = 0; i < mems.length; i++) {
              //filtering classes based on language mode selected
              let is_needed = true;
              if(IsClass(namespace,mems[i])){
                let mnspc_member_apilevel = helpsys._help["Namespaces"][namespace]["Classes"][mems[i]].apilevel;
                is_needed = checkUserLevel(mnspc_member_apilevel);
              }
              if (is_needed == true)
                obj[getJustClassName(mems[i])] = true;
            }
            let files = getfileMembers(namespace);
            for (let i = 0; i < files.length; i++) {
              obj[getJustClassName(files[i])] = true;
            }
            return Object.getOwnPropertyNames(obj);
          }
          else if (IsNamespaceMember(namespace, memberName)) {
            let m = helpsys._help["Namespaces"][namespace]["members"][memberName];
            if (m.kind == "enum") {
              let ev = m.enumvalue;
              let evm = [];
              for (let j = 0; j < ev.length; j++) {
                evm.push(ev[j].name);
              }
              return evm;
            }
            else return "";
          }
        }
        else
          return "";
      }

      if (helpsys._help["Namespaces"][namespace]["Classes"][className] != undefined && helpsys._help["Namespaces"][namespace]["Classes"][className]["members"] != undefined) {
        let membernames = Object.getOwnPropertyNames(helpsys._help["Namespaces"][namespace]["Classes"][className]["members"]);
        let memberlistfinal = [];
        for (let i = 0; i < membernames.length; i++) {
          let cmember = helpsys._help["Namespaces"][namespace]["Classes"][className]["members"][membernames[i]];
          let memberapilevel;
          if (cmember.kind == "function") {
            if (cmember.specialkind && cmember.specialkind == "constructor")
              continue;
            memberapilevel = cmember.apilevel;
          } else {
            memberapilevel = cmember.apilevel;
          }

          let static = helpsys._help["Namespaces"][namespace]["Classes"][className]["members"][membernames[i]].static;
          if (checkUserLevel(memberapilevel)) {
            if (isStatic == true) {
              if (static == true)
                memberlistfinal.push(membernames[i]);
            }
            else {
              if (static != true)
                memberlistfinal.push(membernames[i]);
            }
          }
        }
        return memberlistfinal;
      }
      else
        return "";
    }
    function getMembersAll(className, isStatic, namespace, memberName) {
      let ret = "";
      if (namespace == undefined) {
        let included = getIncludes();
        let nms = Object.getOwnPropertyNames(included["namespaces"]);
        for (let i = 0; i < nms.length; i++) {
          let nmsp = nms[i];
          ret = getMembers(className, isStatic, nmsp, memberName);
          if (ret != "")
            return ret;
        }
      }
      else
        return getMembers(className, isStatic, namespace, memberName);
      return ret;
    }
    helpsys.getMembers = getMembersAll;
    //Global Context
    let _GlobalContext = {};
    let _GlobalContextUserDefs = {};
    function getGlobalContext() {
      return _GlobalContext;
    }
    helpsys.getGlobalContext = getGlobalContext;

    function updateGlobalContext(objmap, userdefmap) {
      _GlobalContext = Object.assign({}, objmap);
      _GlobalContextUserDefs = Object.assign({}, userdefmap);
    }
    helpsys.updateGlobalContext = updateGlobalContext;
    //Local Context
    let _LocalContext = {};
    let _LocalContextUserDefs = {};
    function getLocalContext() {
      return _LocalContext;
    }
    helpsys.getLocalContext = getLocalContext;

    function updateLocalContext(objmap, userdefmap) {
      _LocalContext = Object.assign({}, objmap);
      _LocalContextUserDefs = Object.assign({}, userdefmap);
    }
    helpsys.updateLocalContext = updateLocalContext;

    function getAllContext() {
      let includes_ = getIncludes();
      //include global header objects if robot-config.h is included
      if(includes_["files"] && includes_["files"].includes("robot-config.h"))
        return Object.assign({}, _GlobalContext, _LocalContext);
      
      return _LocalContext;
    }
    helpsys.getAllContext = getAllContext;
    //checks only userdefined primitive type variables and returns type info
    //TODO: This will be merged later with getType.
    function getUserDefinedType(token){
      if (_LocalContextUserDefs && _LocalContextUserDefs[token]) {
        return _LocalContextUserDefs[token].kind;
      }
      let includes_ = getIncludes();
      if (includes_["files"] && includes_["files"].includes("robot-config.h")) {
        if (_GlobalContextUserDefs && _GlobalContextUserDefs[token]) {
          return _GlobalContextUserDefs[token].kind;
        }
      }
      return undefined;
    }
    helpsys.getUserDefinedType = getUserDefinedType;
    function getType(token) {
      if (_LocalContext && _LocalContext[token]) {
        return _LocalContext[token].className;
      }
      let includes_ = getIncludes();
      if (includes_["files"] && includes_["files"].includes("robot-config.h")) {
        if (_GlobalContext && _GlobalContext[token]) {
          return _GlobalContext[token].className;
        }
      }
      return undefined;
    }
    helpsys.getType = getType;
    /**
     * Create the help widget for codemirror
     */
    function createToolTip(word, statement, description, params, paramIndex) {
      var str = '<div class = "itoolTip">'
      str += '<table>'
      str += '<tr><td class="itoolTip_definition"><span class="itoolTip_word">'
      str += word + '</span>'
      if (statement) {
        str += ' - <span class="itoolTip_statement">'
        str += statement + '</span>'
      }
      str += '</td></tr>'
      if (description) {
        str += '<tr><td class = "itoolTip_description">'
        str += description + '</td></tr>'
      }
      if (params && params.length > 0) {

        let pstr = "";
        for (let i = 0; i < params.length; i++) {
          if (params[i].declname && params[i].desc && params[i].desc.trim() != "") {
            pstr += `<b>${params[i].declname}</b> - ${params[i].desc}</br>`
          }
        }
        if (pstr.trim() != "") {
          str += '<tr><td class = "itoolTip_description">';
          str += pstr;
          str += '</td></tr>';
        }

      }
      str += '</table>'
      str += '</div>'
      return str;
      /* var div = document.createElement("div");
       div.innerHTML = str;
       return div;*/

    }
    function showTooltip(item, overloadParams) {
      //var para = item.tooltip.replace(/\n/g, '<br>');

      let desc = "";
      let def = "";
      let params = [];
      if (item.kind == "function") {
        //todo :  implement overloads
        if (item.overloads.length > 0) {
          if (overloadParams != undefined) {
            for (let j = 0; j < item.overloads.length; j++) {
              let isMatch = false;
              if (overloadParams.args.length > 0) {
                for (let i = 0; i < overloadParams.args.length; i++) {
                  if (overloadParams.args[i].type == item.overloads[j].params[i].type) {
                    isMatch = true;
                  }
                  else
                    isMatch = false;
                }
              }
              else {
                if (overloadParams.argsstring == item.overloads[j].argsstring)
                  isMatch = true;
              }
              if (isMatch) {
                //
                let argstring = item.overloads[j].argsstring;
                let justargs = argstring.replace("(", "").replace(")", "");
                let splt = justargs.split(",");
                let position = (overloadParams.argindx != undefined) ? overloadParams.argindx : -1;
                for (let i = 0; i < splt.length; i++) {
                  if ((i) == position) {
                    if (splt[i]) {
                      //splt[i] = "&lt;b&gt;" + splt[i] + "&lt;/b&gt;"
                      splt[i] = "<u><b>" + splt[i] + "</b></u>"
                    }
                  }
                }
                let dps = "(" + splt.join() + ")";
                //
                def = item.def + dps + "\n";
                desc = item.overloads[j].desc;
                params = item.overloads[j].params;
              }
            }
          }
          else {
            if (item.overloads.length > 1)
              def = item.def + item.overloads[0].argsstring + `+ ${item.overloads.length - 1} overload`;
            else
              def = item.def + item.overloads[0].argsstring;
            desc = item.overloads[0].desc;
            params = item.overloads[0].params;
          }

        }
      }
      else {
        def = item.def;
        desc = item.desc
      }

      def = (def) ? def.replace(new RegExp('\r?\n', 'g'), '<br />') : "";
      desc = (desc) ? desc.replace(new RegExp('\r?\n', 'g'), '<br />') : "";
      // create help widget div
      var help = createToolTip(item.name, def, desc, params);

      return (help);
    }
    helpsys.showTooltip = showTooltip;
    function _readJSONFile(file_url) {
      return new Promise(async (resolve, reject) => {
        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', file_url, true);
        xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            resolve(JSON.parse(xobj.responseText));
          }
        };
        xobj.onerror = reject;
        xobj.send(null);
      })
    }

  })(helpsys = vex.helpsys || (vex.helpsys = {}));
})(vex || (vex = {}));
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";
  
  //loading vex help db for autocomplete
  //console.log("Clike loading helpsys db");
  /*setTimeout(function() {
    vex.helpsys.init();
  },1000);*/
  
  function Context(indented, column, type, info, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.info = info;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type, info) {
    var indent = state.indented;
    if (state.context && state.context.type == "statement" && type != "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, info, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }
  
  function typeBefore(stream, state, pos) {
    if (state.prevToken == "variable" || state.prevToken == "type") return true;
    if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos))) return true;
    if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;
  }
  
  function isTopScope(context) {
    for (;;) {
      if (!context || context.type == "top") return true;
      if (context.type == "}" && context.prev.info != "namespace") return false;
      context = context.prev;
    }
  }
  
  CodeMirror.defineMode("clike", function(config, parserConfig) {
    console.log("Clike loading helpsys db");
    vex.helpsys.init();
    var indentUnit = config.indentUnit,
        statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
        dontAlignCalls = parserConfig.dontAlignCalls,
        keywords = parserConfig.keywords || {},
        types = parserConfig.types || {},
        builtin = parserConfig.builtin || {},
        blockKeywords = parserConfig.blockKeywords || {},
        defKeywords = parserConfig.defKeywords || {},
        atoms = parserConfig.atoms || {},
        hooks = parserConfig.hooks || {},
        multiLineStrings = parserConfig.multiLineStrings,
        indentStatements = parserConfig.indentStatements !== false,
        indentSwitch = parserConfig.indentSwitch !== false,
        namespaceSeparator = parserConfig.namespaceSeparator,
        isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
        numberStart = parserConfig.numberStart || /[\d\.]/,
        number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
        isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/,
        isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/;

    var curPunc, isDefKeyword;
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (isPunctuationChar.test(ch)) {
        curPunc = ch;
        //clear the context array because we only track the members for styling purpose
        let currentVar_ = stream.current();
        //console.log(currentVar_);
        if (currentVar_.match(/[\[\]{}\(\),;]/, false)) {/*console.log(_contextArray);*/_contextArray = []; }
        return null;
      }
      if (numberStart.test(ch)) {
        stream.backUp(1)
        if (stream.match(number)) return "number"
        stream.next()
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (isOperatorChar.test(ch)) {
        while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar)) {}
        return "operator";
      }
      stream.eatWhile(isIdentifierChar);
      if (namespaceSeparator) while (stream.match(namespaceSeparator))
        stream.eatWhile(isIdentifierChar);
  
      var cur = stream.current();
      if (contains(keywords, cur)) {
        if (contains(blockKeywords, cur)) curPunc = "newstatement";
        if (contains(defKeywords, cur)) isDefKeyword = true;
        return "keyword";
      }
      if (contains(types, cur)) return "type";
      if (contains(builtin, cur)) {
        if (contains(blockKeywords, cur)) curPunc = "newstatement";
        return "builtin";
      }
      if (contains(atoms, cur)) return "atom";

      let style_ = resolveBuiltins(stream,"variable");
      style_ = resolveUserDefVariables(stream,style_);
      return style_;
      //return "variable";
    }
    //
    function resolveUserDefVariables(stream, style) {
      let currentVar_ = stream.current();
      if (style === "variable") {
        let currentVar = stream.current();
        let kind = vex.helpsys.getUserDefinedType(currentVar);
        if (kind) {
          if(kind=="variable")
            style = "user";
          else if(kind=="function")
            style = "def";
        }
      }
      return style;
    }
    //
    let _contextArray = [];
    function resolveBuiltins(stream,style){
      let currentVar_ = stream.current();
      if (style === "variable" || style === "builtin") {
        let currentVar = stream.current();
        let className = vex.helpsys.getType(currentVar);
        let memberType;
        if (className) {
          style = "instance";
        }
        else {
          if (_contextArray.length > 0) {
            if (_contextArray[_contextArray.length - 1] && _contextArray[_contextArray.length - 1].className) {
              let _tmp_nmspcName = vex.helpsys.getDefaultNamespace();
              let _tmp_className = _contextArray[_contextArray.length - 1].className;
              let memberInfo = vex.helpsys.lookup(_tmp_className, currentVar, _tmp_nmspcName);
              //console.log(memberInfo);
              if (memberInfo != undefined) {
                if (memberInfo.drawercat == "instance") {
                  className = memberInfo.type[0];
                  style = "instance";
                }
                if (memberInfo.drawercat == "sensing") style = "sensing";
                if (memberInfo.drawercat == "action") style = "action";
                if (memberInfo.drawercat == "setting") style = "setting";
              }
            }
          }
        }
        _contextArray.push({ "instanceName": currentVar, "className": className });
      }
      return style;
    }
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) {end = true; break;}
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings))
          state.tokenize = null;
        return "string";
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = null;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }
    function maybeEOL(stream, state) {
      if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
        state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)
    }
    // Interface
    return {
      startState: function(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", null, false),
          indented: 0,
          startOfLine: true,
          prevToken: null
        };
      },
  
      token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) { maybeEOL(stream, state); return null; }
        curPunc = isDefKeyword = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment" || style == "meta") return style;
        if (ctx.align == null) ctx.align = true;
  
        if (curPunc == ";" || curPunc == ":" || (curPunc == "," && stream.match(/^\s*(?:\/\/.*)?$/, false)))
          while (state.context.type == "statement") popContext(state);
        else if (curPunc == "{") pushContext(state, stream.column(), "}");
        else if (curPunc == "[") pushContext(state, stream.column(), "]");
        else if (curPunc == "(") pushContext(state, stream.column(), ")");
        else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        }
        else if (curPunc == ctx.type) popContext(state);
        else if (indentStatements &&
                 (((ctx.type == "}" || ctx.type == "top") && curPunc != ";") ||
                  (ctx.type == "statement" && curPunc == "newstatement"))) {
          pushContext(state, stream.column(), "statement", stream.current());
        }
  
        if (style == "variable" &&
            ((state.prevToken == "def" ||
              (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&
               isTopScope(state.context) && stream.match(/^\s*\(/, false)))))
          style = "def";
  
        if (hooks.token) {
          var result = hooks.token(stream, state, style);
          if (result !== undefined) style = result;
        }
  
        if (style == "def" && parserConfig.styleDefs === false) style = "variable";
  
        state.startOfLine = false;
        state.prevToken = isDefKeyword ? "def" : style || curPunc;
        maybeEOL(stream, state);
        return style;
      },
  
      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return CodeMirror.Pass;
        var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
        if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
        if (parserConfig.dontIndentStatements)
          while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
            ctx = ctx.prev
        if (hooks.indent) {
          var hook = hooks.indent(state, ctx, textAfter);
          if (typeof hook == "number") return hook
        }
        var closing = firstChar == ctx.type;
        var switchBlock = ctx.prev && ctx.prev.info == "switch";
        if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
          while (ctx.type != "top" && ctx.type != "}") ctx = ctx.prev
          return ctx.indented
        }
        if (ctx.type == "statement")
          return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
        if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
          return ctx.column + (closing ? 0 : 1);
        if (ctx.type == ")" && !closing)
          return ctx.indented + statementIndentUnit;
  
        return ctx.indented + (closing ? 0 : indentUnit) +
          (!closing && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? indentUnit : 0);
      },
  
      electricInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      blockCommentContinue: " * ",
      lineComment: "//",
      fold: "brace"
    };
  });
  
    function words(str) {
      var obj = {}, words = str.split(" ");
      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
      return obj;
    }
    function contains(words, word) {
      if (typeof words === "function") {
        return words(word);
      } else {
        return words.propertyIsEnumerable(word);
      }
    }
    var cKeywords = "auto if break case register continue return default do sizeof " +
      "static else struct switch extern typedef union for goto while enum const volatile";
    var cTypes = "int long char short double float unsigned signed void size_t ptrdiff_t";
  
    function cppHook(stream, state) {
      if (!state.startOfLine) return false
      for (var ch, next = null; ch = stream.peek();) {
        if (ch == "\\" && stream.match(/^.$/)) {
          next = cppHook
          break
        } else if (ch == "/" && stream.match(/^\/[\/\*]/, false)) {
          break
        }
        stream.next()
      }
      state.tokenize = next
      return "meta"
    }
  
    function pointerHook(_stream, state) {
      if (state.prevToken == "type") return "type";
      return false;
    }
  
    function cpp14Literal(stream) {
      stream.eatWhile(/[\w\.']/);
      return "number";
    }
  
    function cpp11StringHook(stream, state) {
      stream.backUp(1);
      // Raw strings.
      if (stream.match(/(R|u8R|uR|UR|LR)/)) {
        var match = stream.match(/"([^\s\\()]{0,16})\(/);
        if (!match) {
          return false;
        }
        state.cpp11RawStringDelim = match[1];
        state.tokenize = tokenRawString;
        return tokenRawString(stream, state);
      }
      // Unicode strings/chars.
      if (stream.match(/(u8|u|U|L)/)) {
        if (stream.match(/["']/, /* eat */ false)) {
          return "string";
        }
        return false;
      }
      // Ignore this hook.
      stream.next();
      return false;
    }
  
    function cppLooksLikeConstructor(word) {
      var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
      return lastTwo && lastTwo[1] == lastTwo[2];
    }
  
    // C#-style strings where "" escapes a quote.
    function tokenAtString(stream, state) {
      var next;
      while ((next = stream.next()) != null) {
        if (next == '"' && !stream.eat('"')) {
          state.tokenize = null;
          break;
        }
      }
      return "string";
    }
  
    // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
    // <delim> can be a string up to 16 characters long.
    function tokenRawString(stream, state) {
      // Escape characters that have special regex meanings.
      var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
      var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
      if (match)
        state.tokenize = null;
      else
        stream.skipToEnd();
      return "string";
    }
  
    function def(mimes, mode) {
      if (typeof mimes == "string") mimes = [mimes];
      var words = [];
      function add(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
          words.push(prop);
      }
      add(mode.keywords);
      add(mode.types);
      add(mode.builtin);
      add(mode.atoms);
      if (words.length) {
        mode.helperType = mimes[0];
        CodeMirror.registerHelper("hintWords", mimes[0], words);
      }
  
      for (var i = 0; i < mimes.length; ++i)
        CodeMirror.defineMIME(mimes[i], mode);
    }
    def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
      name: "clike",
      keywords: words(cKeywords),
      types: words(cTypes + " bool _Complex _Bool float_t double_t intptr_t intmax_t " +
                   "int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t " +
                   "uint32_t uint64_t"),
      blockKeywords: words("case do else for if switch while struct"),
      defKeywords: words("struct"),
      typeFirstDefinitions: true,
      atoms: words("NULL true false"),
      hooks: {"#": cppHook, "*": pointerHook},
      modeProps: {fold: ["brace", "include"]}
    });
  
    def(["text/x-c++src", "text/x-c++hdr"], {
      name: "clike",
      keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try explicit new " +
                      "static_cast typeid catch operator template typename class friend private " +
                      "this using const_cast inline public throw virtual delete mutable protected " +
                      "alignas alignof constexpr decltype nullptr noexcept thread_local final " +
                      "static_assert override"),
      types: words(cTypes + " bool wchar_t"),
      blockKeywords: words("catch class do else finally for if struct switch try while"),
      defKeywords: words("class namespace struct enum union"),
      typeFirstDefinitions: true,
      atoms: words("true false NULL"),
      dontIndentStatements: /^template$/,
      isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
      hooks: {
        "#": cppHook,
        "*": pointerHook,
        "u": cpp11StringHook,
        "U": cpp11StringHook,
        "L": cpp11StringHook,
        "R": cpp11StringHook,
        "0": cpp14Literal,
        "1": cpp14Literal,
        "2": cpp14Literal,
        "3": cpp14Literal,
        "4": cpp14Literal,
        "5": cpp14Literal,
        "6": cpp14Literal,
        "7": cpp14Literal,
        "8": cpp14Literal,
        "9": cpp14Literal,
        token: function(stream, state, style) {
          if (style == "variable" && stream.peek() == "(" &&
              (state.prevToken == ";" || state.prevToken == null ||
               state.prevToken == "}") &&
              cppLooksLikeConstructor(stream.current()))
            return "def";
        }
      },
      namespaceSeparator: "::",
      modeProps: {fold: ["brace", "include"]}
    });
    function tokenTripleString(stream, state) {
      var escaped = false;
      while (!stream.eol()) {
        if (!escaped && stream.match('"""')) {
          state.tokenize = null;
          break;
        }
        escaped = stream.next() == "\\" && !escaped;
      }
      return "string";
    }
  
    function tokenNestedComment(depth) {
      return function (stream, state) {
        var ch
        while (ch = stream.next()) {
          if (ch == "*" && stream.eat("/")) {
            if (depth == 1) {
              state.tokenize = null
              break
            } else {
              state.tokenize = tokenNestedComment(depth - 1)
              return state.tokenize(stream, state)
            }
          } else if (ch == "/" && stream.eat("*")) {
            state.tokenize = tokenNestedComment(depth + 1)
            return state.tokenize(stream, state)
          }
        }
        return "comment"
      }
    }

    function tokenKotlinString(tripleString){
      return function (stream, state) {
        var escaped = false, next, end = false;
        while (!stream.eol()) {
          if (!tripleString && !escaped && stream.match('"') ) {end = true; break;}
          if (tripleString && stream.match('"""')) {end = true; break;}
          next = stream.next();
          if(!escaped && next == "$" && stream.match('{'))
            stream.skipTo("}");
          escaped = !escaped && next == "\\" && !tripleString;
        }
        if (end || !tripleString)
          state.tokenize = null;
        return "string";
      }
    }
    // Ceylon Strings need to deal with interpolation
    var stringTokenizer = null;
    function tokenCeylonString(type) {
      return function(stream, state) {
        var escaped = false, next, end = false;
        while (!stream.eol()) {
          if (!escaped && stream.match('"') &&
                (type == "single" || stream.match('""'))) {
            end = true;
            break;
          }
          if (!escaped && stream.match('``')) {
            stringTokenizer = tokenCeylonString(type);
            end = true;
            break;
          }
          next = stream.next();
          escaped = type == "single" && !escaped && next == "\\";
        }
        if (end)
            state.tokenize = null;
        return "string";
      }
    }

    
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function (cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = { hint: getHints };
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function (options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections()
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function () { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
    return setTimeout(fn, 1000 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function () {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function () {
      return this.cm.state.completionActive == this;
    },

    pick: function (data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else if(data.donotcomplete==undefined)   
        this.cm.replaceRange(getText(completion), completion.from || data.from,
        completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function () {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
        pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
        (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function () { self.update(); });
        if (this.widget) this.widget.disable();
      }
    },

    update: function (first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function (data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function (data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      if (data && this.data && isNewCompletion(this.data, data)) return;
      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function isNewCompletion(old, nw) {
    var moved = CodeMirror.cmpPos(nw.from, old.from)
    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch
  }

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function () { handle.moveFocus(-1); },
      Down: function () { handle.moveFocus(1); },
      PageUp: function () { handle.moveFocus(-handle.menuSize() + 1, true); },
      PageDown: function () { handle.moveFocus(handle.menuSize() - 1, true); },
      Home: function () { handle.setFocus(0); },
      End: function () { handle.setFocus(handle.length - 1); },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function (cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;

    var hints = this.hints = document.createElement("ul");
    hints.className = "CodeMirror-hints";
    this.selectedHint = data.selectedHint || 0;

    var tip = this.tip = document.createElement("div");
    tip.className = "CodeMirror-hints";

    var completions = data.list;
    tip.innerHTML = GetToolTipElement(getText(completions[this.selectedHint]),cm);
    //console.log(tip.innerHTML);
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else //elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      { 
        let el = document.createElement("div");
        el.innerHTML = "<div>"+ (cur.displayText || getText(cur))+"</div>";
        elt.appendChild(el);
      }
      elt.hintId = i;
      elt["ToolTipKey"] = getText(cur);
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    left = left+ (CodeMirror.HintOffsetX);
    top = top + (CodeMirror.HintOffsetY);
    hints.style.left = left + "px";
    hints.style.top = top + "px";


    tip.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    if(CodeMirror.Editor_X_Max) winW = CodeMirror.Editor_X_Max + CodeMirror.HintOffsetX;
    if(CodeMirror.Editor_Y_Max) winH = CodeMirror.Editor_Y_Max + CodeMirror.HintOffsetY;
    (completion.options.container || document.body).appendChild(hints);
    if(tip.innerHTML)
      (completion.options.container || document.body).appendChild(tip);
    var box = hints.getBoundingClientRect(), limit_bottom=box.bottom +20, overlapY = limit_bottom +20 - winH + CodeMirror.HintOffsetY;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = limit_bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        tip.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top + CodeMirror.HintOffsetY) + "px";
        tip.style.height = (winH - 5) + "px";
        tip.style.top = (top = pos.bottom - box.top + CodeMirror.HintOffsetY) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          tip.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    let limit_right  = box.right + 300;
    var overlapX = limit_right - winW + CodeMirror.HintOffsetX;
    if (overlapX > 0) {
      if (limit_right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        tip.style.width = (winW - 5) + "px";
        overlapX -= (limit_right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX + CodeMirror.HintOffsetX) + "px";
      tip.style.left = (left = pos.left - overlapX + CodeMirror.HintOffsetX) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    tip.style.left = hints.offsetWidth + left + "px";
    // document.body.appendChild(tip);
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function (n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function (n) { widget.changeActive(n); },
      menuSize: function () { return widget.screenAmount(); },
      length: completions.length,
      close: function () { completion.close(); },
      pick: function () { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function () { closingOnBlur = setTimeout(function () { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function () { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function () {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
      tip.style.top = newTop + "px";
    });

    CodeMirror.on(hints, "dblclick", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) { widget.changeActive(t.hintId); widget.pick(); }
    });

    CodeMirror.on(hints, "click", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function () {
      setTimeout(function () { cm.focus(); }, 20);
    });

    CodeMirror.signal(data, "select", completions[0], hints.firstChild);
    return true;
  } 

  Widget.prototype = {
    close: function () {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      if(this.tip.parentNode) this.tip.parentNode.removeChild(this.tip);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function () {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = { Enter: function () { widget.picked = true; } };
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function () {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function (i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      this.tip.innerHTML = GetToolTipElement(this.hints.childNodes[i].ToolTipKey);
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);

    },

    screenAmount: function () {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function (cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function (result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function (cm) { return CodeMirror.hint.fromList(cm, { words: words }) }
    } else if (CodeMirror.hint.anyword) {
      return function (cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function () { }
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function (cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var to = CodeMirror.Pos(cur.line, token.end);
    if (token.string && /\w/.test(token.string[token.string.length - 1])) {
      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);
    } else {
      var term = "", from = to;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return { list: found, from: from, to: to };
  });

  CodeMirror.commands.autocomplete = ShowHintDropDown;//CodeMirror.showHint;
  CodeMirror._IsAutoCompleteOn =true;
  CodeMirror._IsToolTipOn =true;
  CodeMirror.HintOffsetX = 0;
  CodeMirror.HintOffsetY = 0;
  CodeMirror.Editor_X_Max = undefined;//1200;
  CodeMirror.Editor_Y_Max = undefined;//800;
  CodeMirror.LanguageMode = undefined;
  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
/*****************************-* Editor Keymap for hints *-****************************************************/
CodeMirror.InitializeAutoComplete = function InitializeAutoComplete(cm,options) {
  console.log("Initializing Auto-complete feature..");
  console.log(`version : ${get_CM_CPP_AC_Version()}`);

  if (options) {
    //set hint options
    if (options["hint"]) {
      if (options["hint"]["offsetx"]) CodeMirror.HintOffsetX = Number(options["hint"]["offsetx"]);
      if (options["hint"]["offsety"]) CodeMirror.HintOffsetY = Number(options["hint"]["offsety"]);
      if (options["hint"]["editormaxx"]) CodeMirror.Editor_X_Max = Number(options["hint"]["editormaxx"]);
      if (options["hint"]["editormaxy"]) CodeMirror.Editor_Y_Max = Number(options["hint"]["editormaxy"]);
    }
  }
 //below logs re for debugging purpose
 let ___d_winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
 let ___d_winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
 console.log(`winW = ${___d_winW}`);
 console.log(`winH = ${___d_winH}`);
 console.log(`offsetX = ${CodeMirror.HintOffsetX}`);
 console.log(`offsetY = ${CodeMirror.HintOffsetY}`);
 //////////

  var ExcludedIntelliSenseTriggerKeys =
    {
      "8": "delete",
      "16": "shift",
      "17": "ctrl",
      "18": "alt",
      "19": "pause",
      "20": "capslock",
      "27": "escape",
      "33": "pageup",
      "34": "pagedown",
      "35": "end",
      "36": "home",
      "37": "left",
      "39": "right",
      "38": "up",
      "40": "down",
      "45": "insert",
      "91": "left window key",
      "92": "right window key",
      "93": "select",
      "107": "add",
      "109": "subtract",
      "110": "decimal point",
      "111": "divide",
      "112": "f1",
      "113": "f2",
      "114": "f3",
      "115": "f4",
      "116": "f5",
      "117": "f6",
      "118": "f7",
      "119": "f8",
      "120": "f9",
      "121": "f10",
      "122": "f11",
      "123": "f12",
      "144": "numlock",
      "145": "scrolllock",
      "186": "semicolon"
    }
    var CombinationKeys =
    {
      "17": "ctrl",
      "18": "alt",
      "91": "left window key",
      "92": "right window key"
    }
  let isSpecialKeyDown = false;
  let specialKeyTimeOut;
  cm.on("keydown", function (cm, event) {
    if(CombinationKeys[(event.keyCode).toString()] != undefined)
      {
        if(specialKeyTimeOut) {
          clearTimeout(specialKeyTimeOut);
        }
        isSpecialKeyDown = true;
      }
  });
  let lastTypedCHar;
  //this is to handle if user releases shift key first in an attempt to type ":"
  //In that case event.shiftKey will be false so it will not show popup as per the old logic
  cm.on("keypress", function (cm, event) {
    lastTypedCHar = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
  });
  cm.on("keyup", function (cm, event) {
    if(CombinationKeys[(event.keyCode).toString()] != undefined){
      specialKeyTimeOut = setTimeout(function(){ 
         isSpecialKeyDown = false;
        }, 1000);
    }       
    var __Cursor = cm.getDoc().getCursor();
    var __Token = cm.getTokenAt(__Cursor);
    //period or colon
    if (event.keyCode == 190 || (event.keyCode == 186 && event.shiftKey == true)|| (event.keyCode == 186 && lastTypedCHar ==":")) {
      CodeMirror.commands.autocomplete(cm,true);
    }
    else if (
      ExcludedIntelliSenseTriggerKeys[(event.keyCode).toString()] == undefined
      && isSpecialKeyDown == false
    ) {
      CodeMirror.commands.autocomplete(cm,true);
    }
  });
}
CodeMirror.UpdateSettings = function UpdateSettings(cm,options) {
  console.log("Updating CPPEditor settings..");
  console.log(options);
  if (options) {
    //set hint options
    if (options["hint"]) {
      if (options["hint"]["offsetx"]) CodeMirror.HintOffsetX = Number(options["hint"]["offsetx"]);
      if (options["hint"]["offsety"]) CodeMirror.HintOffsetY = Number(options["hint"]["offsety"]);
      if (options["hint"]["editormaxx"]) CodeMirror.Editor_X_Max = Number(options["hint"]["editormaxx"]);
      if (options["hint"]["editormaxy"]) CodeMirror.Editor_Y_Max = Number(options["hint"]["editormaxy"]);
    }
  }
}
///////////
CodeMirror.ToggleAutoComplete = function ToggleAutoComplete(enable) {
  if(enable == true || enable == false)
    CodeMirror._IsAutoCompleteOn =enable;
};
CodeMirror.IsAutoCompleteOn = function DisableAutoComplete() {
  return CodeMirror._IsAutoCompleteOn;
};
///////////
CodeMirror.ToggleToolTip = function ToggleToolTip(enable) {
  if(enable == true || enable == false)
    CodeMirror._IsToolTipOn =enable;
};
CodeMirror.IsToolTipOn = function DisableAutoComplete() {
  return CodeMirror._IsToolTipOn;
};

/*********************************************************************************/
let __namespace;
let __globalContext;
let __context;
let __member;
let __arguments;
let __enum;
let __visionSensorContexts = {}; //vision contexts - key as instance name
let __visionCodeContexts = {};

function CheckIfVEXClassMember(source, variable) {
  let targetInstance = variable;
  let targetClass = "null";
  let semiSplit = source.split(';');
  for (let i = 0; i < semiSplit.length; i++) {
    //Split by spaces
    let spaceSplit = semiSplit[i].split(' ');
    for (let j = spaceSplit.length - 1; j >= 0; j--) {
      if (spaceSplit[j] == targetInstance) {
        targetClass = spaceSplit[j - 1];
        break;
      }
    }
  }
  targetClass = targetClass.replace(/\s/g, '');
  if (targetClass == "null" || (!targetClass.startsWith("vex::")))
    targetClass = undefined;
  return targetClass;
}
CodeMirror.UpdateGlobalContext = function UpdateGlobalContext(cm) {
  //console.log("updating global context..");
    //making sure language mode matches the editor language mode
    if(cm.options.languageMode){
      if(cm.options.languageMode != vex.helpsys.getLanguageMode()){
        console.log(`changing language mode to : ${cm.options.languageMode} for the editor : ${cm.options.editorType}`)
        vex.helpsys.setLanguageMode(cm.options.languageMode);
      }
    }
    else if(CodeMirror.LanguageMode){
      if(CodeMirror.LanguageMode != vex.helpsys.getLanguageMode())
        vex.helpsys.setLanguageMode(CodeMirror.LanguageMode);
    }

  //console.log(cm.getValue());
      //
      cm["_linewidgets"] = cm["_linewidgets"] ? cm["_linewidgets"] : [];
      for (var i = 0; i < cm["_linewidgets"].length; ++i)
        cm.removeLineWidget(cm["_linewidgets"][i]);
        cm["_linewidgets"].length = 0;
      //
    //****** CRITCAL  */
    __visionSensorContexts = {};
    __visionCodeContexts = {};  
  let editorContext = getVEXObjectList(cm);
  vex.helpsys.updateGlobalContext(editorContext.HeaderObjCache, editorContext.UserDefCache);
  vex.helpsys.setUsings_Config(editorContext.Usings);
}
function ShowVisionSettings(cm, lineNumber, VisionInstanceName) {
  cm.operation(function () {
      let msg = document.createElement("div");
      let btn = document.createElement("button");
      //default style for widget message and icon
      btn.className = "vision-config-widget-icon";
      msg.appendChild(btn);
      msg.className = "vision-config-widget";
      let msgTxtNode = document.createTextNode(" Configure Vision Sensor");
      if(cm.options.visionWidgetSettings){ 
        if(cm.options.visionWidgetSettings.openVisionUtil)
        btn.onclick = function(){cm.options.visionWidgetSettings.openVisionUtil(VisionInstanceName)};
            //icon style
            if(cm.options.visionWidgetSettings.iconStyle){
              let btn_style = document.createElement('style');
              btn_style.type = 'text/css';
              btn_style.innerHTML = `._temp_vision-config-widget-icon ${cm.options.visionWidgetSettings.iconStyle}`;
              document.getElementsByTagName('head')[0].appendChild(btn_style);
              btn.className = '_temp_vision-config-widget-icon';
            }
            //message style
            if(cm.options.visionWidgetSettings.textStyle){
              let txt_style = document.createElement('style');
              txt_style.type = 'text/css';
              txt_style.innerHTML = `._temp_vision-config-widget ${cm.options.visionWidgetSettings.textStyle}`;
              document.getElementsByTagName('head')[0].appendChild(txt_style);
              msg.className = '_temp_vision-config-widget';
            }
            //message text
            if(cm.options.visionWidgetSettings.message){
              msgTxtNode = document.createTextNode(cm.options.visionWidgetSettings.message);
            }
      }
      msg.appendChild(msgTxtNode);
      cm["_linewidgets"].push(cm.addLineWidget(lineNumber, msg, { coverGutter: false, handleMouseEvents:false, noHScroll: true }));
  });
}
function UpdateVisionSensorContext(cm,lineIndex,variableName,indexOfInstance){
  if(__visionSensorContexts[variableName]){
    __visionSensorContexts[variableName].codeName = variableName;
    __visionSensorContexts[variableName].lineIndex = lineIndex;
  }
  else{
    __visionSensorContexts[variableName] = {
      "sensorInstance":variableName,
      "lineIndex":lineIndex,
      "port":"disconnected",
      "brightness":"",
      "sigs":{}
    }
  }
  //
  if(indexOfInstance){
    let lineTokens = cm.getLineTokens(lineIndex);
    let paramArr = ExtractFunctionParams(lineTokens,indexOfInstance,variableName);
    //console.log(paramArr);
    for(let i =0;i<paramArr.length;i++){
      if(i==0 && paramArr[i] && paramArr[i].trim()!="")
        {__visionSensorContexts[variableName].port= paramArr[i];continue;}
      if(i==1)
      {__visionSensorContexts[variableName].brightness= paramArr[i];continue;}
      if(i>1)
      {
        __visionSensorContexts[variableName].sigs[paramArr[i]] = {"lineIndex":undefined};
      }
    }
  }
  //
  //console.log(__visionSensorContexts);
}
function UpdateVisionCodeContext(cm,lineIndex,variableName,indexOfInstance){
  if(__visionCodeContexts[variableName]){
    __visionCodeContexts[variableName].codeName = variableName;
    __visionCodeContexts[variableName].lineIndex = lineIndex;
  }
  else{
    __visionCodeContexts[variableName] = {
      "codeName":variableName,
      "lineIndex":lineIndex,
      "sigs":{}
    }
  }
  //
  //
  if(indexOfInstance){
    let lineTokens = cm.getLineTokens(lineIndex);
    let paramArr = ExtractFunctionParams(lineTokens,indexOfInstance,variableName);
    //console.log(paramArr);
    for(let i =0;i<paramArr.length;i++){
      if(paramArr[i] && paramArr[i].trim()!="")
      __visionCodeContexts[variableName].sigs[paramArr[i]] ={};
    }
  }
  //
  //console.log(__visionCodeContexts);
}
function UpdateVisionSensorContext_SIGS(HeaderObjectCache){
  let instances = Object.getOwnPropertyNames(__visionSensorContexts);
  for(let i=0;i<instances.length;i++){
    let signatures = __visionSensorContexts[instances[i]]?Object.getOwnPropertyNames(__visionSensorContexts[instances[i]].sigs):[];
    for(let j=0;j<signatures.length;j++){
      //console.log(__visionSensorContexts[instances[i]].sigs[signatures[j]]);
      //console.log(HeaderObjectCache[signatures[j]]);
      if(__visionSensorContexts[instances[i]].sigs[signatures[j]])
      __visionSensorContexts[instances[i]].sigs[signatures[j]].lineIndex = HeaderObjectCache[signatures[j]]?HeaderObjectCache[signatures[j]].lineIndex:undefined;
    }
  }
  //console.log(__visionSensorContexts);
}
function UpdateVisionSensorContext_CODES(HeaderObjectCache){
  let codes = __visionCodeContexts?Object.getOwnPropertyNames(__visionCodeContexts):[];
  for(let j=0;j<codes.length;j++){
    __visionCodeContexts[codes[j]].lineIndex = HeaderObjectCache[codes[j]]?HeaderObjectCache[codes[j]].lineIndex:undefined;
  }
  //console.log(__visionCodeContexts);
}
function ExtractFunctionParams(lineTokens,indexOfInstance,variableName){
  // extracting constrcutor params below
  let openBracketCount = 0;
  let paramStr = "";
  let Params = [];
  for(let i =Number(indexOfInstance)+1;i<lineTokens.length;i++){
    if (lineTokens[i].string.trim() == ";") break;
    if (lineTokens[i].string.trim() == "(") {
      openBracketCount++; 
      if(openBracketCount==1) continue;
    }
    if (lineTokens[i].string.trim() == ")") {openBracketCount--;}
    if(openBracketCount==0 && lineTokens[i].string.trim() == ")"){ 
      paramStr = paramStr.trim();
      if(paramStr!="") Params.push(paramStr);
      paramStr = "";
      break;
    }
    if(lineTokens[i].string.trim() == ","){
      Params.push(paramStr.trim());
      paramStr = "";
    }
    else{
      paramStr = paramStr+ lineTokens[i].string;
    }
  }
  paramStr = paramStr.trim();
  if(paramStr!="") Params.push(paramStr);
  
  return Params;
}

function UpdateVisionHeaders(cm, vison) {
  console.log("Receieved Vision config:",vison);
  //console.log(__visionSensorContexts);
  if (!(vison && vison.name)) return;
  if (vison.name == "" || __visionSensorContexts[vison.name] == undefined) return;

  /// Generating header from the config received from Vision Utility
  let port = __visionSensorContexts[vison.name].port;
  let s = [];
  let ss = [];
  let visionHeaders = { "sensorInstance": vison.name, "text": "", "sigs": {}, "codes": {} };
  //Vision Sensor name
  let name = vison.name;
  // Create signatures first;
  if (vison.config.signatures !== undefined) {

    for (let i = 0; i < vison.config.signatures.length; i++) {
      let sig = vison.config.signatures[i];
      if (sig === undefined || sig.parameters === undefined)
        continue;
      let sig_sig = 'vex::vision::signature ' + sig.name + ' (' + (i + 1) + ', '
        + sig.parameters.uMin + ', '
        + sig.parameters.uMax + ', '
        + sig.parameters.uMean + ', '
        + sig.parameters.vMin + ', '
        + sig.parameters.vMax + ', '
        + sig.parameters.vMean + ', '
        + sig.range + ', '
        + sig.parameters.type + ');';
      visionHeaders.sigs[sig.name] = sig_sig;
      ss.push(sig.name);
    }
  }
  // then do codes
  if (vison.config.codes !== undefined) {
    for (let i = 0; i < vison.config.codes.length; i++) {
      let code = vison.config.codes[i];
      let code_sig = 'vex::vision::code ' + code.name + ' (' + code.code + ' );';
      visionHeaders.codes[code.name] = code_sig;
    }
  }
  let portstr = "";
  if (port.includes("disconnected"))
    portstr = ' (# ';
  else
    portstr = ' (' + port;

  let vInstance = 'vex::vision ' + name + portstr;
  if (vison.config.brightness != undefined)
    vInstance += ', ' + vison.config.brightness;
  if (ss.length > 0)
    vInstance += ', ' + ss.join(', ')
  visionHeaders.text = (vInstance + ');');
  //console.log(visionHeaders);
  ///Updating header editor with generated header by refering to vision context
  //First update the vision sensor instance 
  if (__visionSensorContexts[visionHeaders.sensorInstance].lineIndex!=undefined) {
    let lineNo = __visionSensorContexts[visionHeaders.sensorInstance].lineIndex;
    replaceLineText(cm,lineNo,visionHeaders.text);
  }
  //second go update the sigs
  let signatures = visionHeaders.sigs?Object.getOwnPropertyNames(visionHeaders.sigs):[];
    for(let j=0;j<signatures.length;j++){
      let isSigFound = false;
      if(__visionSensorContexts[visionHeaders.sensorInstance].sigs 
        && __visionSensorContexts[visionHeaders.sensorInstance].sigs[signatures[j]]
        && __visionSensorContexts[visionHeaders.sensorInstance].sigs[signatures[j]].lineIndex
      )
        isSigFound =  true;
        
        //if sig found replace or insert above the vision sensor instance line
        if(isSigFound == true){
          let lineIndexSig = __visionSensorContexts[visionHeaders.sensorInstance].sigs[signatures[j]].lineIndex;
          replaceLineText(cm,
            lineIndexSig,
            visionHeaders.sigs[signatures[j]]
          );
        }
        else{
          insertLineAt(cm,__visionSensorContexts[visionHeaders.sensorInstance].lineIndex,visionHeaders.sigs[signatures[j]]);
        } 
    }
  //Third update the codes
  let codes = visionHeaders.codes?Object.getOwnPropertyNames(visionHeaders.codes):[];
  for(let j=0;j<codes.length;j++){
    let isCodeFound = false;
    if(__visionCodeContexts[codes[j]] 
      && __visionCodeContexts[codes[j]].lineIndex
    )
      isCodeFound = true;
      if(isCodeFound){
        let lineIndexCode = __visionCodeContexts[codes[j]].lineIndex;
        replaceLineText(cm,
          lineIndexCode,
          visionHeaders.codes[codes[j]]
        );
      }
      else{
        insertLineAt(cm,__visionSensorContexts[visionHeaders.sensorInstance].lineIndex, visionHeaders.codes[codes[j]]);
      } 
  }
}
function insertLineAt(cm, lineNo, text) {
  if(lineNo == undefined){console.log("lineNo is undefined"); return;}
  if(text == undefined) {console.log("text is undefined");return;}
  cm.replaceRange(text+'\n',{ line: lineNo, ch: 0 });
}
function replaceLineText(cm, lineNo, text){
  if(lineNo==undefined){console.log("lineNo is undefined"); return;}
  if(text==undefined) {console.log("text is undefined");return;}
  let lineTokens = cm.getLineTokens(lineNo);
  let endofLine = 0;
  if(lineTokens && lineTokens.length>0){
    endofLine = lineTokens[lineTokens.length-1].end;
  }
  cm.replaceRange(text, { line: lineNo, ch: 0 }, { line: lineNo, ch: endofLine });
}

CodeMirror.UpdateVisionSettings =  function UpdateVisionSettings(cm,config){
  if(config && cm)
    UpdateVisionHeaders(cm, config);
}

CodeMirror.UpdateLocalContext = function UpdateLocalContext(cm) {
  //console.log("updating Local context..");
    //making sure language mode matches the editor language mode
    if(cm.options.languageMode){
      if(cm.options.languageMode != vex.helpsys.getLanguageMode()){
        console.log(`changing language mode to : ${cm.options.languageMode} for the editor : ${cm.options.editorType}`)
        vex.helpsys.setLanguageMode(cm.options.languageMode);
      }
    }
    else if(CodeMirror.LanguageMode){
      if(CodeMirror.LanguageMode != vex.helpsys.getLanguageMode())
        vex.helpsys.setLanguageMode(CodeMirror.LanguageMode);
    }
  //console.log(cm.getValue());
  let editorContext = getVEXObjectList(cm);
  vex.helpsys.updateLocalContext(editorContext.HeaderObjCache, editorContext.UserDefCache);
  vex.helpsys.setIncludes(editorContext.Includes);
  vex.helpsys.setUsings_Code(editorContext.Usings);
}
CodeMirror.SetUserLevel = function SetUserLevel(level) {
  console.log("CodeMirror.SetUserLevel is obsolete: please use CodeMirror.SetLanguageMode( block or cpp or pro) ");
}
CodeMirror.GetUserLevel = function GetUserLevel() {
  console.log("CodeMirror.GetUserLevel is obsolete: please use CodeMirror.GetLanguageMode()");
}
CodeMirror.SetLanguageMode = function SetLanguageMode(mode) {
  console.log(`CodeMirror.SetLanguageMode(${mode})`);
  if (mode){
    if(CodeMirror.LanguageMode != mode){
      //update the global language mode
      CodeMirror.LanguageMode = mode;
      //update the Db's language mode
      vex.helpsys.setLanguageMode(mode);
    }
  }
}
CodeMirror.GetLanguageMode = function GetLanguageMode() {
  return vex.helpsys.getLanguageMode();
}

  function ResolvePreprocDirective(lineTokens) {
    let final = { "includes": "", "usings": [] };
    let lib = "";
    let usingFound = false;
    let nmpscFound = false;
    let lookforSemicolon = false;
    let namespacename = undefined;
    let usings = [];
    for (let i = 0; i < lineTokens.length; i++) {
      if (lineTokens[i].type == "meta") {
        let indx = lineTokens[i].string.indexOf("#include");
        if (indx > -1) {
          let _start = lineTokens[i].string.indexOf("<", indx + 8);
          if (_start > -1) {
            let _end = lineTokens[i].string.indexOf(">", _start + 1);
            if (_end > -1) {
              lib = lineTokens[i].string.substring(_start + 1, _end);
              //console.log(lib);
            }
          }
          else {
            let _start = lineTokens[i].string.indexOf(`"`, indx + 8);
            if (_start > -1) {
              let _end = lineTokens[i].string.indexOf(`"`, _start + 1);
              if (_end > -1) {
                lib = lineTokens[i].string.substring(_start + 1, _end);
                //console.log(lib);
              }
            }
          }
        }
      }
      else {
        if (lineTokens[i].type == "keyword" && lineTokens[i].string == "using") {
          usingFound = true;
        }
        if (lineTokens[i].type == "keyword" && lineTokens[i].string == "namespace" && usingFound == true) {
          nmpscFound = true;
        }
        if (lineTokens[i].type == "def" && nmpscFound == true) {
          lookforSemicolon = true;
          namespacename = lineTokens[i].string;
        }
        if (lineTokens[i].string == ";" && lookforSemicolon == true) {
          if (namespacename && vex.helpsys.IsNameSpace(namespacename) == true)
            usings.push(namespacename);
          usingFound = false;
          nmpscFound = false;
          lookforSemicolon = false;
          namespacename = undefined;
        }
      }
    }
    final = { "includes": lib, "usings": [] }
    if (usings.length > 0)
      final.usings = usings;

    return final;
  }

  function getVEXObjectList(cm) {
    let HeaderObjectCache = {};
    let UserDefinedVariableCache = {};
    let Includes = [];
    let Usings = [];
    let IsVisionContextNeeded = false;
    let IsVisionCodeContextNeeded = false;
    let count = cm.lineCount();
    for (let i = 0; i < count; i++) {
      let lineTokens = cm.getLineTokens(i);
      let _preprocs = ResolvePreprocDirective(lineTokens);
      let _usings = _preprocs.usings;
      let libfound = _preprocs.includes;
      if (libfound) Includes.push(libfound);
      for(let ui =0;ui<_usings.length;ui++){
        if(Usings.includes(_usings[ui])) continue;
        Usings.push(_usings[ui]);
      }

      //object-class-mapping
      let className;
      let variableName;
      let indexOfInstance;
      let primitiveTypeName;
      let primitiveVariableName;
      let indexOfPrimitiveVariable;
      for (let li in lineTokens) {
        if (lineTokens[li] == undefined) continue;
        if (lineTokens[li].type == "builtin") {
          if (lineTokens[li].string.includes("::") == true) {
            let arr = lineTokens[li].string.split("::");
            if (vex.helpsys.IsNameSpace(arr[0])) {

              className = lineTokens[li].string;
            }
            else {
              let possiblenmspc = vex.helpsys.whichNamespace(lineTokens[li].string, Usings, cm);
              if (possiblenmspc)
                className = possiblenmspc + "::" + lineTokens[li].string;
            }
          } else {
            let possiblenmspc = vex.helpsys.whichNamespace(lineTokens[li].string, Usings, cm);
            if (possiblenmspc)
              className = possiblenmspc + "::" + lineTokens[li].string;
          }

        }
        else {
          
          if (lineTokens[li].string.trim() == "") continue;
          //TODO: template parsing needs to be implemented.
          //This doesnt pick up the correct the type
          let patterRegx = RegExp(/[\[\]{}\(\),;<>]/);
          if(patterRegx.test(lineTokens[li].string.trim())){
            //console.log(lineTokens[li].string.trim());
            
            /* any changes to this needs to be updated for the same logic outside the loop  */
            //below is to avoid functions being detected as variables.
            /*if(lineTokens[li].string == "(") {
              primitiveTypeName = undefined;
              primitiveVariableName =  undefined;
            }*/
            if (primitiveTypeName && primitiveVariableName) {
              let kind = (lineTokens[li].string == "(")? "function" : "variable";
              UserDefinedVariableCache[primitiveVariableName] = {"TypeName" : primitiveTypeName,"kind": kind, "lineIndex": i};
              if (lineTokens[li].string.trim() != ",")
                primitiveTypeName = undefined;
              primitiveVariableName =  undefined;
            }
            /* any changes to this needs to be updated for the same logic outside the loop  */
            if (className && variableName) {
              HeaderObjectCache[variableName] = {"className" : className, "lineIndex": i};
              //
              if ( cm.options.editorType
                && cm.options.editorType == "config"
                && vex.helpsys.getLanguageMode() == "pro") {
                if(className == "vex::vision") 
                {
                  ShowVisionSettings(cm, i,variableName);
                  UpdateVisionSensorContext(cm,i,variableName,indexOfInstance);
                  IsVisionContextNeeded = true;
                }
                if(className == "vex::vision::code") 
                {
                  UpdateVisionCodeContext(cm,i,variableName,indexOfInstance);
                  IsVisionCodeContextNeeded = true; 
                }
              }
              //
              if (lineTokens[li].string.trim() != ",")
                className =  undefined;
              variableName =  undefined;
            }
            continue;
          }
         
          if (lineTokens[li].type == "type") {
            primitiveTypeName = lineTokens[li].string;
            continue;
          }
          if(primitiveTypeName && !primitiveVariableName && (lineTokens[li].type == "variable"|| lineTokens[li].type == "user" || lineTokens[li].type == "def")){
            primitiveVariableName = lineTokens[li].string;
            indexOfPrimitiveVariable = li;
            continue;
          }
          if (className && !variableName && (lineTokens[li].type == "variable"|| lineTokens[li].type == "user" || lineTokens[li].type == "instance")) {
            variableName = lineTokens[li].string;
            indexOfInstance = li;
            continue;
          }
        }
      }
      if (primitiveTypeName && primitiveVariableName) {
        UserDefinedVariableCache[primitiveVariableName] = {"TypeName" : primitiveTypeName, "lineIndex": i};
      }
      
      if (className && variableName) {
        HeaderObjectCache[variableName] = {"className" : className, "lineIndex": i};
        //
        if ( cm.options.editorType
          && cm.options.editorType == "config"
          && vex.helpsys.getLanguageMode() == "pro") {
          if(className == "vex::vision") 
          {
            ShowVisionSettings(cm, i,variableName);
            UpdateVisionSensorContext(cm,i,variableName,indexOfInstance);
            IsVisionContextNeeded = true;
          }
          if(className == "vex::vision::code") 
          {
            UpdateVisionCodeContext(cm,i,variableName,indexOfInstance);
            IsVisionCodeContextNeeded = true; 
          }
        }
        //
      }
    }
    // Update SIG info in Vision sensor context
    if (IsVisionContextNeeded == true) {
      UpdateVisionSensorContext_SIGS(HeaderObjectCache);
    }
    if (IsVisionCodeContextNeeded == true) {
      UpdateVisionSensorContext_CODES(HeaderObjectCache);
    }
    //Update preprocessor directives

    //console.log(HeaderObjectCache);
    return { "UserDefCache" : UserDefinedVariableCache,"HeaderObjCache": HeaderObjectCache, "Includes": Includes, "Usings": Usings };
  }

  function getFunctionOverloads(member,cm) {
    let list = [];
    if (member.overloads != undefined && member.overloads.length > 0) {
      for (let i = 0; i < member.overloads.length; i++) {
        if (vex.helpsys.checkUserLevel(member.overloads[i].apilevel)) {
          //

          let params = member.overloads[i].params;
          let paramCountExpected = 0;
          if (params != undefined && params.length > 0) {
            if (__arguments != undefined) {
              if (__arguments.list.length > 0)
                paramCountExpected = __arguments.selectedIndex + 1;


              if (params.length >= paramCountExpected) {
                let dtext = `${member.name}${member.overloads[i].argsstring}`;
                let completionText = undefined;

                if (params[__arguments.selectedIndex] && params[__arguments.selectedIndex].kind)
                  if (params[__arguments.selectedIndex].kind == "enum"){
                    let _pType = params[__arguments.selectedIndex].type;
                    let _pTypeArr = [];
                    if(_pType){
                      _pTypeArr = _pType.split("::");
                      if(_pTypeArr.length>1){
                        if(vex.helpsys.IsNameSpace(_pTypeArr[0])){
                          let _usingslocal = vex.helpsys.getUsings(cm);
                          if(_usingslocal.includes(_pTypeArr[0])){
                            _pType =  _pType.replace(`${_pTypeArr[0]}::`,'');
                          }
                        }
                      }
                    }
                    completionText = `${_pType}::`;

                  }
                  let displayStr = undefined;
                  displayStr = getDisplayString(member.name,member.overloads[i].argsstring,__arguments.selectedIndex ,50);
                  //console.log(displayStr);
                let hintElem = { "text":dtext ,"displayText":displayStr, "completiontext": completionText, "type": "function", "hint": _CM_HintCompleteSpecial };
                list.push(hintElem);
              }

            }
            else {
              if (params.length >= paramCountExpected) {
                let dtext = `${member.name}${member.overloads[i].argsstring}`;
                let completionText = undefined;
                let hintElem = { "text": dtext, "completiontext": completionText, "type": "function", "hint": _CM_HintCompleteSpecial };
                list.push(hintElem);
              }
            }
          }
          else {
            list.push(`${member.name}()`)
          }
          //
        }
      }
    }
    return list;
  }
//parsing arguments
function getParamList(tokens, currToken) {
  let openIndex, closeIndex;
  let param = "";
  let params = [];
  let currentParamIndx = 0;
  let paramCount = 0;
  let isInside = false;
  if (currToken.state.context.type == ")") {
    isInside = true;
    openIndex = currToken.state.context.column;

    let currIndex = findIndexByKeyValue(tokens, 'start', openIndex);

    for (let ind = currIndex + 1; ind < tokens.length; ind++) {
      if (tokens[ind].string == ")")
        break;
      else {
        if (tokens[ind].string.trim() != "" && tokens[ind].string.trim() != ",") {
          param = tokens[ind].string;
          params.push(param.trim())
          paramCount++;
          if (currToken.string.trim() == param.trim())
            currentParamIndx = paramCount - 1;
          else if (currToken.string.trim() == "," || currToken.end == tokens[ind].start) {
            currentParamIndx = paramCount;
          }
        }
      }
    }
  }
  return { "list": params, "selectedIndex": currentParamIndx, "insidePlist": isInside };
}
//parsing arguments v2
function getParamList_v2(tokens, currToken) {
  let openIndex, closeIndex;
  let param = "";
  let params = [];
  let currentParamIndx = 0;
  let paramCount = 0;
  let isInside = false;
  let selectedFnToken = "";
  if (currToken.state.context.type == ")") {
    //isInside = true;
    
    let currIndex = findIndexByKeyValue(tokens, 'start', currToken.state.context.column);
    //identiying context start & end
    if(currToken.string.trim() != "" && currToken.string != "," && currToken.string != "("){
      closeIndex = findIndexByKeyValue(tokens, 'start', currToken.start);;
      openIndex = currIndex;
      for(let ci =closeIndex;ci>openIndex;ci--){
        if(tokens[ci].string == "," 
        || tokens[ci].string == ";" 
        || tokens[ci].type == "operator"
        ){
          openIndex = ci;
          break;
        }
      }
      selectedFnToken = (tokens[currIndex-1])? tokens[currIndex-1].string: "";
      //console.log("##################");
      //for(let ti = openIndex; ti<=closeIndex;ti++){ console.log(tokens[ti].string);}
      //console.log(tokens[closeIndex].string);
      //console.log("##################");
    }
    else if(currToken.state.context.prev){
      isInside = true;
      openIndex = findIndexByKeyValue(tokens, 'start', currToken.state.context.prev.column);
      //check if context inside paramter list, if so set the open index to prev comma
      for(let ci =currIndex-1;ci>openIndex;ci--){
        if(tokens[ci].string == ","){
          openIndex = ci;
          break;
        }
      }
      if(tokens[openIndex])
        openIndex = (tokens[openIndex].string == "(" || tokens[openIndex].string == ",")? openIndex+1:openIndex;
      closeIndex = currIndex-1;

      selectedFnToken = (tokens[currIndex-1])? tokens[currIndex-1].string: "";

      //console.log("*****************");
      //for(let ti = openIndex; ti<=closeIndex;ti++){ console.log(tokens[ti].string);}
      //console.log(tokens[closeIndex].string);
      //console.log("******************");
      
    }
    let funcCount = 0;
    let paramCount_Prev=0;
    for (let ind = currIndex + 1; ind < tokens.length; ind++) {
      if (tokens[ind].string == "(" ){ 
        funcCount++;
        paramCount_Prev = paramCount;
        paramCount = 0;
      }
      if (tokens[ind].string == ")" ){
        if(funcCount == 0){
          break;
        }
        else if(funcCount > 0){
          //below concat needs to be fixed
          //check where it is used
          param = param.concat(tokens[ind].string);
          paramCount = paramCount_Prev;
          funcCount--;
        }
      }
        //console.log(tokens[ind].string);
        if (tokens[ind].string.trim() == ",") {
          paramCount++;
          params.push(param);
          param = "";
        }
        else{
          param = param.concat(tokens[ind].string);
        }
        if(currToken.start == tokens[ind].start){
          currentParamIndx = paramCount;
          params.push(param);
          param = "";
        }
    }
  }
  //console.log(currentParamIndx);
  //console.log(params);
  return { "list": params,"selectedFunc":selectedFnToken, "selectedIndex": currentParamIndx, "insidePlist": isInside,"openIndex": openIndex,"closeIndex":closeIndex };
}

function getNameSpaceORStaticMembers(currentToken,cm) {
  let obj = { "namespace": "", "class": "", "member": "" };
  if (currentToken.trim() == "") return;
  let ind = currentToken.lastIndexOf("::");
  //if (ind > 0) //coz we dont want to pull up the whole class list for just typing "::"
  {
     //this is to handle cases like vex::this_thread which itself is a namespace
     //this is a hack for nested namespace
     //TODO: need a better solution at some point
     if (vex.helpsys.IsNameSpace(currentToken)) {
      obj["namespace"] = currentToken;
      return obj;
    }
    else{
      let possible_Nmspc = vex.helpsys.whichNamespace(currentToken,undefined,cm);
      let possible_Nmspc_obj= vex.helpsys.lookup(possible_Nmspc + "::" +currentToken,undefined,possible_Nmspc);
      // workaround: "specialkind == namespace" property added to the dummy class this_thread under vex namespace 
      if(possible_Nmspc && possible_Nmspc_obj&& possible_Nmspc_obj.specialkind == "namespace"){
        obj["namespace"] = possible_Nmspc + "::" +currentToken;
        return obj;
      }
    }
    let arr = currentToken.split("::");
    let defaultNamespace = vex.helpsys.getDefaultNamespace();
    let namespacename = "";
    let classname = "";
    let membername = "";

    if (arr.length > 0) {
      if (vex.helpsys.IsNameSpace(arr[0]))
        obj["namespace"] = arr[0];
      else
        obj["namespace"] = "";
    }
    if (arr.length == 1) {
      let nmspc = (obj["namespace"]) ? obj["namespace"] : vex.helpsys.whichNamespace(arr[0],undefined,cm);//(obj["namespace"]) ? obj["namespace"] : defaultNamespace;
      if (nmspc) {
        obj["namespace"] = nmspc;
        let classname = nmspc + "::" + arr[0];
        if (vex.helpsys.IsClass(nmspc, classname))
          obj["class"] = classname;
        else if (vex.helpsys.IsNamespaceMember(nmspc, arr[0])) {
          obj["member"] = arr[0];
        }
      }
    }
    if (arr.length > 1) {
      let nmspc = (obj["namespace"]) ? obj["namespace"] : vex.helpsys.whichNamespace(arr[1],undefined,cm);
      if (nmspc) {
        let classname = nmspc + "::" + arr[1];
        if (vex.helpsys.IsClass(nmspc, classname))
          obj["class"] = classname;
        else if (vex.helpsys.IsNamespaceMember(nmspc, arr[1])) {
          obj["member"] = arr[1];
        }
        else
        obj = { "namespace": "", "class": "", "member": ""};
      }
    }
    if (arr.length > 2) {
      if (obj["member"] && obj["class"] == "") {
        let nmspc = vex.helpsys.whichNamespace(obj["member"],obj["namespace"],cm);
        if (nmspc)
          obj = { "namespace": nmspc, "class": "", "member": "", "enum": obj["member"] };
         else
           obj = { "namespace": "", "class": "", "member": ""};
      }
    }
  }
  return obj;

}

  function getStaticMembers(currToken, currentIndex,tokens,cm) {
  //console.log(currToken);
  let members = undefined;
  let filterstring = "";
  let ind = currToken.string.lastIndexOf("::");
  //this is to make sure static/namespace member functions shows hints when opening brackets after function name.
  if(ind == -1){
    if(currToken.string == "(" && tokens[currentIndex-1]){
      currToken = tokens[currentIndex-1];
      ind = currToken.string.lastIndexOf("::");
    }
  }
  if (ind > 0) //coz we dont want to pull up the whole class list for just typing "::"
  {
    let possibleClass = currToken.string.substring(0, ind);

    if ((ind + 2) <= (currToken.string.length - 1))
      filterstring = currToken.string.substring(ind + 2, currToken.string.length);
    /// namespace members lookup
    let tokenInfo = getNameSpaceORStaticMembers(possibleClass,cm);
    //console.log(tokenInfo);
    //namespace member lookup
    if(tokenInfo.class == ""){
      members = vex.helpsys.getMembers("", true,tokenInfo.namespace, tokenInfo.member);
      let memberInfo = vex.helpsys.lookup("", filterstring,tokenInfo.namespace);
      if(memberInfo && memberInfo.kind == "function"){
        return ({ "classname": "", "namespace":tokenInfo.namespace, "list": getFunctionOverloads(memberInfo, cm), "start": (currToken.start + ind + 2), "filter": false });
      }
      else
        return { "classname":"","namespace":tokenInfo.namespace, "enumMember": tokenInfo.member,"list": members, "start": (currToken.start + ind + 2), "filtertoken": filterstring };
    }
    else
      possibleClass = tokenInfo.class;


    /// class member look up
    let memberInfo = vex.helpsys.lookup(possibleClass, filterstring,tokenInfo.namespace);

    if (memberInfo != undefined && memberInfo.kind == "variable") {
      possibleClass = memberInfo.type[0];
    }
    else if (memberInfo != undefined && memberInfo.kind == "function") {
      return ({ "classname": possibleClass, "list": getFunctionOverloads(memberInfo, cm), "start": (currToken.start + ind + 2), "filter": false });
    }
    ///
    members = vex.helpsys.getMembers(possibleClass, true);
    return { "classname": possibleClass, "list": members, "start": (currToken.start + ind + 2), "filtertoken": filterstring };
  }
  return;
}
function switchToGlobalContext(currToken, cm) {
  __context = "_global";
  __globalContext = vex.helpsys.getAllContext(); // optimize this.we might not need to call this everytime.
  let _contextMembers = [];
  if (__globalContext && Object.getOwnPropertyNames(__globalContext).length > 0)
    _contextMembers = Object.getOwnPropertyNames(__globalContext);
  else {
    console.log("warning:robot-config.h is empty or not included! ");
  }

  //__namespace = vex.helpsys.getDefaultNamespace();
  let _usingslocal = vex.helpsys.getUsings(cm);
  let nmpcmembers = [];
  for (let o = 0; o < _usingslocal.length; o++) {
    nmpcmembers = nmpcmembers.concat(vex.helpsys.getMembers("", true, _usingslocal[o]));
  }
  let consolidatedMembs = _contextMembers.concat(nmpcmembers);

  let glist = { "list": consolidatedMembs, "start": currToken.start};
  
  glist["filtertoken"] = currToken.string;

  return glist;
}
function getConstructor(tokens, currToken, cm){
  if(__arguments && __arguments.insidePlist == true && __arguments.openIndex!=undefined && __arguments.closeIndex!=undefined){
    if(__arguments.closeIndex > -1 && __arguments.openIndex > -1){
      let _consContext = [];
      for (let ind = __arguments.closeIndex; ind >= __arguments.openIndex; ind--) {
        if(tokens[ind].string.trim()!=""){
          _consContext.push(tokens[ind]);
        }
      }
      //console.log(_consContext);
      if(_consContext.length>=1){
        let ___className;;
        if(_consContext[0].type == "builtin")
          ___className  = _consContext[0].string;
        else if(
          _consContext[0].type == "instance" 
          && _consContext[1] 
          && _consContext[1].type == "builtin")
            ___className  = _consContext[1].string;
        if(___className)
        {
          //console.log(_consContext[1]);
          let _classInfo = getNameSpaceORStaticMembers(___className, cm);
          //console.log(_classInfo);
          let constrName = vex.helpsys.getJustClassName(_classInfo.class);
          //console.log(constrName);
          let constrInfo = vex.helpsys.lookup(_classInfo.class, constrName);
          //console.log(constrInfo);
          if(constrInfo && constrInfo.specialkind == "constructor"){
            __context = _classInfo.class;
            let lst = getFunctionOverloads(constrInfo, cm);
      
            return ({ "list": lst, "start": currToken.start, "filter": false ,"donotcomplete" : true});
          }
        }
      }
    }
  }
}
function getMemberList(cm, tokens, currToken, IsByKeyPress) {
  // below check is to avoid showing autocomplete/hints for Instances in CPP header editor
 if ( cm.options.editorType
  && cm.options.editorType == "config"
  && vex.helpsys.getLanguageMode() != "pro"
  ){
    return { "list": undefined };
  }
  __namespace = undefined;
  __arguments = getParamList_v2(tokens, currToken);
  let currIndex = findIndexByKeyValue(tokens, 'start', currToken.start)
  if(__arguments.insidePlist == false  && currToken.string.trim() == ""){
    if(IsByKeyPress && IsByKeyPress == true) 
       return { "list": undefined };
 }
 let constructors = getConstructor(tokens, currToken,cm)
  if (constructors) {
    return constructors;
  }
  let staticmembers = getStaticMembers(currToken,currIndex,tokens,cm);
  if (staticmembers) {
    if (staticmembers.classname != "" || staticmembers.namespace != "") {
      __context = staticmembers.classname;
      __namespace = staticmembers.namespace;
      __member = staticmembers.enumMember;
      return ({ "list": staticmembers.list, "start": staticmembers.start, "filter": staticmembers.filter, "filtertoken": staticmembers.filtertoken });
    }
  }
 // below check is to avoid showing autocomplete/hints for Instances in header editor
 if ( cm.options.editorType
  && cm.options.editorType == "config"){
    return { "list": undefined };
  }
  let className; 
  let endIndex = 0;
  if(__arguments /*&& __arguments.insidePlist == true */&& __arguments.openIndex!=undefined && __arguments.closeIndex!=undefined){
    if(__arguments.closeIndex > -1 && __arguments.openIndex > -1){
      currIndex = __arguments.closeIndex;
      endIndex = __arguments.openIndex;
    }
  }

//checking if user is trying to access members using classname instead of instance
if(currToken.string == "." && tokens[currIndex-1]){
  if(!(tokens[currIndex-1].type=="instance" || tokens[currIndex-1].type=="variable"))
   return { "list": undefined };
}

 let _contextArray = [];
 function checkIfValid(ind){
   return tokens[ind].string != ";" 
         && tokens[ind].string.trim() != "" 
         && tokens[ind].string != "(" 
         && tokens[ind].string != "{" 
         && tokens[ind].string != "}" 
         && tokens[ind].string != ","
         && tokens[ind].type != "operator";
 }
 for (let ind = currIndex; ind >= endIndex; ind--) {
   if(tokens[ind]== undefined) break;
   if (tokens[ind].string == ";") break;
   if (tokens[ind].string == ")") break; //closing context when used inside default constructs
   if (tokens[ind].string == "{") break;
   if (tokens[ind].type == "operator") break;
   if (__arguments.insidePlist != true && tokens[ind].string.trim() == "") break;

   if(tokens[ind].string == ".") continue;

   if ((tokens[ind-1] && tokens[ind-1].string == "." )|| (tokens[ind+1] && tokens[ind+1].string == ".")){
     if(checkIfValid(ind))
     _contextArray.push(tokens[ind]);
   }
 }

  if (_contextArray.length == 0) {
    //if (__arguments.insidePlist == true) {
      if (currToken.state.context && currToken.state.context.prev && currToken.state.context.prev.type) {
        //console.log(currToken.state.context.prev.type);
        if(currToken.string == "(" || currToken.string == ")" || currToken.string == "{" || currToken.string == "}")
        return { "list": undefined };
      }
    //}
    return switchToGlobalContext(currToken, cm);
  }
  while (_contextArray.length) {
    let tokenToResolve = _contextArray.pop();
    //console.log(`${tokenToResolve.string}`);
    className = vex.helpsys.getType(tokenToResolve.string);
    if (className == undefined) {
      //Todo:look up in the DB/local context
      let memberInfo;
      if (__context != undefined) {
        memberInfo = vex.helpsys.lookup(__context, tokenToResolve.string);
        if(memberInfo == undefined && (currToken.string == "." || currToken.string == "(")) return { "list": undefined };
        if (memberInfo != undefined && memberInfo.kind == "variable") {
          className = memberInfo.type[0];
          if (currToken.string == "(" && _contextArray.length==0) 
              return { "list": undefined };
        }
        else if (memberInfo != undefined && memberInfo.kind == "function") {
          let lst;
          if (currToken.string != ")"){
            //
            if(__arguments && (memberInfo.name != __arguments.selectedFunc)) 
              __arguments.selectedIndex = 0;
            lst = getFunctionOverloads(memberInfo, cm);
          }
          return ({ "list": lst, "start": tokenToResolve.start, "filter": false });
        }
      }
    }
    __context = (className) ? className : __context;
  }
  //console.log("Resolved : " + className);
  return ({ "list": vex.helpsys.getMembers((className) ? className : __context), "start": currToken.start });
}
function _CM_InsertTextAtCursor(editor, text) {
  var doc = editor.getDoc();
  var cursor = doc.getCursor();
  doc.replaceRange(text, cursor);
}
function _showHint(cm) {
  var doc = cm.getDoc();
  var cursor = cm.getCursor();
  var token = cm.getTokenAt(cursor);
  let start = token.start;
  var end = cursor.ch;
  var line = cursor.line;
  var lineToken = cm.getLineTokens(line);
  var mlistobj = getMemberList(cm, lineToken, token, cm.IsByKeyPress);
  var list = mlistobj.list || [];
  var replacePos = mlistobj.start;
  var filtertoken = mlistobj.filtertoken;
  start = end;
  if (list != undefined) {
    if (token.string != "." && token.string != "(" && token.string != ";") {
      if (mlistobj.filter != false) {
        if (filtertoken != undefined) {
          if (filtertoken.trim().length > 0) //allowing caseinsensitve lookup
          list = list.filter((elem) => elem.toLowerCase().startsWith(filtertoken.toLowerCase()));
          start = replacePos;
        }
        else {
          if (token.string.trim().length > 0)
          list = list.filter((elem) => elem.toLowerCase().startsWith(token.string.toLowerCase()));
          start = token.start;
        }
      }
      else
        start = replacePos;
    }
    if (token.string == "(") {
      start = replacePos;
    }
  }
  return {
    list: list.length ? list : "",
    from: CodeMirror.Pos(line, start),
    to: CodeMirror.Pos(line, end), // double check
    donotcomplete: mlistobj.donotcomplete
  };
}

function getDisplayString(membername, argstring, position, allowedLength) {
    let justargs = argstring.replace("(", "").replace(")", "");
    let original = membername + argstring;
    let splt = justargs.split(",");
    for (let i = 0; i < splt.length; i++) {
      if ((i) == position) {
        if (splt[i]) {
          //splt[i] = "&lt;b&gt;" + splt[i] + "&lt;/b&gt;"
          splt[i] = "<u>" + splt[i] + "</u>"
        }
      }
    }
    allowedLength =  allowedLength+7;
    let dps = membername + "(" + splt.join() + ")";
    if (dps.length <= allowedLength)
      return dps;
    else {
      let pIndx = (position>0)?GetSubstringIndex(dps, ",", position):0;
      let startIndx = 0;
      let endIndx = dps.length - 1;
      if ((endIndx - pIndx) >= allowedLength) {
        if(pIndx<(allowedLength))
          return (dps.substring(startIndx, startIndx + allowedLength - 3) + "...");
        else
          return ("..." + dps.substring(pIndx, pIndx + allowedLength - 3) + "...");
      }
      else {

        return ("..." + dps.substring(pIndx, pIndx + allowedLength));
      }
    }
}
function GetSubstringIndex(str, substring, n) {
  var times = 0, index = null;
  while (times < n && index !== -1) {
      index = str.indexOf(substring, index+1);
      times++;
  }
  return index;
}
function _CM_HintCompleteSpecial(cm,data,completion){
  //console.log(completion);
  if(completion.completiontext){
    let doc = cm.getDoc();
    let cursor = cm.getCursor();
    var token = cm.getTokenAt(cursor);
    //console.log(token);

    if(token.string!="(" && __arguments && __arguments.insidePlist==false)
      doc.replaceRange("("+completion.completiontext, cursor);
    else if(token.string.trim() =="" || token.string =="(" || token.string ==",")
      doc.replaceRange(completion.completiontext, cursor);
      
    ShowHintDropDown(cm); //double check for infinite loop
  }
}
function ShowHintDropDown(cm,IsByKeyPress) {
  if(CodeMirror._IsAutoCompleteOn==true){
    cm["IsByKeyPress"] = IsByKeyPress;
    CodeMirror.showHint(cm, _showHint, { completeSingle: false });
  }
}
/***************************** Tool Tip ********************************************/
function GetToolTipElement(selectedItem,cm) {
    if (CodeMirror._IsToolTipOn == true) {
      selectedItem = selectedItem?selectedItem.trim():selectedItem;
      let funcInd = selectedItem.indexOf("(");
      let argsstring;
      let oveloadparams;
      if (funcInd > 0) { //assuming the tooltip lookup token wont start with (
        argsstring = selectedItem.substring(funcInd).replace(/&amp;/g, '&');;
        selectedItem = selectedItem.substring(0, funcInd).replace(/&amp;/g, '&');;
      }
      let helpitem;
      if (__context == "_global") {
        if (__globalContext[selectedItem]) {
          let def = `${__globalContext[selectedItem].className} ${selectedItem}`;
          helpitem = { "name": selectedItem, "kind": "class", "def": def, "desc": "" }; // should be pulled from DB -later
        }
        else if (__namespace && vex.helpsys.IsNamespaceMember(__namespace, selectedItem)) {
          helpitem = vex.helpsys.lookup("", selectedItem, __namespace);
        }
        else if (__namespace == undefined) {
          let possiblenmspc = vex.helpsys.whichNamespace(selectedItem,undefined,cm);
          if (vex.helpsys.IsNamespaceMember(possiblenmspc, selectedItem)) {
            helpitem = vex.helpsys.lookup("", selectedItem, possiblenmspc);
          }
          else {
            helpitem = vex.helpsys.lookup(`${possiblenmspc}::${selectedItem}`, undefined, possiblenmspc);
          }
        }
        else //add check namespace member "IsNamespacemember()" & update lookup function to get nmspcmems
          helpitem = vex.helpsys.lookup(`${__namespace}::${selectedItem}`, undefined, __namespace);
      }
      else {
        if (__context != "")
          helpitem = vex.helpsys.lookup(__context, selectedItem);
        else if (vex.helpsys.IsNamespaceMember(__namespace, selectedItem)) {
          helpitem = vex.helpsys.lookup(__context, selectedItem, __namespace);

        } else if (vex.helpsys.IsNamespaceMember(__namespace, __member)) {
          helpitem = vex.helpsys.lookup(__context, __member, __namespace);
          if (helpitem.kind == "enum")
            helpitem = vex.helpsys.lookup(__context, __member, __namespace, selectedItem);
        }
        else //add check namespace member "IsNamespacemember()" & update lookup function to get nmspcmems
          helpitem = vex.helpsys.lookup(`${__namespace}::${selectedItem}`, undefined, __namespace);
      }

      if (helpitem === undefined || helpitem == "")
        return;
      if (argsstring != undefined) {
        oveloadparams = { "argsstring": '', "argindx": __arguments.selectedIndex, "args": [] };
        oveloadparams.argsstring = argsstring;
      }
      var help = vex.helpsys.showTooltip(helpitem, oveloadparams);
      return help;
    }
    return "";
}
/***************************** Helpers **********************************************/
function findIndexByKeyValue(_array, key, value) {
  for (var i = 0; i < _array.length; i++) {
    if (_array[i][key] == value) {
      return i;
    }
  }
  return -1;
}
//Update the version number here for tracking and debugging purpose
let ___CM_CPP_AC_Version = "20180807.18.10"
function get_CM_CPP_AC_Version(){
  return ___CM_CPP_AC_Version;
}
});
